)]}'
{"version":3,"file":"demoarea.js","sources":["../../../packages/rtl/rtl.js","../../../packages/rtl/system.pas","../../../packages/rtl/js.pas","../../../packages/rtl/sysutils.pas","../../../packages/rtl/math.pas","../../../packages/chartjs/chartjs.pas","../demoarea.lpr"],"sourcesContent":["var pas = {};\n\nvar rtl = {\n\n  version: 10408,\n\n  quiet: false,\n  debug_load_units: false,\n  debug_rtti: false,\n\n  debug: function(){\n    if (rtl.quiet || !console || !console.log) return;\n    console.log(arguments);\n  },\n\n  error: function(s){\n    rtl.debug('Error: ',s);\n    throw s;\n  },\n\n  warn: function(s){\n    rtl.debug('Warn: ',s);\n  },\n\n  checkVersion: function(v){\n    if (rtl.version != v) throw \"expected rtl version \"+v+\", but found \"+rtl.version;\n  },\n\n  hiInt: Math.pow(2,53),\n\n  hasString: function(s){\n    return rtl.isString(s) && (s.length>0);\n  },\n\n  isArray: function(a) {\n    return Array.isArray(a);\n  },\n\n  isFunction: function(f){\n    return typeof(f)===\"function\";\n  },\n\n  isModule: function(m){\n    return rtl.isObject(m) && rtl.hasString(m.$name) && (pas[m.$name]===m);\n  },\n\n  isImplementation: function(m){\n    return rtl.isObject(m) && rtl.isModule(m.$module) && (m.$module.$impl===m);\n  },\n\n  isNumber: function(n){\n    return typeof(n)===\"number\";\n  },\n\n  isObject: function(o){\n    var s=typeof(o);\n    return (typeof(o)===\"object\") && (o!=null);\n  },\n\n  isString: function(s){\n    return typeof(s)===\"string\";\n  },\n\n  getNumber: function(n){\n    return typeof(n)===\"number\"?n:NaN;\n  },\n\n  getChar: function(c){\n    return ((typeof(c)===\"string\") && (c.length===1)) ? c : \"\";\n  },\n\n  getObject: function(o){\n    return ((typeof(o)===\"object\") || (typeof(o)==='function')) ? o : null;\n  },\n\n  isTRecord: function(type){\n    return (rtl.isObject(type) && type.hasOwnProperty('$new') && (typeof(type.$new)==='function'));\n  },\n\n  isPasClass: function(type){\n    return (rtl.isObject(type) && type.hasOwnProperty('$classname') && rtl.isObject(type.$module));\n  },\n\n  isPasClassInstance: function(type){\n    return (rtl.isObject(type) && rtl.isPasClass(type.$class));\n  },\n\n  hexStr: function(n,digits){\n    return (\"000000000000000\"+n.toString(16).toUpperCase()).slice(-digits);\n  },\n\n  m_loading: 0,\n  m_loading_intf: 1,\n  m_intf_loaded: 2,\n  m_loading_impl: 3, // loading all used unit\n  m_initializing: 4, // running initialization\n  m_initialized: 5,\n\n  module: function(module_name, intfuseslist, intfcode, impluseslist, implcode){\n    if (rtl.debug_load_units) rtl.debug('rtl.module name=\"'+module_name+'\" intfuses='+intfuseslist+' impluses='+impluseslist+' hasimplcode='+rtl.isFunction(implcode));\n    if (!rtl.hasString(module_name)) rtl.error('invalid module name \"'+module_name+'\"');\n    if (!rtl.isArray(intfuseslist)) rtl.error('invalid interface useslist of \"'+module_name+'\"');\n    if (!rtl.isFunction(intfcode)) rtl.error('invalid interface code of \"'+module_name+'\"');\n    if (!(impluseslist==undefined) && !rtl.isArray(impluseslist)) rtl.error('invalid implementation useslist of \"'+module_name+'\"');\n    if (!(implcode==undefined) && !rtl.isFunction(implcode)) rtl.error('invalid implementation code of \"'+module_name+'\"');\n\n    if (pas[module_name])\n      rtl.error('module \"'+module_name+'\" is already registered');\n\n    var module = pas[module_name] = {\n      $name: module_name,\n      $intfuseslist: intfuseslist,\n      $impluseslist: impluseslist,\n      $state: rtl.m_loading,\n      $intfcode: intfcode,\n      $implcode: implcode,\n      $impl: null,\n      $rtti: Object.create(rtl.tSectionRTTI)\n    };\n    module.$rtti.$module = module;\n    if (implcode) module.$impl = {\n      $module: module,\n      $rtti: module.$rtti\n    };\n  },\n\n  exitcode: 0,\n\n  run: function(module_name){\n  \n    function doRun(){\n      if (!rtl.hasString(module_name)) module_name='program';\n      if (rtl.debug_load_units) rtl.debug('rtl.run module=\"'+module_name+'\"');\n      rtl.initRTTI();\n      var module = pas[module_name];\n      if (!module) rtl.error('rtl.run module \"'+module_name+'\" missing');\n      rtl.loadintf(module);\n      rtl.loadimpl(module);\n      if (module_name=='program'){\n        if (rtl.debug_load_units) rtl.debug('running $main');\n        var r = pas.program.$main();\n        if (rtl.isNumber(r)) rtl.exitcode = r;\n      }\n    }\n    \n    if (rtl.showUncaughtExceptions) {\n      try{\n        doRun();\n      } catch(re) {\n        var errMsg = rtl.hasString(re.$classname) ? re.$classname : '';\n\t    errMsg +=  ((errMsg) ? ': ' : '') + (re.hasOwnProperty('fMessage') ? re.fMessage : re);\n        alert('Uncaught Exception : '+errMsg);\n        rtl.exitCode = 216;\n      }\n    } else {\n      doRun();\n    }\n    return rtl.exitcode;\n  },\n\n  loadintf: function(module){\n    if (module.$state>rtl.m_loading_intf) return; // already finished\n    if (rtl.debug_load_units) rtl.debug('loadintf: \"'+module.$name+'\"');\n    if (module.$state===rtl.m_loading_intf)\n      rtl.error('unit cycle detected \"'+module.$name+'\"');\n    module.$state=rtl.m_loading_intf;\n    // load interfaces of interface useslist\n    rtl.loaduseslist(module,module.$intfuseslist,rtl.loadintf);\n    // run interface\n    if (rtl.debug_load_units) rtl.debug('loadintf: run intf of \"'+module.$name+'\"');\n    module.$intfcode(module.$intfuseslist);\n    // success\n    module.$state=rtl.m_intf_loaded;\n    // Note: units only used in implementations are not yet loaded (not even their interfaces)\n  },\n\n  loaduseslist: function(module,useslist,f){\n    if (useslist==undefined) return;\n    for (var i in useslist){\n      var unitname=useslist[i];\n      if (rtl.debug_load_units) rtl.debug('loaduseslist of \"'+module.$name+'\" uses=\"'+unitname+'\"');\n      if (pas[unitname]==undefined)\n        rtl.error('module \"'+module.$name+'\" misses \"'+unitname+'\"');\n      f(pas[unitname]);\n    }\n  },\n\n  loadimpl: function(module){\n    if (module.$state>=rtl.m_loading_impl) return; // already processing\n    if (module.$state<rtl.m_intf_loaded) rtl.error('loadimpl: interface not loaded of \"'+module.$name+'\"');\n    if (rtl.debug_load_units) rtl.debug('loadimpl: load uses of \"'+module.$name+'\"');\n    module.$state=rtl.m_loading_impl;\n    // load interfaces of implementation useslist\n    rtl.loaduseslist(module,module.$impluseslist,rtl.loadintf);\n    // load implementation of interfaces useslist\n    rtl.loaduseslist(module,module.$intfuseslist,rtl.loadimpl);\n    // load implementation of implementation useslist\n    rtl.loaduseslist(module,module.$impluseslist,rtl.loadimpl);\n    // Note: At this point all interfaces used by this unit are loaded. If\n    //   there are implementation uses cycles some used units might not yet be\n    //   initialized. This is by design.\n    // run implementation\n    if (rtl.debug_load_units) rtl.debug('loadimpl: run impl of \"'+module.$name+'\"');\n    if (rtl.isFunction(module.$implcode)) module.$implcode(module.$impluseslist);\n    // run initialization\n    if (rtl.debug_load_units) rtl.debug('loadimpl: run init of \"'+module.$name+'\"');\n    module.$state=rtl.m_initializing;\n    if (rtl.isFunction(module.$init)) module.$init();\n    // unit initialized\n    module.$state=rtl.m_initialized;\n  },\n\n  createCallback: function(scope, fn){\n    var cb;\n    if (typeof(fn)==='string'){\n      cb = function(){\n        return scope[fn].apply(scope,arguments);\n      };\n    } else {\n      cb = function(){\n        return fn.apply(scope,arguments);\n      };\n    };\n    cb.scope = scope;\n    cb.fn = fn;\n    return cb;\n  },\n\n  cloneCallback: function(cb){\n    return rtl.createCallback(cb.scope,cb.fn);\n  },\n\n  eqCallback: function(a,b){\n    // can be a function or a function wrapper\n    if (a==b){\n      return true;\n    } else {\n      return (a!=null) && (b!=null) && (a.fn) && (a.scope===b.scope) && (a.fn==b.fn);\n    }\n  },\n\n  initStruct: function(c,parent,name){\n    if ((parent.$module) && (parent.$module.$impl===parent)) parent=parent.$module;\n    c.$parent = parent;\n    if (rtl.isModule(parent)){\n      c.$module = parent;\n      c.$name = name;\n    } else {\n      c.$module = parent.$module;\n      c.$name = parent.$name+'.'+name;\n    };\n    return parent;\n  },\n\n  initClass: function(c,parent,name,initfn){\n    parent[name] = c;\n    c.$class = c; // Note: o.$class === Object.getPrototypeOf(o)\n    c.$classname = name;\n    parent = rtl.initStruct(c,parent,name);\n    c.$fullname = parent.$name+'.'+name;\n    // rtti\n    if (rtl.debug_rtti) rtl.debug('initClass '+c.$fullname);\n    var t = c.$module.$rtti.$Class(c.$name,{ \"class\": c });\n    c.$rtti = t;\n    if (rtl.isObject(c.$ancestor)) t.ancestor = c.$ancestor.$rtti;\n    if (!t.ancestor) t.ancestor = null;\n    // init members\n    initfn.call(c);\n  },\n\n  createClass: function(parent,name,ancestor,initfn){\n    // create a normal class,\n    // ancestor must be null or a normal class,\n    // the root ancestor can be an external class\n    var c = null;\n    if (ancestor != null){\n      c = Object.create(ancestor);\n      c.$ancestor = ancestor;\n      // Note:\n      // if root is an \"object\" then c.$ancestor === Object.getPrototypeOf(c)\n      // if root is a \"function\" then c.$ancestor === c.__proto__, Object.getPrototypeOf(c) returns the root\n    } else {\n      c = {};\n      c.$create = function(fn,args){\n        if (args == undefined) args = [];\n        var o = Object.create(this);\n        o.$init();\n        try{\n          if (typeof(fn)===\"string\"){\n            o[fn].apply(o,args);\n          } else {\n            fn.apply(o,args);\n          };\n          o.AfterConstruction();\n        } catch($e){\n          // do not call BeforeDestruction\n          if (o.Destroy) o.Destroy();\n          o.$final();\n          throw $e;\n        }\n        return o;\n      };\n      c.$destroy = function(fnname){\n        this.BeforeDestruction();\n        if (this[fnname]) this[fnname]();\n        this.$final();\n      };\n    };\n    rtl.initClass(c,parent,name,initfn);\n  },\n\n  createClassExt: function(parent,name,ancestor,newinstancefnname,initfn){\n    // Create a class using an external ancestor.\n    // If newinstancefnname is given, use that function to create the new object.\n    // If exist call BeforeDestruction and AfterConstruction.\n    var c = Object.create(ancestor);\n    c.$create = function(fn,args){\n      if (args == undefined) args = [];\n      var o = null;\n      if (newinstancefnname.length>0){\n        o = this[newinstancefnname](fn,args);\n      } else {\n        o = Object.create(this);\n      }\n      if (o.$init) o.$init();\n      try{\n        if (typeof(fn)===\"string\"){\n          o[fn].apply(o,args);\n        } else {\n          fn.apply(o,args);\n        };\n        if (o.AfterConstruction) o.AfterConstruction();\n      } catch($e){\n        // do not call BeforeDestruction\n        if (o.Destroy) o.Destroy();\n        if (o.$final) this.$final();\n        throw $e;\n      }\n      return o;\n    };\n    c.$destroy = function(fnname){\n      if (this.BeforeDestruction) this.BeforeDestruction();\n      if (this[fnname]) this[fnname]();\n      if (this.$final) this.$final();\n    };\n    rtl.initClass(c,parent,name,initfn);\n  },\n\n  createHelper: function(parent,name,ancestor,initfn){\n    // create a helper,\n    // ancestor must be null or a helper,\n    var c = null;\n    if (ancestor != null){\n      c = Object.create(ancestor);\n      c.$ancestor = ancestor;\n      // c.$ancestor === Object.getPrototypeOf(c)\n    } else {\n      c = {};\n    };\n    parent[name] = c;\n    c.$class = c; // Note: o.$class === Object.getPrototypeOf(o)\n    c.$classname = name;\n    parent = rtl.initStruct(c,parent,name);\n    c.$fullname = parent.$name+'.'+name;\n    // rtti\n    var t = c.$module.$rtti.$Helper(c.$name,{ \"helper\": c });\n    c.$rtti = t;\n    if (rtl.isObject(ancestor)) t.ancestor = ancestor.$rtti;\n    if (!t.ancestor) t.ancestor = null;\n    // init members\n    initfn.call(c);\n  },\n\n  tObjectDestroy: \"Destroy\",\n\n  free: function(obj,name){\n    if (obj[name]==null) return;\n    obj[name].$destroy(rtl.tObjectDestroy);\n    obj[name]=null;\n  },\n\n  freeLoc: function(obj){\n    if (obj==null) return;\n    obj.$destroy(rtl.tObjectDestroy);\n    return null;\n  },\n\n  recNewT: function(parent,name,initfn,full){\n    // create new record type\n    var t = {};\n    if (parent) parent[name] = t;\n    function hide(prop){\n      Object.defineProperty(t,prop,{enumerable:false});\n    }\n    if (full){\n      rtl.initStruct(t,parent,name);\n      t.$record = t;\n      hide('$record');\n      hide('$name');\n      hide('$parent');\n      hide('$module');\n    }\n    initfn.call(t);\n    if (!t.$new){\n      t.$new = function(){ return Object.create(this); };\n    }\n    t.$clone = function(r){ return this.$new().$assign(r); };\n    hide('$new');\n    hide('$clone');\n    hide('$eq');\n    hide('$assign');\n    return t;\n  },\n\n  is: function(instance,type){\n    return type.isPrototypeOf(instance) || (instance===type);\n  },\n\n  isExt: function(instance,type,mode){\n    // mode===1 means instance must be a Pascal class instance\n    // mode===2 means instance must be a Pascal class\n    // Notes:\n    // isPrototypeOf and instanceof return false on equal\n    // isPrototypeOf does not work for Date.isPrototypeOf(new Date())\n    //   so if isPrototypeOf is false test with instanceof\n    // instanceof needs a function on right side\n    if (instance == null) return false; // Note: ==null checks for undefined too\n    if ((typeof(type) !== 'object') && (typeof(type) !== 'function')) return false;\n    if (instance === type){\n      if (mode===1) return false;\n      if (mode===2) return rtl.isPasClass(instance);\n      return true;\n    }\n    if (type.isPrototypeOf && type.isPrototypeOf(instance)){\n      if (mode===1) return rtl.isPasClassInstance(instance);\n      if (mode===2) return rtl.isPasClass(instance);\n      return true;\n    }\n    if ((typeof type == 'function') && (instance instanceof type)) return true;\n    return false;\n  },\n\n  Exception: null,\n  EInvalidCast: null,\n  EAbstractError: null,\n  ERangeError: null,\n  EPropWriteOnly: null,\n\n  raiseE: function(typename){\n    var t = rtl[typename];\n    if (t==null){\n      var mod = pas.SysUtils;\n      if (!mod) mod = pas.sysutils;\n      if (mod){\n        t = mod[typename];\n        if (!t) t = mod[typename.toLowerCase()];\n        if (!t) t = mod['Exception'];\n        if (!t) t = mod['exception'];\n      }\n    }\n    if (t){\n      if (t.Create){\n        throw t.$create(\"Create\");\n      } else if (t.create){\n        throw t.$create(\"create\");\n      }\n    }\n    if (typename === \"EInvalidCast\") throw \"invalid type cast\";\n    if (typename === \"EAbstractError\") throw \"Abstract method called\";\n    if (typename === \"ERangeError\") throw \"range error\";\n    throw typename;\n  },\n\n  as: function(instance,type){\n    if((instance === null) || rtl.is(instance,type)) return instance;\n    rtl.raiseE(\"EInvalidCast\");\n  },\n\n  asExt: function(instance,type,mode){\n    if((instance === null) || rtl.isExt(instance,type,mode)) return instance;\n    rtl.raiseE(\"EInvalidCast\");\n  },\n\n  createInterface: function(module, name, guid, fnnames, ancestor, initfn){\n    //console.log('createInterface name=\"'+name+'\" guid=\"'+guid+'\" names='+fnnames);\n    var i = ancestor?Object.create(ancestor):{};\n    module[name] = i;\n    i.$module = module;\n    i.$name = name;\n    i.$fullname = module.$name+'.'+name;\n    i.$guid = guid;\n    i.$guidr = null;\n    i.$names = fnnames?fnnames:[];\n    if (rtl.isFunction(initfn)){\n      // rtti\n      if (rtl.debug_rtti) rtl.debug('createInterface '+i.$fullname);\n      var t = i.$module.$rtti.$Interface(name,{ \"interface\": i, module: module });\n      i.$rtti = t;\n      if (ancestor) t.ancestor = ancestor.$rtti;\n      if (!t.ancestor) t.ancestor = null;\n      initfn.call(i);\n    }\n    return i;\n  },\n\n  strToGUIDR: function(s,g){\n    var p = 0;\n    function n(l){\n      var h = s.substr(p,l);\n      p+=l;\n      return parseInt(h,16);\n    }\n    p+=1; // skip {\n    g.D1 = n(8);\n    p+=1; // skip -\n    g.D2 = n(4);\n    p+=1; // skip -\n    g.D3 = n(4);\n    p+=1; // skip -\n    if (!g.D4) g.D4=[];\n    g.D4[0] = n(2);\n    g.D4[1] = n(2);\n    p+=1; // skip -\n    for(var i=2; i<8; i++) g.D4[i] = n(2);\n    return g;\n  },\n\n  guidrToStr: function(g){\n    if (g.$intf) return g.$intf.$guid;\n    var h = rtl.hexStr;\n    var s='{'+h(g.D1,8)+'-'+h(g.D2,4)+'-'+h(g.D3,4)+'-'+h(g.D4[0],2)+h(g.D4[1],2)+'-';\n    for (var i=2; i<8; i++) s+=h(g.D4[i],2);\n    s+='}';\n    return s;\n  },\n\n  createTGUID: function(guid){\n    var TGuid = (pas.System)?pas.System.TGuid:pas.system.tguid;\n    var g = rtl.strToGUIDR(guid,TGuid.$new());\n    return g;\n  },\n\n  getIntfGUIDR: function(intfTypeOrVar){\n    if (!intfTypeOrVar) return null;\n    if (!intfTypeOrVar.$guidr){\n      var g = rtl.createTGUID(intfTypeOrVar.$guid);\n      if (!intfTypeOrVar.hasOwnProperty('$guid')) intfTypeOrVar = Object.getPrototypeOf(intfTypeOrVar);\n      g.$intf = intfTypeOrVar;\n      intfTypeOrVar.$guidr = g;\n    }\n    return intfTypeOrVar.$guidr;\n  },\n\n  addIntf: function (aclass, intf, map){\n    function jmp(fn){\n      if (typeof(fn)===\"function\"){\n        return function(){ return fn.apply(this.$o,arguments); };\n      } else {\n        return function(){ rtl.raiseE('EAbstractError'); };\n      }\n    }\n    if(!map) map = {};\n    var t = intf;\n    var item = Object.create(t);\n    if (!aclass.hasOwnProperty('$intfmaps')) aclass.$intfmaps = {};\n    aclass.$intfmaps[intf.$guid] = item;\n    do{\n      var names = t.$names;\n      if (!names) break;\n      for (var i=0; i<names.length; i++){\n        var intfname = names[i];\n        var fnname = map[intfname];\n        if (!fnname) fnname = intfname;\n        //console.log('addIntf: intftype='+t.$name+' index='+i+' intfname=\"'+intfname+'\" fnname=\"'+fnname+'\" old='+typeof(item[intfname]));\n        item[intfname] = jmp(aclass[fnname]);\n      }\n      t = Object.getPrototypeOf(t);\n    }while(t!=null);\n  },\n\n  getIntfG: function (obj, guid, query){\n    if (!obj) return null;\n    //console.log('getIntfG: obj='+obj.$classname+' guid='+guid+' query='+query);\n    // search\n    var maps = obj.$intfmaps;\n    if (!maps) return null;\n    var item = maps[guid];\n    if (!item) return null;\n    // check delegation\n    //console.log('getIntfG: obj='+obj.$classname+' guid='+guid+' query='+query+' item='+typeof(item));\n    if (typeof item === 'function') return item.call(obj); // delegate. Note: COM contains _AddRef\n    // check cache\n    var intf = null;\n    if (obj.$interfaces){\n      intf = obj.$interfaces[guid];\n      //console.log('getIntfG: obj='+obj.$classname+' guid='+guid+' cache='+typeof(intf));\n    }\n    if (!intf){ // intf can be undefined!\n      intf = Object.create(item);\n      intf.$o = obj;\n      if (!obj.$interfaces) obj.$interfaces = {};\n      obj.$interfaces[guid] = intf;\n    }\n    if (typeof(query)==='object'){\n      // called by queryIntfT\n      var o = null;\n      if (intf.QueryInterface(rtl.getIntfGUIDR(query),\n          {get:function(){ return o; }, set:function(v){ o=v; }}) === 0){\n        return o;\n      } else {\n        return null;\n      }\n    } else if(query===2){\n      // called by TObject.GetInterfaceByStr\n      if (intf.$kind === 'com') intf._AddRef();\n    }\n    return intf;\n  },\n\n  getIntfT: function(obj,intftype){\n    return rtl.getIntfG(obj,intftype.$guid);\n  },\n\n  queryIntfT: function(obj,intftype){\n    return rtl.getIntfG(obj,intftype.$guid,intftype);\n  },\n\n  queryIntfIsT: function(obj,intftype){\n    var i = rtl.queryIntfG(obj,intftype.$guid);\n    if (!i) return false;\n    if (i.$kind === 'com') i._Release();\n    return true;\n  },\n\n  asIntfT: function (obj,intftype){\n    var i = rtl.getIntfG(obj,intftype.$guid);\n    if (i!==null) return i;\n    rtl.raiseEInvalidCast();\n  },\n\n  intfIsClass: function(intf,classtype){\n    return (intf!=null) && (rtl.is(intf.$o,classtype));\n  },\n\n  intfAsClass: function(intf,classtype){\n    if (intf==null) return null;\n    return rtl.as(intf.$o,classtype);\n  },\n\n  intfToClass: function(intf,classtype){\n    if ((intf!==null) && rtl.is(intf.$o,classtype)) return intf.$o;\n    return null;\n  },\n\n  // interface reference counting\n  intfRefs: { // base object for temporary interface variables\n    ref: function(id,intf){\n      // called for temporary interface references needing delayed release\n      var old = this[id];\n      //console.log('rtl.intfRefs.ref: id='+id+' old=\"'+(old?old.$name:'null')+'\" intf=\"'+(intf?intf.$name:'null')+' $o='+(intf?intf.$o:'null'));\n      if (old){\n        // called again, e.g. in a loop\n        delete this[id];\n        old._Release(); // may fail\n      }\n      this[id]=intf;\n      return intf;\n    },\n    free: function(){\n      //console.log('rtl.intfRefs.free...');\n      for (var id in this){\n        if (this.hasOwnProperty(id)){\n          //console.log('rtl.intfRefs.free: id='+id+' '+this[id].$name+' $o='+this[id].$o.$classname);\n          this[id]._Release();\n        }\n      }\n    }\n  },\n\n  createIntfRefs: function(){\n    //console.log('rtl.createIntfRefs');\n    return Object.create(rtl.intfRefs);\n  },\n\n  setIntfP: function(path,name,value,skipAddRef){\n    var old = path[name];\n    //console.log('rtl.setIntfP path='+path+' name='+name+' old=\"'+(old?old.$name:'null')+'\" value=\"'+(value?value.$name:'null')+'\"');\n    if (old === value) return;\n    if (old !== null){\n      path[name]=null;\n      old._Release();\n    }\n    if (value !== null){\n      if (!skipAddRef) value._AddRef();\n      path[name]=value;\n    }\n  },\n\n  setIntfL: function(old,value,skipAddRef){\n    //console.log('rtl.setIntfL old=\"'+(old?old.$name:'null')+'\" value=\"'+(value?value.$name:'null')+'\"');\n    if (old !== value){\n      if (value!==null){\n        if (!skipAddRef) value._AddRef();\n      }\n      if (old!==null){\n        old._Release();  // Release after AddRef, to avoid double Release if Release creates an exception\n      }\n    } else if (skipAddRef){\n      if (old!==null){\n        old._Release();  // value has an AddRef\n      }\n    }\n    return value;\n  },\n\n  _AddRef: function(intf){\n    //if (intf) console.log('rtl._AddRef intf=\"'+(intf?intf.$name:'null')+'\"');\n    if (intf) intf._AddRef();\n    return intf;\n  },\n\n  _Release: function(intf){\n    //if (intf) console.log('rtl._Release intf=\"'+(intf?intf.$name:'null')+'\"');\n    if (intf) intf._Release();\n    return intf;\n  },\n\n  checkMethodCall: function(obj,type){\n    if (rtl.isObject(obj) && rtl.is(obj,type)) return;\n    rtl.raiseE(\"EInvalidCast\");\n  },\n\n  rc: function(i,minval,maxval){\n    // range check integer\n    if ((Math.floor(i)===i) && (i>=minval) && (i<=maxval)) return i;\n    rtl.raiseE('ERangeError');\n  },\n\n  rcc: function(c,minval,maxval){\n    // range check char\n    if ((typeof(c)==='string') && (c.length===1)){\n      var i = c.charCodeAt(0);\n      if ((i>=minval) && (i<=maxval)) return c;\n    }\n    rtl.raiseE('ERangeError');\n  },\n\n  rcSetCharAt: function(s,index,c){\n    // range check setCharAt\n    if ((typeof(s)!=='string') || (index<0) || (index>=s.length)) rtl.raiseE('ERangeError');\n    return rtl.setCharAt(s,index,c);\n  },\n\n  rcCharAt: function(s,index){\n    // range check charAt\n    if ((typeof(s)!=='string') || (index<0) || (index>=s.length)) rtl.raiseE('ERangeError');\n    return s.charAt(index);\n  },\n\n  rcArrR: function(arr,index){\n    // range check read array\n    if (Array.isArray(arr) && (typeof(index)==='number') && (index>=0) && (index<arr.length)){\n      if (arguments.length>2){\n        // arr,index1,index2,...\n        arr=arr[index];\n        for (var i=2; i<arguments.length; i++) arr=rtl.rcArrR(arr,arguments[i]);\n        return arr;\n      }\n      return arr[index];\n    }\n    rtl.raiseE('ERangeError');\n  },\n\n  rcArrW: function(arr,index,value){\n    // range check write array\n    // arr,index1,index2,...,value\n    for (var i=3; i<arguments.length; i++){\n      arr=rtl.rcArrR(arr,index);\n      index=arguments[i-1];\n      value=arguments[i];\n    }\n    if (Array.isArray(arr) && (typeof(index)==='number') && (index>=0) && (index<arr.length)){\n      return arr[index]=value;\n    }\n    rtl.raiseE('ERangeError');\n  },\n\n  length: function(arr){\n    return (arr == null) ? 0 : arr.length;\n  },\n\n  arraySetLength: function(arr,defaultvalue,newlength){\n    // multi dim: (arr,defaultvalue,dim1,dim2,...)\n    var p = arguments;\n    function setLength(src,argNo){\n      var newlen = p[argNo];\n      var a = [];\n      a.length = newlength;\n      if (argNo === p.length-1){\n        var oldlen = src?src.length:0;\n        if (rtl.isArray(defaultvalue)){\n          for (var i=0; i<newlen; i++) a[i]=(i<oldlen)?src[i]:[]; // array of dyn array\n        } else if (rtl.isObject(defaultvalue)) {\n          if (rtl.isTRecord(defaultvalue)){\n            for (var i=0; i<newlen; i++)\n              a[i]=(i<oldlen)?defaultvalue.$clone(src[i]):defaultvalue.$new(); // e.g. record\n          } else {\n            for (var i=0; i<newlen; i++) a[i]=(i<oldlen)?rtl.refSet(src[i]):{}; // e.g. set\n          }\n        } else {\n          for (var i=0; i<newlen; i++)\n            a[i]=(i<oldlen)?src[i]:defaultvalue;\n        }\n      } else {\n        // multi dim array\n        for (var i=0; i<newlen; i++) a[i]=setLength(src?src[i]:null,argNo+1);\n      }\n      return a;\n    }\n    return setLength(arr,2);\n  },\n\n  /*arrayChgLength: function(arr,defaultvalue,newlength){\n    // multi dim: (arr,defaultvalue,dim1,dim2,...)\n    if (arr == null) arr = [];\n    var p = arguments;\n    function setLength(a,argNo){\n      var oldlen = a.length;\n      var newlen = p[argNo];\n      if (oldlen!==newlength){\n        a.length = newlength;\n        if (argNo === p.length-1){\n          if (rtl.isArray(defaultvalue)){\n            for (var i=oldlen; i<newlen; i++) a[i]=[]; // nested array\n          } else if (rtl.isObject(defaultvalue)) {\n            if (rtl.isTRecord(defaultvalue)){\n              for (var i=oldlen; i<newlen; i++) a[i]=defaultvalue.$new(); // e.g. record\n            } else {\n              for (var i=oldlen; i<newlen; i++) a[i]={}; // e.g. set\n            }\n          } else {\n            for (var i=oldlen; i<newlen; i++) a[i]=defaultvalue;\n          }\n        } else {\n          for (var i=oldlen; i<newlen; i++) a[i]=[]; // nested array\n        }\n      }\n      if (argNo < p.length-1){\n        // multi argNo\n        for (var i=0; i<newlen; i++) a[i]=setLength(a[i],argNo+1);\n      }\n      return a;\n    }\n    return setLength(arr,2);\n  },*/\n\n  arrayEq: function(a,b){\n    if (a===null) return b===null;\n    if (b===null) return false;\n    if (a.length!==b.length) return false;\n    for (var i=0; i<a.length; i++) if (a[i]!==b[i]) return false;\n    return true;\n  },\n\n  arrayClone: function(type,src,srcpos,endpos,dst,dstpos){\n    // type: 0 for references, \"refset\" for calling refSet(), a function for new type()\n    // src must not be null\n    // This function does not range check.\n    if(type === 'refSet') {\n      for (; srcpos<endpos; srcpos++) dst[dstpos++] = rtl.refSet(src[srcpos]); // ref set\n    } else if (rtl.isTRecord(type)){\n      for (; srcpos<endpos; srcpos++) dst[dstpos++] = type.$clone(src[srcpos]); // clone record\n    }  else {\n      for (; srcpos<endpos; srcpos++) dst[dstpos++] = src[srcpos]; // reference\n    };\n  },\n\n  arrayConcat: function(type){\n    // type: see rtl.arrayClone\n    var a = [];\n    var l = 0;\n    for (var i=1; i<arguments.length; i++){\n      var src = arguments[i];\n      if (src !== null) l+=src.length;\n    };\n    a.length = l;\n    l=0;\n    for (var i=1; i<arguments.length; i++){\n      var src = arguments[i];\n      if (src === null) continue;\n      rtl.arrayClone(type,src,0,src.length,a,l);\n      l+=src.length;\n    };\n    return a;\n  },\n\n  arrayConcatN: function(){\n    var a = null;\n    for (var i=1; i<arguments.length; i++){\n      var src = arguments[i];\n      if (src === null) continue;\n      if (a===null){\n        a=src; // Note: concat(a) does not clone\n      } else {\n        a=a.concat(src);\n      }\n    };\n    return a;\n  },\n\n  arrayCopy: function(type, srcarray, index, count){\n    // type: see rtl.arrayClone\n    // if count is missing, use srcarray.length\n    if (srcarray === null) return [];\n    if (index < 0) index = 0;\n    if (count === undefined) count=srcarray.length;\n    var end = index+count;\n    if (end>srcarray.length) end = srcarray.length;\n    if (index>=end) return [];\n    if (type===0){\n      return srcarray.slice(index,end);\n    } else {\n      var a = [];\n      a.length = end-index;\n      rtl.arrayClone(type,srcarray,index,end,a,0);\n      return a;\n    }\n  },\n\n  setCharAt: function(s,index,c){\n    return s.substr(0,index)+c+s.substr(index+1);\n  },\n\n  getResStr: function(mod,name){\n    var rs = mod.$resourcestrings[name];\n    return rs.current?rs.current:rs.org;\n  },\n\n  createSet: function(){\n    var s = {};\n    for (var i=0; i<arguments.length; i++){\n      if (arguments[i]!=null){\n        s[arguments[i]]=true;\n      } else {\n        var first=arguments[i+=1];\n        var last=arguments[i+=1];\n        for(var j=first; j<=last; j++) s[j]=true;\n      }\n    }\n    return s;\n  },\n\n  cloneSet: function(s){\n    var r = {};\n    for (var key in s) r[key]=true;\n    return r;\n  },\n\n  refSet: function(s){\n    Object.defineProperty(s, '$shared', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    return s;\n  },\n\n  includeSet: function(s,enumvalue){\n    if (s.$shared) s = rtl.cloneSet(s);\n    s[enumvalue] = true;\n    return s;\n  },\n\n  excludeSet: function(s,enumvalue){\n    if (s.$shared) s = rtl.cloneSet(s);\n    delete s[enumvalue];\n    return s;\n  },\n\n  diffSet: function(s,t){\n    var r = {};\n    for (var key in s) if (!t[key]) r[key]=true;\n    return r;\n  },\n\n  unionSet: function(s,t){\n    var r = {};\n    for (var key in s) r[key]=true;\n    for (var key in t) r[key]=true;\n    return r;\n  },\n\n  intersectSet: function(s,t){\n    var r = {};\n    for (var key in s) if (t[key]) r[key]=true;\n    return r;\n  },\n\n  symDiffSet: function(s,t){\n    var r = {};\n    for (var key in s) if (!t[key]) r[key]=true;\n    for (var key in t) if (!s[key]) r[key]=true;\n    return r;\n  },\n\n  eqSet: function(s,t){\n    for (var key in s) if (!t[key]) return false;\n    for (var key in t) if (!s[key]) return false;\n    return true;\n  },\n\n  neSet: function(s,t){\n    return !rtl.eqSet(s,t);\n  },\n\n  leSet: function(s,t){\n    for (var key in s) if (!t[key]) return false;\n    return true;\n  },\n\n  geSet: function(s,t){\n    for (var key in t) if (!s[key]) return false;\n    return true;\n  },\n\n  strSetLength: function(s,newlen){\n    var oldlen = s.length;\n    if (oldlen > newlen){\n      return s.substring(0,newlen);\n    } else if (s.repeat){\n      // Note: repeat needs ECMAScript6!\n      return s+' '.repeat(newlen-oldlen);\n    } else {\n       while (oldlen<newlen){\n         s+=' ';\n         oldlen++;\n       };\n       return s;\n    }\n  },\n\n  spaceLeft: function(s,width){\n    var l=s.length;\n    if (l>=width) return s;\n    if (s.repeat){\n      // Note: repeat needs ECMAScript6!\n      return ' '.repeat(width-l) + s;\n    } else {\n      while (l<width){\n        s=' '+s;\n        l++;\n      };\n    };\n  },\n\n  floatToStr: function(d,w,p){\n    // input 1-3 arguments: double, width, precision\n    if (arguments.length>2){\n      return rtl.spaceLeft(d.toFixed(p),w);\n    } else {\n\t  // exponent width\n\t  var pad = \"\";\n\t  var ad = Math.abs(d);\n\t  if (ad<1.0e+10) {\n\t\tpad='00';\n\t  } else if (ad<1.0e+100) {\n\t\tpad='0';\n      }  \t\n\t  if (arguments.length<2) {\n\t    w=9;\t\t\n      } else if (w<9) {\n\t\tw=9;\n      }\t\t  \n      var p = w-8;\n      var s=(d>0 ? \" \" : \"\" ) + d.toExponential(p);\n      s=s.replace(/e(.)/,'E$1'+pad);\n      return rtl.spaceLeft(s,w);\n    }\n  },\n\n  valEnum: function(s, enumType, setCodeFn){\n    s = s.toLowerCase();\n    for (var key in enumType){\n      if((typeof(key)==='string') && (key.toLowerCase()===s)){\n        setCodeFn(0);\n        return enumType[key];\n      }\n    }\n    setCodeFn(1);\n    return 0;\n  },\n\n  and: function(a,b){\n    var hi = 0x80000000;\n    var low = 0x7fffffff;\n    var h = (a / hi) & (b / hi);\n    var l = (a & low) & (b & low);\n    return h*hi + l;\n  },\n\n  or: function(a,b){\n    var hi = 0x80000000;\n    var low = 0x7fffffff;\n    var h = (a / hi) | (b / hi);\n    var l = (a & low) | (b & low);\n    return h*hi + l;\n  },\n\n  xor: function(a,b){\n    var hi = 0x80000000;\n    var low = 0x7fffffff;\n    var h = (a / hi) ^ (b / hi);\n    var l = (a & low) ^ (b & low);\n    return h*hi + l;\n  },\n\n  shr: function(a,b){\n    if (a<0) a += rtl.hiInt;\n    if (a<0x80000000) return a >> b;\n    if (b<=0) return a;\n    if (b>54) return 0;\n    return Math.floor(a / Math.pow(2,b));\n  },\n\n  shl: function(a,b){\n    if (a<0) a += rtl.hiInt;\n    if (b<=0) return a;\n    if (b>54) return 0;\n    var r = a * Math.pow(2,b);\n    if (r <= rtl.hiInt) return r;\n    return r % rtl.hiInt;\n  },\n\n  initRTTI: function(){\n    if (rtl.debug_rtti) rtl.debug('initRTTI');\n\n    // base types\n    rtl.tTypeInfo = { name: \"tTypeInfo\" };\n    function newBaseTI(name,kind,ancestor){\n      if (!ancestor) ancestor = rtl.tTypeInfo;\n      if (rtl.debug_rtti) rtl.debug('initRTTI.newBaseTI \"'+name+'\" '+kind+' (\"'+ancestor.name+'\")');\n      var t = Object.create(ancestor);\n      t.name = name;\n      t.kind = kind;\n      rtl[name] = t;\n      return t;\n    };\n    function newBaseInt(name,minvalue,maxvalue,ordtype){\n      var t = newBaseTI(name,1 /* tkInteger */,rtl.tTypeInfoInteger);\n      t.minvalue = minvalue;\n      t.maxvalue = maxvalue;\n      t.ordtype = ordtype;\n      return t;\n    };\n    newBaseTI(\"tTypeInfoInteger\",1 /* tkInteger */);\n    newBaseInt(\"shortint\",-0x80,0x7f,0);\n    newBaseInt(\"byte\",0,0xff,1);\n    newBaseInt(\"smallint\",-0x8000,0x7fff,2);\n    newBaseInt(\"word\",0,0xffff,3);\n    newBaseInt(\"longint\",-0x80000000,0x7fffffff,4);\n    newBaseInt(\"longword\",0,0xffffffff,5);\n    newBaseInt(\"nativeint\",-0x10000000000000,0xfffffffffffff,6);\n    newBaseInt(\"nativeuint\",0,0xfffffffffffff,7);\n    newBaseTI(\"char\",2 /* tkChar */);\n    newBaseTI(\"string\",3 /* tkString */);\n    newBaseTI(\"tTypeInfoEnum\",4 /* tkEnumeration */,rtl.tTypeInfoInteger);\n    newBaseTI(\"tTypeInfoSet\",5 /* tkSet */);\n    newBaseTI(\"double\",6 /* tkDouble */);\n    newBaseTI(\"boolean\",7 /* tkBool */);\n    newBaseTI(\"tTypeInfoProcVar\",8 /* tkProcVar */);\n    newBaseTI(\"tTypeInfoMethodVar\",9 /* tkMethod */,rtl.tTypeInfoProcVar);\n    newBaseTI(\"tTypeInfoArray\",10 /* tkArray */);\n    newBaseTI(\"tTypeInfoDynArray\",11 /* tkDynArray */);\n    newBaseTI(\"tTypeInfoPointer\",15 /* tkPointer */);\n    var t = newBaseTI(\"pointer\",15 /* tkPointer */,rtl.tTypeInfoPointer);\n    t.reftype = null;\n    newBaseTI(\"jsvalue\",16 /* tkJSValue */);\n    newBaseTI(\"tTypeInfoRefToProcVar\",17 /* tkRefToProcVar */,rtl.tTypeInfoProcVar);\n\n    // member kinds\n    rtl.tTypeMember = {};\n    function newMember(name,kind){\n      var m = Object.create(rtl.tTypeMember);\n      m.name = name;\n      m.kind = kind;\n      rtl[name] = m;\n    };\n    newMember(\"tTypeMemberField\",1); // tmkField\n    newMember(\"tTypeMemberMethod\",2); // tmkMethod\n    newMember(\"tTypeMemberProperty\",3); // tmkProperty\n\n    // base object for storing members: a simple object\n    rtl.tTypeMembers = {};\n\n    // tTypeInfoStruct - base object for tTypeInfoClass, tTypeInfoRecord, tTypeInfoInterface\n    var tis = newBaseTI(\"tTypeInfoStruct\",0);\n    tis.$addMember = function(name,ancestor,options){\n      if (rtl.debug_rtti){\n        if (!rtl.hasString(name) || (name.charAt()==='$')) throw 'invalid member \"'+name+'\", this=\"'+this.name+'\"';\n        if (!rtl.is(ancestor,rtl.tTypeMember)) throw 'invalid ancestor \"'+ancestor+':'+ancestor.name+'\", \"'+this.name+'.'+name+'\"';\n        if ((options!=undefined) && (typeof(options)!='object')) throw 'invalid options \"'+options+'\", \"'+this.name+'.'+name+'\"';\n      };\n      var t = Object.create(ancestor);\n      t.name = name;\n      this.members[name] = t;\n      this.names.push(name);\n      if (rtl.isObject(options)){\n        for (var key in options) if (options.hasOwnProperty(key)) t[key] = options[key];\n      };\n      return t;\n    };\n    tis.addField = function(name,type,options){\n      var t = this.$addMember(name,rtl.tTypeMemberField,options);\n      if (rtl.debug_rtti){\n        if (!rtl.is(type,rtl.tTypeInfo)) throw 'invalid type \"'+type+'\", \"'+this.name+'.'+name+'\"';\n      };\n      t.typeinfo = type;\n      this.fields.push(name);\n      return t;\n    };\n    tis.addFields = function(){\n      var i=0;\n      while(i<arguments.length){\n        var name = arguments[i++];\n        var type = arguments[i++];\n        if ((i<arguments.length) && (typeof(arguments[i])==='object')){\n          this.addField(name,type,arguments[i++]);\n        } else {\n          this.addField(name,type);\n        };\n      };\n    };\n    tis.addMethod = function(name,methodkind,params,result,options){\n      var t = this.$addMember(name,rtl.tTypeMemberMethod,options);\n      t.methodkind = methodkind;\n      t.procsig = rtl.newTIProcSig(params);\n      t.procsig.resulttype = result?result:null;\n      this.methods.push(name);\n      return t;\n    };\n    tis.addProperty = function(name,flags,result,getter,setter,options){\n      var t = this.$addMember(name,rtl.tTypeMemberProperty,options);\n      t.flags = flags;\n      t.typeinfo = result;\n      t.getter = getter;\n      t.setter = setter;\n      // Note: in options: params, stored, defaultvalue\n      if (rtl.isArray(t.params)) t.params = rtl.newTIParams(t.params);\n      this.properties.push(name);\n      if (!rtl.isString(t.stored)) t.stored = \"\";\n      return t;\n    };\n    tis.getField = function(index){\n      return this.members[this.fields[index]];\n    };\n    tis.getMethod = function(index){\n      return this.members[this.methods[index]];\n    };\n    tis.getProperty = function(index){\n      return this.members[this.properties[index]];\n    };\n\n    newBaseTI(\"tTypeInfoRecord\",12 /* tkRecord */,rtl.tTypeInfoStruct);\n    newBaseTI(\"tTypeInfoClass\",13 /* tkClass */,rtl.tTypeInfoStruct);\n    newBaseTI(\"tTypeInfoClassRef\",14 /* tkClassRef */);\n    newBaseTI(\"tTypeInfoInterface\",18 /* tkInterface */,rtl.tTypeInfoStruct);\n    newBaseTI(\"tTypeInfoHelper\",19 /* tkHelper */,rtl.tTypeInfoStruct);\n  },\n\n  tSectionRTTI: {\n    $module: null,\n    $inherited: function(name,ancestor,o){\n      if (rtl.debug_rtti){\n        rtl.debug('tSectionRTTI.newTI \"'+(this.$module?this.$module.$name:\"(no module)\")\n          +'\".\"'+name+'\" ('+ancestor.name+') '+(o?'init':'forward'));\n      };\n      var t = this[name];\n      if (t){\n        if (!t.$forward) throw 'duplicate type \"'+name+'\"';\n        if (!ancestor.isPrototypeOf(t)) throw 'typeinfo ancestor mismatch \"'+name+'\" ancestor=\"'+ancestor.name+'\" t.name=\"'+t.name+'\"';\n      } else {\n        t = Object.create(ancestor);\n        t.name = name;\n        t.$module = this.$module;\n        this[name] = t;\n      }\n      if (o){\n        delete t.$forward;\n        for (var key in o) if (o.hasOwnProperty(key)) t[key]=o[key];\n      } else {\n        t.$forward = true;\n      }\n      return t;\n    },\n    $Scope: function(name,ancestor,o){\n      var t=this.$inherited(name,ancestor,o);\n      t.members = {};\n      t.names = [];\n      t.fields = [];\n      t.methods = [];\n      t.properties = [];\n      return t;\n    },\n    $TI: function(name,kind,o){ var t=this.$inherited(name,rtl.tTypeInfo,o); t.kind = kind; return t; },\n    $Int: function(name,o){ return this.$inherited(name,rtl.tTypeInfoInteger,o); },\n    $Enum: function(name,o){ return this.$inherited(name,rtl.tTypeInfoEnum,o); },\n    $Set: function(name,o){ return this.$inherited(name,rtl.tTypeInfoSet,o); },\n    $StaticArray: function(name,o){ return this.$inherited(name,rtl.tTypeInfoArray,o); },\n    $DynArray: function(name,o){ return this.$inherited(name,rtl.tTypeInfoDynArray,o); },\n    $ProcVar: function(name,o){ return this.$inherited(name,rtl.tTypeInfoProcVar,o); },\n    $RefToProcVar: function(name,o){ return this.$inherited(name,rtl.tTypeInfoRefToProcVar,o); },\n    $MethodVar: function(name,o){ return this.$inherited(name,rtl.tTypeInfoMethodVar,o); },\n    $Record: function(name,o){ return this.$Scope(name,rtl.tTypeInfoRecord,o); },\n    $Class: function(name,o){ return this.$Scope(name,rtl.tTypeInfoClass,o); },\n    $ClassRef: function(name,o){ return this.$inherited(name,rtl.tTypeInfoClassRef,o); },\n    $Pointer: function(name,o){ return this.$inherited(name,rtl.tTypeInfoPointer,o); },\n    $Interface: function(name,o){ return this.$Scope(name,rtl.tTypeInfoInterface,o); },\n    $Helper: function(name,o){ return this.$Scope(name,rtl.tTypeInfoHelper,o); }\n  },\n\n  newTIParam: function(param){\n    // param is an array, 0=name, 1=type, 2=optional flags\n    var t = {\n      name: param[0],\n      typeinfo: param[1],\n      flags: (rtl.isNumber(param[2]) ? param[2] : 0)\n    };\n    return t;\n  },\n\n  newTIParams: function(list){\n    // list: optional array of [paramname,typeinfo,optional flags]\n    var params = [];\n    if (rtl.isArray(list)){\n      for (var i=0; i<list.length; i++) params.push(rtl.newTIParam(list[i]));\n    };\n    return params;\n  },\n\n  newTIProcSig: function(params,result,flags){\n    var s = {\n      params: rtl.newTIParams(params),\n      resulttype: result,\n      flags: flags\n    };\n    return s;\n  }\n}\n","{\n    This file is part of the Pas2JS run time library.\n    Copyright (c) 2018 by Mattias Gaertner\n\n    See the file COPYING.FPC, included in this distribution,\n    for details about the copyright.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n **********************************************************************}\nunit System;\n\n{$mode objfpc}\n{$modeswitch externalclass}\n\ninterface\n\n{$IFDEF NodeJS}\nvar\n  LineEnding: string = #10;\n  sLineBreak: string = #10;\n{$ELSE}\nconst\n  LineEnding = #10;\n  sLineBreak = LineEnding;\n{$ENDIF}\n\nVar\n  PathDelim : Char = '/';\n  AllowDirectorySeparators : Set of Char = ['/'];\n  AllowDriveSeparators : Set of Char = [':'];\n  ExtensionSeparator : Char = '.';\n\nconst\n  MaxSmallint = 32767;\n  MinSmallint = -32768;\n  MaxShortInt = 127;\n  MinShortInt = -128;\n  MaxByte = $FF;\n  MaxWord = $FFFF;\n  MaxLongint  = $7fffffff;\n  MaxCardinal = LongWord($ffffffff);\n\n  Maxint = MaxLongint;\n  IsMultiThread = false;\n\n{*****************************************************************************\n                               Base types\n*****************************************************************************}\ntype\n  Integer = LongInt;\n  Cardinal = LongWord;\n  DWord = LongWord;\n  SizeInt = NativeInt;\n  SizeUInt = NativeUInt;\n  PtrInt = NativeInt;\n  PtrUInt = NativeUInt;\n  ValSInt = NativeInt;\n  ValUInt = NativeUInt;\n  ValReal = Double;\n  Real = type Double;\n  Extended = type Double;\n\n  TDateTime = type double;\n  TTime = type TDateTime;\n  TDate = type TDateTime;\n\n  Int64 = type NativeInt unimplemented; // only 53 bits at runtime\n  UInt64 = type NativeUInt unimplemented; // only 52 bits at runtime\n  QWord = type NativeUInt unimplemented; // only 52 bits at runtime\n  Single = type Double unimplemented;\n  Comp = type NativeInt unimplemented;\n  NativeLargeInt = NativeInt;\n  NativeLargeUInt = NativeUInt;\n\n  UnicodeString = type String;\n  WideString = type String;\n  WideChar = char;\n  UnicodeChar = char;\n\n  TDynArrayIndex = NativeInt;\n  TTextLineBreakStyle = (tlbsLF,tlbsCRLF,tlbsCR);\n\n{*****************************************************************************\n            TObject, TClass, IUnknown, IInterface, TInterfacedObject\n*****************************************************************************}\ntype\n  TGuid = record\n    D1: DWord;\n    D2: word;\n    D3: word;\n    D4: array[0..7] of byte;\n  end;\n  TGUIDString = type string;\n\n  TClass = class of TObject;\n\n  { TObject }\n\n  TObject = class\n  private\n    class var FClassName: String; external name '$classname';\n    class var FClassParent: TClass; external name '$ancestor';\n    class var FUnitName: String; external name '$module.$name';\n  public\n    constructor Create;\n    destructor Destroy; virtual;\n\n    // Free is using compiler magic.\n    // Reasons:\n    // 1. In JS calling obj.Free when obj=nil would crash.\n    // 2. In JS freeing memory requires to set all references to nil.\n    // Therefore any obj.free call is replaced by the compiler with some rtl magic.\n    procedure Free;\n\n    class function ClassType: TClass; assembler;\n    class property ClassName: String read FClassName;\n    class function ClassNameIs(const Name: string): boolean;\n    class property ClassParent: TClass read FClassParent;\n    class function InheritsFrom(aClass: TClass): boolean; assembler;\n    class property UnitName: String read FUnitName;\n\n    procedure AfterConstruction; virtual;\n    procedure BeforeDestruction; virtual;\n\n    function GetInterface(const iid: TGuid; out obj): boolean;\n    function GetInterface(const iidstr: String; out obj): boolean; inline;\n    function GetInterfaceByStr(const iidstr: String; out obj): boolean;\n    function GetInterfaceWeak(const iid: TGuid; out obj): boolean; // equal to GetInterface but the interface returned is not referenced\n\n    function Equals(Obj: TObject): boolean; virtual;\n    function ToString: String; virtual;\n  end;\n\nconst\n  { IInterface }\n  S_OK          = 0;\n  S_FALSE       = 1;\n  E_NOINTERFACE = -2147467262; // FPC: longint($80004002)\n  E_UNEXPECTED  = -2147418113; // FPC: longint($8000FFFF)\n  E_NOTIMPL     = -2147467263; // FPC: longint($80004001)\n\ntype\n  {$Interfaces COM}\n  IUnknown = interface\n    ['{00000000-0000-0000-C000-000000000046}']\n    function QueryInterface(const iid: TGuid; out obj): Integer;\n    function _AddRef: Integer;\n    function _Release: Integer;\n  end;\n  IInterface = IUnknown;\n\n  {$M+}\n  IInvokable = interface(IInterface)\n  end;\n  {$M-}\n\n  { Enumerator support }\n  IEnumerator = interface(IInterface)\n    function GetCurrent: TObject;\n    function MoveNext: Boolean;\n    procedure Reset;\n    property Current: TObject read GetCurrent;\n  end;\n\n  IEnumerable = interface(IInterface)\n    function GetEnumerator: IEnumerator;\n  end;\n\n  { TInterfacedObject }\n\n  TInterfacedObject = class(TObject,IUnknown)\n  protected\n    fRefCount: Integer;\n    { implement methods of IUnknown }\n    function QueryInterface(const iid: TGuid; out obj): Integer; virtual;\n    function _AddRef: Integer; virtual;\n    function _Release: Integer; virtual;\n  public\n    procedure BeforeDestruction; override;\n    property RefCount: Integer read fRefCount;\n  end;\n  TInterfacedClass = class of TInterfacedObject;\n\n  { TAggregatedObject - sub or satellite object using same interface as controller }\n\n  TAggregatedObject = class(TObject)\n  private\n    fController: Pointer;\n    function GetController: IUnknown;\n  protected\n    { implement methods of IUnknown }\n    function QueryInterface(const iid: TGuid; out obj): Integer; virtual;\n    function _AddRef: Integer; virtual;\n    function _Release: Integer; virtual;\n  public\n    constructor Create(const aController: IUnknown); reintroduce;\n    property Controller: IUnknown read GetController;\n  end;\n\n  { TContainedObject }\n\n  TContainedObject = class(TAggregatedObject,IInterface)\n  protected\n    function QueryInterface(const iid: TGuid; out obj): Integer; override;\n  end;\n\nconst\n  { for safe as operator support }\n  IObjectInstance: TGuid = '{D91C9AF4-3C93-420F-A303-BF5BA82BFD23}';\n\nfunction GUIDToString(const GUID: TGUID): string; external name 'rtl.guidrToStr';\n\n{*****************************************************************************\n                              Array of const support\n*****************************************************************************}\n\nconst\n  vtInteger       = 0;\n  vtBoolean       = 1;\n  //vtChar          = 2; // Delphi/FPC: ansichar\n  vtExtended      = 3; // Note: double in pas2js, PExtended in Delphi/FPC\n  //vtString        = 4; // Delphi/FPC: PShortString\n  vtPointer       = 5;\n  //vtPChar         = 6;\n  vtObject        = 7;\n  vtClass         = 8;\n  vtWideChar      = 9;\n  //vtPWideChar     = 10;\n  //vtAnsiString    = 11;\n  vtCurrency      = 12; // Note: currency in pas2js, PCurrency in Delphi/FPC\n  //vtVariant       = 13;\n  vtInterface     = 14;\n  //vtWideString    = 15;\n  //vtInt64         = 16;\n  //vtQWord         = 17;\n  vtUnicodeString = 18;\n  // only pas2js, not in Delphi/FPC:\n  vtNativeInt     = 19;\n  vtJSValue       = 20;\n\ntype\n  PVarRec = ^TVarRec;\n  TVarRec = record\n    VType: byte;\n    VJSValue: JSValue;\n    VInteger: LongInt external name 'VJSValue';\n    VBoolean: Boolean external name 'VJSValue';\n    VExtended: Double external name 'VJSValue';\n    VPointer: Pointer external name 'VJSValue';\n    VObject: TObject external name 'VJSValue';\n    VClass: TClass external name 'VJSValue';\n    VWideChar: WideChar external name 'VJSValue';\n    VCurrency: Currency external name 'VJSValue';\n    VInterface: Pointer external name 'VJSValue';\n    VUnicodeString: UnicodeString external name 'VJSValue';\n    VNativeInt: NativeInt external name 'VJSValue';\n  end;\n  TVarRecArray = array of TVarRec;\n\nfunction VarRecs: TVarRecArray; varargs;\n\n{*****************************************************************************\n                            Init / Exit / ExitProc\n*****************************************************************************}\nvar\n  ExitCode: Integer; external name 'rtl.exitcode';\n  IsConsole: Boolean = {$IFDEF NodeJS}true{$ELSE}false{$ENDIF};\n  FirstDotAtFileNameStartIsExtension : Boolean = False;\n\ntype\n  TOnParamCount = function: Longint;\n  TOnParamStr = function(Index: Longint): String;\nvar\n  OnParamCount: TOnParamCount;\n  OnParamStr: TOnParamStr;\n\nfunction ParamCount: Longint;\nfunction ParamStr(Index: Longint): String;\n\n{*****************************************************************************\n                                 Math\n*****************************************************************************}\nconst\n  PI: Double; external name 'Math.PI';\n  MathE: Double; external name 'Math.E'; // Euler's number\n  MathLN10: Double; external name 'Math.LN10'; // ln(10)\n  MathLN2: Double; external name 'Math.LN2'; // ln(2)\n  MathLog10E: Double; external name 'Math.Log10E'; // log10(e)\n  MathLog2E: Double; external name 'Math.LOG2E'; // log2(e)\n  MathSQRT1_2: Double; external name 'Math.SQRT1_2'; // sqrt(0.5)\n  MathSQRT2: Double; external name 'Math.SQRT2'; // sqrt(2)\n\nfunction Abs(const A: integer): integer; overload; external name 'Math.abs';\nfunction Abs(const A: NativeInt): integer; overload; external name 'Math.abs';\nfunction Abs(const A: Double): Double; overload; external name 'Math.abs';\nfunction ArcTan(const A: Double): Double; external name 'Math.atan';\nfunction ArcTan2(const A,B: Double): Double; external name 'Math.atan2';\nfunction Cos(const A: Double): Double; external name 'Math.cos';\nfunction Exp(const A: Double): Double; external name 'Math.exp';\nfunction Frac(const A: Double): Double; assembler;\nfunction Ln(const A: Double): Double; external name 'Math.log';\nfunction Odd(const A: Integer): Boolean; assembler;\nfunction Random(const Range: Integer): Integer; overload; assembler;\nfunction Random: Double; overload; external name 'Math.random';\nfunction Round(const A: Double): NativeInt; external name 'Math.round';\nfunction Sin(const A: Double): Double; external name 'Math.sin';\nfunction Sqr(const A: Integer): Integer; assembler; overload;\nfunction Sqr(const A: Double): Double; assembler; overload;\nfunction sqrt(const A: Double): Double; external name 'Math.sqrt';\nfunction Trunc(const A: Double): NativeInt;\n\n{*****************************************************************************\n                          String functions\n*****************************************************************************}\nconst\n  DefaultTextLineBreakStyle : TTextLineBreakStyle = tlbsLF;\n\nfunction Int(const A: Double): double;\nfunction Copy(const S: string; Index, Size: Integer): String; assembler; overload;\nfunction Copy(const S: string; Index: Integer): String; assembler; overload;\nprocedure Delete(var S: String; Index, Size: Integer); assembler; overload;\nfunction Pos(const Search, InString: String): Integer; assembler; overload;\nfunction Pos(const Search, InString: String; StartAt : Integer): Integer; assembler; overload;\nprocedure Insert(const Insertion: String; var Target: String; Index: Integer); overload;\nfunction upcase(c : char) : char; assembler;\nfunction HexStr(Val: NativeInt; cnt: byte): string; external name 'rtl.hexStr'; overload;\n\nprocedure val(const S: String; out NI : NativeInt; out Code: Integer); overload;\nprocedure val(const S: String; out NI : NativeUInt; out Code: Integer); overload;\nprocedure val(const S: String; out SI : ShortInt; out Code: Integer); overload;\nprocedure val(const S: String; out B : Byte; out Code: Integer); overload;\nprocedure val(const S: String; out SI : smallint; out Code: Integer); overload;\nprocedure val(const S: String; out W : word; out Code : Integer); overload;\nprocedure val(const S: String; out I : integer; out Code : Integer); overload;\nprocedure val(const S: String; out C : Cardinal; out Code: Integer); overload;\nprocedure val(const S: String; out d : double; out Code : Integer); overload;\nprocedure val(const S: String; out b : boolean; out Code: Integer); overload;\nfunction StringOfChar(c: Char; l: NativeInt): String;\n\n{*****************************************************************************\n                          Other functions\n*****************************************************************************}\nprocedure Write; varargs; // ToDo: should be compiler built-in function\nprocedure Writeln; varargs; // ToDo: should be compiler built-in function\n\nType\n  TConsoleHandler = Procedure (S : JSValue; NewLine : Boolean);\nFunction SetWriteCallBack(H : TConsoleHandler) : TConsoleHandler;\n\nfunction Assigned(const V: JSValue): boolean; assembler; overload;\nfunction StrictEqual(const A: JSValue; const B): boolean; assembler;\nfunction StrictInequal(const A: JSValue; const B): boolean; assembler;\n\nimplementation\n\ntype\n\n  { TJSObj - simple access to JS Object }\n\n  TJSObj = class external name 'Object'\n  private\n    function GetProperties(Name: String): JSValue; external name '[]';\n    procedure SetProperties(Name: String; const AValue: JSValue); external name '[]';\n  public\n    //constructor new;\n    //function hasOwnProperty(prop: String): boolean;\n    property Properties[Name: String]: JSValue read GetProperties write SetProperties; default;\n  end;\n\n  TJSArray = class external name 'Array'\n  public\n    //length: nativeint;\n    //constructor new; overload;\n    function push(aElement : JSValue) : NativeInt; varargs;\n  end;\n\n  TJSArguments = class external name 'arguments'\n  private\n    FLength: NativeInt; external name 'length';\n    function GetElements(Index: NativeInt): JSValue; external name '[]';\n  public\n    property Length: NativeInt read FLength;\n    property Elements[Index: NativeInt]: JSValue read GetElements; default;\n  end;\nvar\n  JSArguments: TJSArguments; external name 'arguments';\n\n// function parseInt(s: String; Radix: NativeInt): NativeInt; external name 'parseInt'; // may result NaN\nfunction isNaN(i: JSValue): boolean; external name 'isNaN'; // may result NaN\n\n// needed by ClassNameIs, the real SameText is in SysUtils\nfunction SameText(const s1, s2: String): Boolean; assembler;\nasm\n  return s1.toLowerCase() == s2.toLowerCase();\nend;\n\nfunction VarRecs: TVarRecArray;\nvar\n  i: nativeint;\n  v: PVarRec;\nbegin\n  Result:=nil;\n  while i<JSArguments.Length do\n    begin\n    new(v);\n    v^.VType:=byte(JSArguments[i]);\n    inc(i);\n    v^.VJSValue:=JSArguments[i];\n    inc(i);\n    TJSArray(Result).push(v^);\n    end;\nend;\n\nfunction ParamCount: Longint;\nbegin\n  if Assigned(OnParamCount) then\n    Result:=OnParamCount()\n  else\n    Result:=0;\nend;\n\nfunction ParamStr(Index: Longint): String;\nbegin\n  if Assigned(OnParamStr) then\n    Result:=OnParamStr(Index)\n  else if Index=0 then\n    Result:='js'\n  else\n    Result:='';\nend;\n\nfunction Frac(const A: Double): Double; assembler;\nasm\n  return A % 1;\nend;\n\nfunction Odd(const A: Integer): Boolean; assembler;\nasm\n  return A&1 != 0;\nend;\n\nfunction Random(const Range: Integer): Integer; assembler;\nasm\n  return Math.floor(Math.random()*Range);\nend;\n\nfunction Sqr(const A: Integer): Integer; assembler;\nasm\n  return A*A;\nend;\n\nfunction Sqr(const A: Double): Double; assembler;\nasm\n  return A*A;\nend;\n\nfunction Trunc(const A: Double): NativeInt; assembler;\nasm\n  if (!Math.trunc) {\n    Math.trunc = function(v) {\n      v = +v;\n      if (!isFinite(v)) return v;\n      return (v - v % 1) || (v < 0 ? -0 : v === 0 ? v : 0);\n    };\n  }\n  $mod.Trunc = Math.trunc;\n  return Math.trunc(A);\nend;\n\nfunction Copy(const S: string; Index, Size: Integer): String; assembler;\nasm\n  if (Index<1) Index = 1;\n  return (Size>0) ? S.substring(Index-1,Index+Size-1) : \"\";\nend;\n\nfunction Copy(const S: string; Index: Integer): String; assembler;\nasm\n  if (Index<1) Index = 1;\n  return S.substr(Index-1);\nend;\n\nprocedure Delete(var S: String; Index, Size: Integer);\nvar\n  h: String;\nbegin\n  if (Index<1) or (Index>length(S)) or (Size<=0) then exit;\n  h:=S;\n  S:=copy(h,1,Index-1)+copy(h,Index+Size);\nend;\n\nfunction Pos(const Search, InString: String): Integer; assembler;\nasm\n  return InString.indexOf(Search)+1;\nend;\n\nfunction Pos(const Search, InString: String; StartAt : Integer): Integer; assembler; overload;\nasm\n  return InString.indexOf(Search,StartAt-1)+1;\nend;\n\nprocedure Insert(const Insertion: String; var Target: String; Index: Integer);\nvar\n  t: String;\nbegin\n  if Insertion='' then exit;\n  t:=Target;\n  if Index<1 then\n    Target:=Insertion+t\n  else if Index>length(t) then\n    Target:=t+Insertion\n  else\n    Target:=copy(t,1,Index-1)+Insertion+copy(t,Index,length(t));\nend;\n\nvar\n  WriteBuf: String;\n  WriteCallBack : TConsoleHandler;\n\nFunction SetWriteCallBack(H : TConsoleHandler) : TConsoleHandler;\n\nbegin\n  Result:=WriteCallBack;\n  WriteCallBack:=H;\nend;\n\nprocedure Write;\nvar\n  i: Integer;\nbegin\n  for i:=0 to JSArguments.Length-1 do\n    if Assigned(WriteCallBack) then\n      WriteCallBack(JSArguments[i],False)\n    else\n      WriteBuf:=WriteBuf+String(JSArguments[i]);\nend;\n\nprocedure Writeln;\n\nvar\n  i,l: Integer;\n  s: String;\n\nbegin\n  L:=JSArguments.Length-1;\n  if Assigned(WriteCallBack) then\n    begin\n    for i:=0 to L do\n      WriteCallBack(JSArguments[i],I=L);\n    end\n  else\n    begin\n    s:=WriteBuf;\n    for i:=0 to L do\n      s:=s+String(JSArguments[i]);\n    asm\n      console.log(s);\n    end;\n    WriteBuf:='';\n    end;\nend;\n\nfunction Int(const A: Double): double;\n\nbegin\n  // trunc contains fix for missing Math.trunc in IE\n  Result:=Trunc(A);\nend;\n\nfunction Number(S: String): Double; external name 'Number';\n\nfunction valint(const S: String; MinVal, MaxVal: NativeInt; out Code: Integer): NativeInt;\nvar\n  x: double;\nbegin\n  x:=Number(S);\n  if isNaN(x) then\n    case copy(s,1,1) of\n    '$': x:=Number('0x'+copy(S,2));\n    '&': x:=Number('0o'+copy(S,2));\n    '%': x:=Number('0b'+copy(S,2));\n    else\n      Code:=1;\n      exit;\n    end;\n  if isNaN(x) or (X<>Int(X)) then\n    Code:=1\n  else if (x<MinVal) or (x>MaxVal) then\n    Code:=2\n  else\n    begin\n    Result:=Trunc(x);\n    Code:=0;\n    end;\nend;\n\nprocedure val(const S: String; out NI : NativeInt; out Code: Integer);\nbegin\n  NI:=valint(S,low(NI),high(NI),Code);\nend;\n\nprocedure val(const S: String; out NI: NativeUInt; out Code: Integer);\nvar\n  x : double;\nbegin\n  x:=Number(S);\n  if isNaN(x) or (X<>Int(X)) or (X<0) then\n    Code:=1\n  else\n    begin\n    Code:=0;\n    NI:=Trunc(x);\n    end;\nend;\n\nprocedure val(const S: String; out SI : ShortInt; out Code: Integer);\nbegin\n  SI:=valint(S,low(SI),high(SI),Code);\nend;\n\nprocedure val(const S: String; out SI: smallint; out Code: Integer);\nbegin\n  SI:=valint(S,low(SI),high(SI),Code);\nend;\n\nprocedure val(const S: String; out C: Cardinal; out Code: Integer);\nbegin\n  C:=valint(S,low(C),high(C),Code);\nend;\n\nprocedure val(const S: String; out B: Byte; out Code: Integer);\nbegin\n  B:=valint(S,low(B),high(B),Code);\nend;\n\nprocedure val(const S: String; out W: word; out Code: Integer);\nbegin\n  W:=valint(S,low(W),high(W),Code);\nend;\n\nprocedure val(const S : String; out I : integer; out Code : Integer);\nbegin\n  I:=valint(S,low(I),high(I),Code);\nend;\n\nprocedure val(const S : String; out d : double; out Code : Integer);\nVar\n  x: double;\nbegin\n  x:=Number(S);\n  if isNaN(x) then\n    Code:=1\n  else\n    begin\n    Code:=0;\n    d:=x;\n    end;\nend;\n\nprocedure val(const S: String; out b: boolean; out Code: Integer);\nbegin\n  if SameText(S,'true') then\n    begin\n    Code:=0;\n    b:=true;\n    end\n  else if SameText(S,'false') then\n    begin\n    Code:=0;\n    b:=false;\n    end\n  else\n    Code:=1;\nend;\n\nfunction upcase(c : char) : char; assembler;\nasm\n  return c.toUpperCase();\nend;\n\nfunction StringOfChar(c: Char; l: NativeInt): String;\nvar\n  i: Integer;\nbegin\n  asm\n    if ((l>0) && c.repeat) return c.repeat(l);\n  end;\n  Result:='';\n  for i:=1 to l do Result:=Result+c;\nend;\n\nfunction Assigned(const V: JSValue): boolean; assembler;\nasm\n  return (V!=undefined) && (V!=null) && (!rtl.isArray(V) || (V.length > 0));\nend;\n\nfunction StrictEqual(const A: JSValue; const B): boolean; assembler;\nasm\n  return A === B;\nend;\n\nfunction StrictInequal(const A: JSValue; const B): boolean; assembler;\nasm\n  return A !== B;\nend;\n\n{ TContainedObject }\n\nfunction TContainedObject.QueryInterface(const iid: TGuid; out obj): Integer;\nbegin\n  if GetInterface(iid,obj) then\n    Result:=S_OK\n  else\n    Result:=Integer(E_NOINTERFACE);\nend;\n\n{ TAggregatedObject }\n\nfunction TAggregatedObject.GetController: IUnknown;\nbegin\n  Result := IUnknown(fController);\nend;\n\nfunction TAggregatedObject.QueryInterface(const iid: TGuid; out obj): Integer;\nbegin\n  Result := IUnknown(fController).QueryInterface(iid, obj);\nend;\n\nfunction TAggregatedObject._AddRef: Integer;\nbegin\n  Result := IUnknown(fController)._AddRef;\nend;\n\nfunction TAggregatedObject._Release: Integer;\nbegin\n  Result := IUnknown(fController)._Release;\nend;\n\nconstructor TAggregatedObject.Create(const aController: IUnknown);\nbegin\n  inherited Create;\n  { do not keep a counted reference to the controller! }\n  fController := Pointer(aController);\nend;\n\n{ TInterfacedObject }\n\nfunction TInterfacedObject.QueryInterface(const iid: TGuid; out obj): Integer;\nbegin\n  if GetInterface(iid,obj) then\n    Result:=S_OK\n  else\n    Result:=Integer(E_NOINTERFACE);\nend;\n\nfunction TInterfacedObject._AddRef: Integer;\nbegin\n  inc(fRefCount);\n  Result:=fRefCount;\nend;\n\nfunction TInterfacedObject._Release: Integer;\nbegin\n  dec(fRefCount);\n  Result:=fRefCount;\n  if fRefCount=0 then\n    Destroy;\nend;\n\nprocedure TInterfacedObject.BeforeDestruction;\nbegin\n  if fRefCount<>0 then\n    asm\n    rtl.raiseE('EHeapMemoryError');\n    end;\nend;\n\n{ TObject }\n\nconstructor TObject.Create;\nbegin\n\nend;\n\ndestructor TObject.Destroy;\nbegin\n\nend;\n\nprocedure TObject.Free;\nbegin\n  Destroy;\nend;\n\nclass function TObject.ClassType: TClass; assembler;\nasm\n  return this;\nend;\n\nclass function TObject.ClassNameIs(const Name: string): boolean;\nbegin\n  Result:=SameText(Name,ClassName);\nend;\n\nclass function TObject.InheritsFrom(aClass: TClass): boolean; assembler;\nasm\n  return (aClass!=null) && ((this==aClass) || aClass.isPrototypeOf(this));\nend;\n\nprocedure TObject.AfterConstruction;\nbegin\n\nend;\n\nprocedure TObject.BeforeDestruction;\nbegin\n\nend;\n\nfunction TObject.GetInterface(const iid: TGuid; out obj): boolean;\nbegin\n  asm\n    var i = iid.$intf;\n    if (i){\n      // iid is the private TGuid of an interface\n      i = rtl.getIntfG(this,i.$guid,2);\n      if (i){\n        obj.set(i);\n        return true;\n      }\n    }\n  end;\n  Result := GetInterfaceByStr(GUIDToString(iid),obj);\nend;\n\nfunction TObject.GetInterface(const iidstr: String; out obj): boolean;\nbegin\n  Result := GetInterfaceByStr(iidstr,obj);\nend;\n\nfunction TObject.GetInterfaceByStr(const iidstr: String; out obj): boolean;\nbegin\n  if not TJSObj(IObjectInstance)['$str'] then\n    TJSObj(IObjectInstance)['$str']:=GUIDToString(IObjectInstance);\n  if iidstr = TJSObj(IObjectInstance)['$str'] then\n    begin\n    obj:=Self;\n    exit(true);\n    end;\n  asm\n    var i = rtl.getIntfG(this,iidstr,2);\n    obj.set(i);\n    return i!==null;\n  end;\n  Result:=false;\nend;\n\nfunction TObject.GetInterfaceWeak(const iid: TGuid; out obj): boolean;\nbegin\n  Result:=GetInterface(iid,obj);\n  asm\n    if (Result){\n      var o = obj.get();\n      if (o.$kind==='com'){\n        o._Release();\n      }\n    }\n  end;\nend;\n\nfunction TObject.Equals(Obj: TObject): boolean;\nbegin\n  Result:=Obj=Self;\nend;\n\nfunction TObject.ToString: String;\nbegin\n  Result:=ClassName;\nend;\n\n\ninitialization\n  ExitCode:=0; // set it here, so that WPO does not remove it\n\nend.\n\n","{\n    This file is part of the Pas2JS run time library.\n    Copyright (c) 2017 by Mattias Gaertner\n\n    See the file COPYING.FPC, included in this distribution,\n    for details about the copyright.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n **********************************************************************}\nunit JS;\n\n{$mode objfpc}\n{$modeswitch externalclass}\n\ninterface\n\nuses\n  Types;\n\ntype\n  // We cannot use EConvertError or Exception, this would result in a circular dependency.\n\n  { EJS }\n\n  EJS = class(TObject)\n  private\n    FMessage: string;\n  Public\n    constructor Create(const Msg: String); reintroduce;\n    property Message : string Read FMessage Write FMessage;\n  end;\n\n  TJSObjectPropertyDescriptor = JSValue;\n  Float32 = Double;\n  Float64 = Double;\n\n  { TJSObject }\n\n  TJSObject = class external name 'Object'\n  private\n    function GetProperties(Name: String): JSValue; external name '[]';\n    procedure SetProperties(Name: String; const AValue: JSValue); external name '[]';\n  public\n    constructor new;\n    class function create(const proto: TJSObject): TJSObject;\n    class function create(const proto, propertiesObject: TJSObject): TJSObject;\n    class function assign(const Target, Source1: TJSObject): TJSObject; varargs;\n    class procedure defineProperty(const obj: TJSObject; propname: String; const descriptor: TJSObjectPropertyDescriptor);\n    //class procedure defineProperties\n    class function freeze(const obj: TJSObject): TJSObject;\n    class function getOwnPropertyDescriptor(const obj: TJSObject; propname: String): TJSObjectPropertyDescriptor;\n    //class function getOwnPropertyDescriptors\n    class function getOwnPropertyNames(const obj: TJSObject): TStringDynArray;\n    {$IFDEF FIREFOX}\n    class function getOwnPropertySymbols(const obj: TJSObject): TJSValueDynArray;\n    {$ENDIF}\n    class function getPrototypeOf(const obj: TJSObject): TJSObject;\n    {$IFDEF FIREFOX}\n    class function _is(const value1, value2: JSValue): boolean;\n    {$ENDIF}\n    class function isExtensible(const obj: TJSObject): boolean;\n    class function isFrozen(const obj: TJSObject): boolean;\n    class function isSealed(const obj: TJSObject): boolean;\n    class function keys(const obj: TJSObject): TStringDynArray;\n    class function preventExtensions(const obj: TJSObject): TJSObject;\n    class function seal(const obj: TJSObject): TJSObject;\n    class function setPrototypeOf(const obj, prototype: TJSObject): TJSObject;\n    function hasOwnProperty(prop: String): boolean;\n    function isPrototypeOf(const obj: TJSObject): boolean;\n    function propertyIsEnumerable(propname: String): boolean;\n    function toLocaleString: String;\n    function toString: String;\n    function valueOf: JSValue;\n    property Properties[Name: String]: JSValue read GetProperties write SetProperties; default;\n  end;\n\n  TJSObjectDynArray = Array of TJSObject;\n  TJSObjectDynArrayArray = Array of TJSObjectDynArray;\n  TJSStringDynArray = Array of String;\n\n  { TJSFunction }\n\n  TJSFunction = class external name 'Function'(TJSObject)\n  private\n    Flength: NativeInt external name 'length';\n    Fprototyp: TJSFunction external name 'prototyp';\n  public\n    name: String;\n    property prototyp: TJSFunction read Fprototyp;\n    property length: NativeInt read Flength;\n    function apply(thisArg: TJSObject; const ArgArray: TJSValueDynArray): JSValue; varargs;\n    function bind(thisArg: TJSObject): JSValue; varargs;\n    function call(thisArg: TJSObject): JSValue; varargs;\n  end;\n\n  { TJSDate - wrapper for JavaScript Date }\n\n  TJSDate = class external name 'Date'(TJSFunction)\n  private\n    function getDate: NativeInt;\n    function getFullYear: NativeInt;\n    function getHours: NativeInt;\n    function getMilliseconds: NativeInt;\n    function getMinutes: NativeInt;\n    function getMonth: NativeInt;\n    function getSeconds: NativeInt;\n    function getYear: NativeInt;\n    function getTime: NativeInt;\n    function getUTCDate: NativeInt;\n    function getUTCFullYear: NativeInt;\n    function getUTCHours: NativeInt;\n    function getUTCMilliseconds: NativeInt;\n    function getUTCMinutes: NativeInt;\n    function getUTCMonth: NativeInt;\n    function getUTCSeconds: NativeInt;\n    procedure setDate(const AValue: NativeInt);\n    procedure setFullYear(const AValue: NativeInt);\n    procedure setHours(const AValue: NativeInt);\n    procedure setMilliseconds(const AValue: NativeInt);\n    procedure setMinutes(const AValue: NativeInt);\n    procedure setMonth(const AValue: NativeInt);\n    procedure setSeconds(const AValue: NativeInt);\n    procedure setYear(const AValue: NativeInt);\n    procedure setTime(const AValue: NativeInt);\n    procedure setUTCDate(const AValue: NativeInt);\n    procedure setUTCFullYear(const AValue: NativeInt);\n    procedure setUTCHours(const AValue: NativeInt);\n    procedure setUTCMilliseconds(const AValue: NativeInt);\n    procedure setUTCMinutes(const AValue: NativeInt);\n    procedure setUTCMonth(const AValue: NativeInt);\n    procedure setUTCSeconds(const AValue: NativeInt);\n  public\n    constructor New; reintroduce;\n    constructor New(const MilliSecsSince1970: NativeInt); // milliseconds since 1 January 1970 00:00:00 UTC, with leap seconds ignored\n    constructor New(const aDateString: String); // RFC 2822, ISO8601\n    constructor New(aYear: NativeInt; aMonth: NativeInt; aDayOfMonth: NativeInt = 1;\n      TheHours: NativeInt = 0; TheMinutes: NativeInt = 0; TheSeconds: NativeInt = 0;\n      TheMilliseconds: NativeInt = 0);\n    class function now: NativeInt; // current date and time in milliseconds since 1 January 1970 00:00:00 UTC, with leap seconds ignored\n    class function parse(const aDateString: string): NativeInt; // format depends on browser\n    class function UTC(aYear: NativeInt; aMonth: NativeInt = 0; aDayOfMonth: NativeInt = 1;\n      TheHours: NativeInt = 0; TheMinutes: NativeInt = 0; TheSeconds: NativeInt = 0;\n      TheMilliseconds: NativeInt = 0): NativeInt;\n    function getDay: NativeInt;\n    function getTimezoneOffset: NativeInt;\n    function getUTCDay: NativeInt; // day of the week\n    function toDateString: string; // human readable date, without time\n    function toISOString: string; // ISO 8601 Extended Format\n    function toJSON: string;\n    function toGMTString: string; // in GMT timezone\n    function toLocaleDateString: string; // date in locale timezone, no time\n    function toLocaleString: string; reintroduce; // date and time in locale timezone\n    function toLocaleTimeString: string; // time in locale timezone, no date\n    function toTimeString: string; // time human readable, no date\n    function toUTCString: string; // date and time using UTC timezone\n    property Year: NativeInt read getYear write setYear;\n    property Time: NativeInt read getTime write setTime; // milliseconds since 1 January 1970 00:00:00 UTC, with leap seconds ignored\n    property FullYear: NativeInt read getFullYear write setFullYear;\n    property UTCDate: NativeInt read getUTCDate write setUTCDate; // day of month\n    property UTCFullYear: NativeInt read getUTCFullYear write setUTCFullYear;\n    property UTCHours: NativeInt read getUTCHours write setUTCHours;\n    property UTCMilliseconds: NativeInt read getUTCMilliseconds write setUTCMilliseconds;\n    property UTCMinutes: NativeInt read getUTCMinutes write setUTCMinutes;\n    property UTCMonth: NativeInt read getUTCMonth write setUTCMonth;\n    property UTCSeconds: NativeInt read getUTCSeconds write setUTCSeconds;\n    property Month: NativeInt read getMonth write setMonth;\n    property Date: NativeInt read getDate write setDate; // day of the month, starting at 1\n    property Hours: NativeInt read getHours write setHours;\n    property Minutes: NativeInt read getMinutes write setMinutes;\n    property Seconds: NativeInt read getSeconds write setSeconds;\n    property Milliseconds: NativeInt read getMilliseconds write setMilliseconds;\n  end;\n\n  TLocaleCompareOptions = record\n    localematched : string;\n    usage: string;\n    sensitivity : string;\n    ignorePunctuation : Boolean;\n    numeric : boolean;\n    caseFirst : string;\n  end;\n\n  TJSRegexp = class external name 'RegExp'\n  private\n  {$IFDEF FIREFOX}\n    // not on all browsers:\n    FFlags : string; external name 'flags';\n    FSticky : boolean; external name 'sticky';\n  {$endif}\n    fglobal: boolean; external name 'global';\n    fignoreCase : boolean; external name 'ignoreCase';\n    fmultiline : boolean; external name 'multiline';\n    fsource : string; external name 'source';\n    funicode : boolean; external name 'unicode';\n  public\n    Constructor New(Pattern : string);\n    Constructor New(Pattern, Flags : string);\n    lastIndex: NativeInt;\n    function exec(aString : string): TStringDynArray;\n    function test(aString : string) : boolean;\n    function toString : String;\n    property Global : boolean read fglobal;\n    property IgnoreCase : Boolean read FIgnoreCase;\n    property Multiline : Boolean Read FMultiLine;\n    Property Source : string Read FSource;\n    Property Unicode : boolean Read FUnicode;\n    {$IFDEF FIREFOX}\n    // not on all browsers:\n    property Flags : string read FFlags;\n    property Sticky : boolean read FSticky;\n    {$endif}\n  end;\n\n\n  TReplaceCallBack = Function () : string; varargs;\n\n  TJSString = class external name 'String'\n  private\n    flength : NativeInt; external name 'length';\n  public \n    constructor New(Const S : String);\n    constructor New(Const I : NativeInt);\n    constructor New(Const D : double);\n    property length : NativeInt read flength; \n    class function fromCharCode() : string; varargs;\n    class function fromCodePoint() : string; varargs;\n    function anchor(const aName : string) : string;\n    function charAt(aIndex : NativeInt) : string;\n    function charCodeAt(aIndex : NativeInt) : NativeInt;\n    function codePointAt(aIndex : NativeInt) : NativeInt;\n    function concat(s : string) : string; varargs;\n    function endsWith(aSearchString : string; Pos : NativeInt = 0) : boolean;\n    function includes(aSearchString : string; Pos : NativeInt = 0) : boolean;\n    function indexOf(aSearchString : String; Pos : NativeInt = 0) : Integer;\n    function lastIndexOf(aSearchString : String) : NativeInt;overload;\n    function lastIndexOf(aSearchString : String; Pos : NativeInt) : Integer;overload;\n    function link(aUrl : string) : String;\n    function localeCompare(aCompareString : string) : NativeInt; overload;\n    function localeCompare(aCompareString : string; aLocales: string) : integer; overload;\n    function localeCompare(compareString : string; locales: string; Options : TlocaleCompareOptions) : integer; overload;\n    function match(aRegexp : TJSRegexp) : TStringDynArray; overload;\n    function match(aRegexp : String) : TStringDynArray;overload;\n    {$IFDEF ECMAScript6}\n    function normalize : string;\n    function normalize(aForm : string) : string;\n    {$ENDIF}\n    function _repeat(aCount : NativeInt) : Integer; external name 'repeat';\n    function replace(aRegexp : String; NewString : String) : String; overload;\n    function replace(aRegexp : TJSRegexp; NewString : String) : String; overload;\n    function replace(Regexp : String; aCallback : TReplaceCallBack) : String; overload;\n    function replace(Regexp : TJSRegexp; aCallback : TReplaceCallBack) : String; overload;\n    function search(Regexp : TJSRegexp) : NativeInt; overload;\n    function search(Regexp : JSValue) : NativeInt; overload;\n    function slice(aBeginIndex : NativeInt) : String; overload;\n    function slice(aBeginIndex, aEndIndex : NativeInt) : String; overload;\n    function split : TStringDynArray; overload;\n    function split(aSeparator : string) : TStringDynArray; overload;\n    function split(aSeparator : string; aLimit : NativeInt) : TStringDynArray; overload;\n    function startsWith(aSearchString : String) : Boolean; overload;\n    function startsWith(aSearchString : String; aPosition : NativeInt) : Boolean; overload;\n    function substr(aStartIndex : NativeInt) : String; overload;\n    function substr(aStartIndex,aLength : NativeInt) : String; overload;\n    function subString(aStartIndex : NativeInt) : String; overload;\n    function subString(aStartIndex,aEndIndex : NativeInt) : String; overload;\n    function toLocaleLowerCase : String;\n    function toLocaleUpperCase : String;\n    function toLowerCase : String;\n    function toString : string;\n    function toUpperCase : String;\n    function trim : string;\n    function valueOf : string;\n  end;\n\n  TJSArray = Class;\n  \n  TJSArrayEvent = reference to function (element : JSValue; index: NativeInt; anArray : TJSArray) : Boolean;\n  TJSArrayMapEvent = reference to function (element : JSValue; index: NativeInt; anArray : TJSArray) : JSValue;\n  TJSArrayReduceEvent = reference to function (accumulator, currentValue : JSValue; currentIndex : NativeInt; anArray : TJSArray) : JSValue;\n  TJSArrayCompareEvent = reference to function (a,b : JSValue) : NativeInt;\n  TJSArrayCallback = TJSArrayEvent;\n  TJSArrayMapCallback = TJSArrayMapEvent;\n  TJSArrayReduceCallBack = TJSArrayReduceEvent;\n  TJSArrayCompareCallBack = TJSArrayCompareEvent;\n\n  { TJSArray }\n\n  TJSArray = Class external name 'Array'\n  private\n    function GetElements(Index: NativeInt): JSValue; external name '[]';\n    procedure SetElements(Index: NativeInt; const AValue: JSValue); external name '[]';\n  public\n    FLength : NativeInt; external name 'length';\n    constructor new; overload;\n    constructor new(aLength : NativeInt); overload;\n    constructor new(aElement1 : JSValue); varargs; overload;\n    class function _of() : TJSArray; varargs; external name 'of'; \n    class function isArray(a: JSValue) : Boolean;\n{$IFDEF JAVASCRIPT2015}    \n    class function from(a : JSValue) : TJSArray;\n{$ENDIF}    \n    function concat(el : JSValue) : TJSArray; varargs;\n    function copyWithin(aTarget : NativeInt) : TJSarray;overload; // not in IE\n    function copyWithin(aTarget, aStart : NativeInt) : TJSarray;overload; // not in IE\n    function copyWithin(aTarget, aStart, aEnd : NativeInt) : TJSarray;overload; // not in IE\n    Function every(const aCallback : TJSArrayCallBack) : boolean;overload;\n    Function every(const aCallback : TJSArrayEvent; aThis : TObject) : boolean;overload;\n    Function filter(const aCallBack : TJSArrayCallBack) : TJSArray; overload;\n    Function filter(const aCallBack : TJSArrayEvent; aThis : TObject) : TJSArray;overload;\n    Function fill(aValue : JSValue) : TJSArray; overload;\n    Function fill(aValue : JSValue; aStartIndex : NativeInt) : TJSArray; overload;\n    Function fill(aValue : JSValue; aStartIndex,aEndIndex : NativeInt) : TJSArray; overload;\n    Function find(const aCallBack : TJSArrayCallBack) : JSValue; overload;\n    Function find(const aCallBack : TJSArrayEvent; aThis : TObject) : JSValue; overload;\n    Function findIndex(const aCallBack : TJSArrayCallBack) : NativeInt; overload;\n    Function findIndex(const aCallBack : TJSArrayEvent; aThis : TObject) : NativeInt; overload;\n    procedure forEach(const aCallBack : TJSArrayEvent); overload;\n    procedure forEach(const aCallBack : TJSArrayEvent; aThis : TObject); overload;\n    function includes(aElement : JSValue) : Boolean; overload;\n    function includes(aElement : JSValue; FromIndex : NativeInt) : Boolean; overload;\n    function indexOf(aElement : JSValue) : NativeInt; overload;\n    function indexOf(aElement : JSValue; FromIndex : NativeInt) : NativeInt; overload;\n    function join : String; overload;\n    function join (aSeparator : string) : String; overload;\n    function lastIndexOf(aElement : JSValue) : NativeInt; overload;\n    function lastIndexOf(aElement : JSValue; FromIndex : NativeInt) : NativeInt; overload;\n    Function map(const aCallBack : TJSArrayMapCallBack) : TJSArray; overload;\n    Function map(const aCallBack : TJSArrayMapEvent; aThis : TObject) : TJSArray; overload;\n    function pop : JSValue; \n    function push(aElement : JSValue) : NativeInt; varargs;\n    function reduce(const aCallBack : TJSArrayReduceCallBack) : JSValue; overload;\n    function reduce(const aCallBack : TJSArrayReduceCallBack; initialValue : JSValue) : JSValue; overload;\n    function reduceRight(const aCallBack : TJSArrayReduceCallBack) : JSValue; overload;\n    function reduceRight(const aCallBack : TJSArrayReduceCallBack; initialValue : JSValue) : JSValue; overload;\n    Function reverse : TJSArray;\n    Function shift : JSValue;\n    Function slice : TJSArray; overload;\n    function slice(aBegin : NativeInt) : TJSArray; overload;\n    function slice(aBegin,aEnd : NativeInt) : TJSArray; overload;\n    Function some(const aCallback : TJSArrayCallBack) : boolean; overload;\n    Function some(const aCallback : TJSArrayEvent; aThis : TObject) : boolean; overload;\n    Function sort(const aCallback : TJSArrayCompareCallBack) : TJSArray; overload;\n    Function sort() : TJSArray; overload;\n    function splice(aStart : NativeInt) : TJSArray; overload;\n    function splice(aStart,aDeleteCount : NativeInt) : TJSArray; varargs; overload;\n    function toLocaleString: String; overload;\n    function toLocaleString(locales : string) : String; overload;\n    function toLocaleString(locales : string; const Options : TLocaleCompareOptions) : String; overload;\n    function toString : String;\n    function unshift : NativeInt; varargs; \n    Property Length : NativeInt Read FLength Write FLength;\n    property Elements[Index: NativeInt]: JSValue read GetElements write SetElements; default;\n  end;\n\n  TJSArrayBuffer = Class external name 'ArrayBuffer'\n  private\n    fLength : NativeInt; external name 'byteLength';\n  public\n    constructor new(aByteLength : NativeInt);\n    class function isView(aValue : JSValue) : Boolean;   \n    function slice(aBegin : NativeInt) : TJSArrayBuffer; overload;\n    function slice(aBegin,aEnd : NativeInt) : TJSArrayBuffer; overload;\n    Property byteLength : NativeInt Read fLength;\n  end;\n\n  TJSBufferSource = class external name 'BufferSource'\n  end;\n\n  { TJSTypedArray }\n  TJSTypedArray = Class;\n\n  TJSTypedArrayCallBack = function (element : JSValue; index: NativeInt; anArray : TJSTypedArray) : Boolean;\n  TJSTypedArrayEvent = function (element : JSValue; index: NativeInt; anArray : TJSTypedArray) : Boolean of object;\n  TJSTypedArrayMapCallBack = function (element : JSValue; index: NativeInt; anArray : TJSTypedArray) : JSValue;\n  TJSTypedArrayMapEvent = function (element : JSValue; index: NativeInt; anArray : TJSTypedArray) : JSValue of object;\n  TJSTypedArrayReduceCallBack = function (accumulator, currentValue : JSValue; currentIndex : NativeInt; anArray : TJSTypedArray) : JSValue;\n  TJSTypedArrayCompareCallBack = function (a,b : JSValue) : NativeInt;\n\n  TJSTypedArray = class external name 'TypedArray' (TJSBufferSource)\n  Private\n    FBuffer: TJSArrayBuffer; external name 'buffer';\n    FByteLength: NativeInt; external name 'byteLength';\n    FLength: NativeInt; external name 'length';\n    FByteOffset: NativeInt; external name 'byteOffset';\n    function getValue(Index : NativeInt) : JSValue; external name '[]';\n    procedure setValue(Index : NativeInt;AValue : JSValue); external name '[]';\n  Public\n    class var BYTES_PER_ELEMENT : NativeInt;\n    class var name : string;\n    class function from(aValue : jsValue) : TJSTypedArray;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSTypedArray;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSTypedArray;\n    class function _of(aValue : jsValue) : TJSTypedArray; varargs; external name 'of';\n    function copyWithin(aTarget : NativeInt) : TJSTypedArray;overload;\n    function copyWithin(aTarget, aStart : NativeInt) : TJSTypedArray;overload;\n    function copyWithin(aTarget, aStart, aEnd : NativeInt) : TJSTypedArray;overload;\n    Function every(const aCallback : TJSTypedArrayCallBack) : boolean;overload;\n    Function every(const aCallback : TJSTypedArrayEvent; aThis : TObject) : boolean;overload;\n    Function fill(aValue : JSValue) : TJSTypedArray; overload;\n    Function fill(aValue : JSValue; aStartIndex : NativeInt) : TJSTypedArray; overload;\n    Function fill(aValue : JSValue; aStartIndex,aEndIndex : NativeInt) : TJSTypedArray; overload;\n    Function filter(const aCallBack : TJSTypedArrayCallBack) : TJSTypedArray; overload;\n    Function filter(const aCallBack : TJSTypedArrayEvent; aThis : TObject) : TJSTypedArray;overload;\n    Function find(const aCallBack : TJSTypedArrayCallBack) : JSValue; overload;\n    Function find(const aCallBack : TJSTypedArrayEvent; aThis : TObject) : JSValue; overload;\n    Function findIndex(const aCallBack : TJSTypedArrayCallBack) : NativeInt; overload;\n    Function findIndex(const aCallBack : TJSTypedArrayEvent; aThis : TObject) : NativeInt; overload;\n    procedure forEach(const aCallBack : TJSTypedArrayCallBack); overload;\n    procedure forEach(const aCallBack : TJSTypedArrayEvent; aThis : TObject); overload;\n    function includes(aElement : JSValue) : Boolean; overload;\n    function includes(aElement : JSValue; FromIndex : NativeInt) : Boolean; overload;\n    function indexOf(aElement : JSValue) : NativeInt; overload;\n    function indexOf(aElement : JSValue; FromIndex : NativeInt) : NativeInt; overload;\n    function join : String; overload;\n    function join (aSeparator : string) : String; overload;\n    function lastIndexOf(aElement : JSValue) : NativeInt; overload;\n    function lastIndexOf(aElement : JSValue; FromIndex : NativeInt) : NativeInt; overload;\n    Function map(const aCallBack : TJSTypedArrayCallBack) : TJSTypedArray; overload;\n    Function map(const aCallBack : TJSTypedArrayEvent; aThis : TObject) : TJSTypedArray; overload;\n    function reduce(const aCallBack : TJSTypedArrayReduceCallBack) : JSValue; overload;\n    function reduce(const aCallBack : TJSTypedArrayReduceCallBack; initialValue : JSValue) : JSValue; overload;\n    function reduceRight(const aCallBack : TJSTypedArrayReduceCallBack) : JSValue; overload;\n    function reduceRight(const aCallBack : TJSTypedArrayReduceCallBack; initialValue : JSValue) : JSValue; overload;\n    Function reverse : TJSTypedArray;\n    procedure _set(anArray : TJSArray); external name 'set';\n    procedure _set(anArray : TJSArray; anOffset : NativeInt); external name 'set';\n    procedure _set(anArray : TJSTypedArray); external name 'set';\n    procedure _set(anArray : TJSTypedArray; anOffset : NativeInt); external name 'set';\n    Function slice : TJSTypedArray; overload;\n    function slice(aBegin : NativeInt) : TJSTypedArray; overload;\n    function slice(aBegin,aEnd : NativeInt) : TJSTypedArray; overload;\n    Function some(const aCallback : TJSTypedArrayCallBack) : boolean; overload;\n    Function some(const aCallback : TJSTypedArrayEvent; aThis : TObject) : boolean; overload;\n    Function sort(const aCallback : TJSTypedArrayCompareCallBack) : TJSTypedArray; overload;\n    Function sort() : TJSTypedArray; overload;\n    function splice(aStart : NativeInt) : TJSTypedArray; overload;\n    function splice(aStart,aDeleteCount : NativeInt) : TJSTypedArray; varargs; overload;\n    function toLocaleString: String; overload;\n    function toLocaleString(locales : string) : String; overload;\n    function toLocaleString(locales : string; const Options : TLocaleCompareOptions) : String; overload;\n    function toString : String;\n    function unshift : NativeInt; varargs;\n    property buffer : TJSArrayBuffer read FBuffer;\n    property byteLength : NativeInt Read FByteLength;\n    property byteOffset : NativeInt Read FByteOffset;\n    property length : NativeInt Read FLength;\n    property values[Index : NativeInt] : JSValue Read getValue Write SetValue; default;\n  end;\n\n  { TJSInt8Array }\n\n  TJSInt8Array = class external name 'Int8Array' (TJSTypedArray)\n  private\n    function getTypedValue(Index : NativeInt): Shortint; external name '[]';\n    procedure setTypedValue(Index : NativeInt; AValue: Shortint);external name '[]';\n  public\n    constructor new (length : NativeInt);\n    constructor new (atypedArray : TJSTypedArray);\n    constructor new (aObject : TJSObject);\n    constructor new (buffer : TJSArrayBuffer);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\n    class function from(aValue : jsValue) : TJSInt8Array; reintroduce;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSInt8Array; reintroduce;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSInt8Array; reintroduce;\n    class function _of(aValue : jsValue) : TJSInt8Array; varargs; external name 'of'; reintroduce;\n    procedure _set(anArray : Array of ShortInt); external name 'set'; reintroduce;\n    procedure _set(anArray : Array of ShortInt; anOffset : NativeInt); external name 'set';\n    property values[Index : NativeInt] : Shortint Read getTypedValue Write setTypedValue; default;\n  end;\n\n  TJSUint8Array  = class external name 'Uint8Array' (TJSTypedArray)\n  private\n    function getTypedValue(Index : NativeInt): Byte; external name '[]';\n    procedure setTypedValue(Index : NativeInt; AValue: Byte);external name '[]';\n  public\n    constructor new (length : NativeInt);\n    constructor new (atypedArray : TJSTypedArray);\n    constructor new (aObject : TJSObject);\n    constructor new (buffer : TJSArrayBuffer);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\n    class function from(aValue : jsValue) : TJSUInt8Array; reintroduce;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSUInt8Array; reintroduce;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSUInt8Array; reintroduce;\n    class function _of(aValue : jsValue) : TJSUInt8Array; varargs; external name 'of'; reintroduce;\n    procedure _set(anArray : Array of Byte); external name 'set'; reintroduce;\n    procedure _set(anArray : Array of Byte; anOffset : NativeInt); external name 'set';\n    Property values[Index : NativeInt] : Byte Read getTypedValue Write setTypedValue; default;\n  end;\n\n  TJSUint8ClampedArray  = class external name 'Uint8ClampedArray' (TJSTypedArray)\n  private\n    function getTypedValue(Index : NativeInt): Byte; external name '[]';\n    procedure setTypedValue(Index : NativeInt; AValue: Byte);external name '[]';\n  public\n    constructor new (length : NativeInt);\n    constructor new (atypedArray : TJSTypedArray);\n    constructor new (aObject : TJSObject);\n    constructor new (buffer : TJSArrayBuffer);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\n    class function from(aValue : jsValue) : TJSUInt8ClampedArray; reintroduce;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSUInt8ClampedArray; reintroduce;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSUInt8ClampedArray; reintroduce;\n    class function _of(aValue : jsValue) : TJSUInt8ClampedArray; varargs; external name 'of'; reintroduce;\n    procedure _set(anArray : Array of Byte); external name 'set'; reintroduce;\n    procedure _set(anArray : Array of Byte; anOffset : NativeInt); external name 'set';\n    Property values[Index : NativeInt] : Byte Read getTypedValue Write setTypedValue; default;\n  end;\n\n  TJSInt16Array = class external name 'Int16Array' (TJSTypedArray)\n  private\n    function getTypedValue(Index : NativeInt): smallint; external name '[]';\n    procedure setTypedValue(Index : NativeInt; AValue: Smallint);external name '[]';\n  public\n    constructor new (length : NativeInt);\n    constructor new (atypedArray : TJSTypedArray);\n    constructor new (aObject : TJSObject);\n    constructor new (buffer : TJSArrayBuffer);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\n    class function from(aValue : jsValue) : TJSInt16Array; reintroduce;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSInt16Array; reintroduce;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSInt16Array; reintroduce;\n    class function _of(aValue : jsValue) : TJSInt16Array; varargs; external name 'of'; reintroduce;\n    procedure _set(anArray : Array of SmallInt); external name 'set'; reintroduce;\n    procedure _set(anArray : Array of SmallInt; anOffset : NativeInt); external name 'set';\n    Property values[Index : NativeInt] : SmallInt Read getTypedValue Write setTypedValue; default;\n  end;\n\n  TJSUint16Array = class external name 'Uint16Array' (TJSTypedArray)\n  private\n    function getTypedValue(Index : NativeInt): Word; external name '[]';\n    procedure setTypedValue(Index : NativeInt; AValue: Word);external name '[]';\n  public\n    constructor new (length : NativeInt);\n    constructor new (atypedArray : TJSTypedArray);\n    constructor new (aObject : TJSObject);\n    constructor new (buffer : TJSArrayBuffer);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\n    class function from(aValue : jsValue) : TJSUInt16Array; reintroduce;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSUInt16Array; reintroduce;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSUInt16Array; reintroduce;\n    class function _of(aValue : jsValue) : TJSUInt16Array; varargs; external name 'of'; reintroduce;\n    procedure _set(anArray : Array of Word); external name 'set'; reintroduce;\n    procedure _set(anArray : Array of Word; anOffset : NativeInt); external name 'set';\n    Property values[Index : NativeInt] : Word Read getTypedValue Write setTypedValue; default;\n  end;\n\n  TJSInt32Array = class external name 'Int32Array' (TJSTypedArray)\n  private\n    function getTypedValue(Index : NativeInt): longint; external name '[]';\n    procedure setTypedValue(Index : NativeInt; AValue: longint);external name '[]';\n  public\n    constructor new (length : NativeInt);\n    constructor new (atypedArray : TJSTypedArray);\n    constructor new (aObject : TJSObject);\n    constructor new (buffer : TJSArrayBuffer);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\n    class function from(aValue : jsValue) : TJSInt32Array; reintroduce;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSInt32Array; reintroduce;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSInt32Array; reintroduce;\n    class function _of(aValue : jsValue) : TJSInt32Array; varargs;external name 'of'; reintroduce;\n    procedure _set(anArray : Array of LongInt); external name 'set'; reintroduce;\n    procedure _set(anArray : Array of LongInt; anOffset : NativeInt); external name 'set';\n    Property values[Index : NativeInt] : longint Read getTypedValue Write setTypedValue; default;\n  end;\n\n  TJSUint32Array = class external name 'Uint32Array' (TJSTypedArray)\n  private\n    function getTypedValue(Index : NativeInt): LongWord; external name '[]';\n    procedure setTypedValue(Index : NativeInt; AValue: LongWord);external name '[]';\n  public\n    constructor new (length : NativeInt);\n    constructor new (atypedArray : TJSTypedArray);\n    constructor new (aObject : TJSObject);\n    constructor new (buffer : TJSArrayBuffer);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\n    class function from(aValue : jsValue) : TJSUInt32Array; reintroduce;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSUInt32Array; reintroduce;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSUInt32Array; reintroduce;\n    class function _of(aValue : jsValue) : TJSUInt32Array; varargs; external name 'of'; reintroduce;\n    procedure _set(anArray : Array of Cardinal); external name 'set'; reintroduce;\n    procedure _set(anArray : Array of Cardinal; anOffset : NativeInt); external name 'set';\n    Property values[Index : NativeInt] : LongWord Read getTypedValue Write setTypedValue; default;\n  end;\n\n  TJSFloat32Array = class external name 'Float32Array' (TJSTypedArray)\n  private\n    function getTypedValue(Index : NativeInt): Float32; external name '[]';\n    procedure setTypedValue(Index : NativeInt; AValue: Float32);external name '[]';\n  public\n    constructor new (length : NativeInt);\n    constructor new (atypedArray : TJSTypedArray);\n    constructor new (aObject : TJSObject);\n    constructor new (buffer : TJSArrayBuffer);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\n    class function from(aValue : jsValue) : TJSFloat32Array; reintroduce;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSFloat32Array; reintroduce;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSFloat32Array; reintroduce;\n    class function _of(aValue : jsValue) : TJSFloat32Array; varargs; reintroduce;\n    procedure _set(anArray : Array of Double); external name 'set'; reintroduce;\n    procedure _set(anArray : Array of Double; anOffset : NativeInt); external name 'set'; reintroduce;\n    Property values[Index : NativeInt] : Float32 Read getTypedValue Write setTypedValue; default;\n  end;\n\n  TJSFloat64Array = class external name 'Float64Array' (TJSTypedArray)\n  private\n    function getTypedValue(Index : NativeInt): Float64; external name '[]';\n    procedure setTypedValue(Index : NativeInt; AValue: Float64);external name '[]';\n  public\n    constructor new (length : NativeInt);\n    constructor new (atypedArray : TJSTypedArray);\n    constructor new (aObject : TJSObject);\n    constructor new (buffer : TJSArrayBuffer);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset: NativeInt);\n    constructor new (buffer : TJSArrayBuffer; aByteOffset, aLength: NativeInt);\n    class function from(aValue : jsValue) : TJSFloat64Array; reintroduce;\n    class function from(aValue : jsValue; Map : TJSTypedArrayMapCallBack) : TJSFloat64Array; reintroduce;\n    class function from(aValue : jsValue; aMap : TJSTypedArrayMapEvent) : TJSFloat64Array; reintroduce;\n    class function _of(aValue : jsValue) : TJSFloat64Array; varargs; reintroduce;\n    procedure _set(anArray : Array of Double); external name 'set'; reintroduce;\n    procedure _set(anArray : Array of Double; anOffset : NativeInt); external name 'set'; reintroduce;\n    Property values[Index : NativeInt] : Float64 Read getTypedValue Write setTypedValue; default;\n  end;\n\n  TJSDataView = Class external name 'DataView' (TJSBufferSource)\n  private\n    fBuffer : TJSArrayBuffer; external name 'buffer';\n    fLength : NativeInt; external name 'byteLength';\n    fOffset : NativeInt; external name 'byteOffset';\n  public\n    constructor new(aBuffer : TJSArrayBuffer); overload;\n    constructor new(aBuffer : TJSArrayBuffer; aOffset : NativeInt); overload;\n    constructor new(aBuffer : TJSArrayBuffer; aOffset,aByteLength : NativeInt); overload;\n    function getFloat32(aByteOffset : NativeInt) : double; overload;\n    function getFloat32(aByteOffset : NativeInt; aLittleEndian: Boolean) : double; overload;\n    function getFloat64(aByteOffset : NativeInt) : double; overload;\n    function getFloat64(aByteOffset : NativeInt; aLittleEndian: Boolean) : double; overload;\n    function getInt8(aByteOffset : NativeInt) : ShortInt; \n    function getInt16(aByteOffset : NativeInt) : SmallInt; overload;\n    function getInt16(aByteOffset : NativeInt; aLittleEndian : Boolean) : SmallInt; overload;\n    function getInt32(aByteOffset : NativeInt) : Longint; overload;\n    function getInt32(aByteOffset : NativeInt; aLittleEndian : Boolean) : Longint; overload;\n    function getUint8(aByteOffset : NativeInt) : Byte; overload;\n    function getUint16(aByteOffset : NativeInt) : Word; overload;\n    function getUint16(aByteOffset : NativeInt; aLittleEndian : Boolean) : Word; overload;\n    function getUint32(aByteOffset : NativeInt) : LongWord; overload;\n    function getUint32(aByteOffset : NativeInt; aLittleEndian : Boolean) : LongWord; overload;\n\n    procedure setFloat32(aByteOffset : NativeInt; aValue : double); overload;\n    procedure setFloat32(aByteOffset : NativeInt; aValue : double; aLittleEndian: Boolean); overload;\n    procedure setFloat64(aByteOffset : NativeInt; aValue : double); overload;\n    procedure setFloat64(aByteOffset : NativeInt; aValue : double; aLittleEndian: Boolean); overload;\n    procedure setInt8(aByteOffset : NativeInt; aValue : ShortInt); \n    procedure setInt16(aByteOffset : NativeInt; aValue : SmallInt); overload;\n    procedure setInt16(aByteOffset : NativeInt; aValue : SmallInt; aLittleEndian : Boolean); overload;\n    procedure setInt32(aByteOffset : NativeInt; aValue : Longint); overload;\n    procedure setInt32(aByteOffset : NativeInt; aValue : Longint; aLittleEndian : Boolean); overload;\n    procedure setUint8(aByteOffset : NativeInt; aValue : Byte); overload;\n    procedure setUint16(aByteOffset : NativeInt; aValue : Word); overload;\n    procedure setUint16(aByteOffset : NativeInt; aValue : Word; aLittleEndian : Boolean); overload;\n    procedure setUint32(aByteOffset : NativeInt; aValue : LongWord); overload;\n    procedure setUint32(aByteOffset : NativeInt; aValue: LongWord; aLittleEndian : Boolean); overload;\n \n    Property byteLength : NativeInt Read fLength;\n    Property byteOffset : NativeInt read fOffset;\n    property buffer : TJSArrayBuffer Read fBuffer;\n  end;\n\n  TJSJSON = class external name 'JSON' (TJSObject)\n  Public\n    class function parse(aJSON : String) : JSValue;\n    // Use this only when you are sure you will get an object, no checking is done.\n    class function parseObject(aJSON : String) : TJSObject; external name 'parse';\n    class function stringify(aValue : JSValue) : string;\n    class function stringify(aValue,aReplacer : JSValue) : string;\n    class function stringify(aValue,aReplacer : JSValue; space:  NativeInt) : string;\n    class function stringify(aValue,aReplacer : JSValue; space:  String) : string;\n  end;\n\n  { TJSError }\n\n  TJSError = Class external name 'Error'\n  private\n    FMessage: String; external name 'message';\n    {$ifdef NodeJS}\n    FStack: JSValue; external name 'stack';\n    {$endif}\n  Public\n    Constructor new;\n    Constructor new(Const aMessage : string);\n    Constructor new(Const aMessage,aFileName : string);\n    Constructor new(Const aMessage,aFileName : string; aLineNumber : NativeInt);\n    Property Message : String Read FMessage;\n    {$ifdef NodeJS}\n    Property Stack: JSValue read FStack;\n    {$endif}\n  end;\n\n\n  TJSPromiseResolver = reference to function (aValue : JSValue) : JSValue;\n  TJSPromiseExecutor = reference to procedure (resolve,reject : TJSPromiseResolver);\n  TJSPromiseFinallyHandler = reference to procedure;\n  TJSPromise = Class;\n  TJSPromiseArray = array of TJSPromise;\n\n  TJSPromise = class external name 'Promise'\n    constructor new(Executor : TJSPromiseExecutor);\n    class function all(arg : Array of JSValue) : TJSPromise; overload;\n    class function all(arg : JSValue) : TJSPromise; overload;\n    class function all(arg : TJSPromiseArray) : TJSPromise; overload;\n    class function race(arg : Array of JSValue) : TJSPromise; overload;\n    class function race(arg : JSValue) : TJSPromise; overload;\n    class function race(arg : TJSPromiseArray) : TJSPromise; overload;\n    class function reject(reason : JSValue) : TJSPromise;\n    class function resolve(value : JSValue): TJSPromise; overload;\n    class function resolve : TJSPromise; overload;\n    function _then (onAccepted : TJSPromiseResolver) : TJSPromise; external name 'then';\n    function catch (onRejected : TJSPromiseResolver) : TJSPromise;\n    function _finally(value : TJSPromiseFinallyHandler): TJSPromise;\n  end;\n\n  TJSFunctionArguments = class external name 'arguments'\n  private\n    FLength: NativeInt; external name 'length';\n    function GetElements(Index: NativeInt): JSValue; external name '[]';\n    procedure SetElements(Index: NativeInt; const AValue: JSValue); external name '[]';\n  public\n    property Length: NativeInt read FLength;\n    property Elements[Index: NativeInt]: JSValue read GetElements write SetElements; default;\n  end;\n\nvar\n  // JSArguments can be used in procedures/functions to provide access to the 'arguments' array.\n  JSArguments: TJSFunctionArguments; external name 'arguments';\n  // JSThis can be used in all code to access the javascript 'this' object.\n  JSThis: TJSObject; external name 'this';\n  // JSExceptValue can be used in catch blocks to access the JS throw value\n  JSExceptValue: JSValue; external name '$e';\n\nfunction new(aElements: TJSValueDynArray) : TJSObject; overload;\nfunction JSDelete(const Obj: JSValue; const PropName: string): boolean; assembler; overload;\n\nfunction decodeURIComponent(encodedURI : String) : String; external name 'decodeURIComponent';\nfunction encodeURIComponent(str : String) : String; external name 'encodeURIComponent';\n\nfunction parseInt(s: String; Radix: NativeInt): NativeInt; overload; external name 'parseInt'; // may result NaN\nfunction parseInt(s: String): NativeInt; overload; external name 'parseInt'; // may result NaN\nfunction parseFloat(s: String): double; overload; external name 'parseFloat'; // may result NaN\n\nfunction hasString(const v: JSValue): boolean; external name 'rtl.hasString';// isString(v) and v<>''\nfunction hasValue(const v: JSValue): boolean; assembler; // returns the JS definition of if(v): v is not false, undefined, null, 0, NaN, or the empty string. Note: JS if(new Boolean(false)) returns true.\nfunction isArray(const v: JSValue): boolean; external name 'rtl.isArray';\nfunction isBoolean(const v: JSValue): boolean; assembler;\nfunction isCallback(const v: JSValue): boolean; assembler;\nfunction isChar(const v: JSValue): boolean; assembler;\nfunction isClass(const v: JSValue): boolean; assembler; // is a Pascal class, e.g. a TClass\nfunction isClassInstance(const v: JSValue): boolean; assembler;// is a Pascal class instance, e.g. a TObject\nfunction isFunction(const v: JSValue): boolean; external name 'rtl.isFunction';\nfunction isInteger(const v: JSValue): boolean; assembler;\nfunction isModule(const v: JSValue): boolean; external name 'rtl.isModule';\nfunction isNull(const v: JSValue): boolean; assembler;\nfunction isNumber(const v: JSValue): boolean; external name 'rtl.isNumber';\nfunction isObject(const v: JSValue): boolean; external name 'rtl.isObject'; // true if not null and a JS Object\nfunction isRecord(const v: JSValue): boolean; assembler;\nfunction isString(const v: JSValue): boolean; external name 'rtl.isString';\nfunction isUndefined(const v: JSValue): boolean; assembler;\nfunction isDefined(const v: JSValue): boolean; assembler;\nfunction isUTF16Char(const v: JSValue): boolean; assembler;\nfunction isExt(const InstanceOrClass, aClass: JSValue): boolean; external name 'rtl.isExt'; // aClass can be a JS object or function\nfunction jsInstanceOf(const aFunction, aFunctionWithPrototype: JSValue): String; assembler;\nfunction jsTypeOf(const v: JSValue): String; external name 'typeof';\nfunction jsIsNaN(const v: JSValue): boolean; external name 'isNaN';// true if value cannot be converted to a number. e.g. True on NaN, undefined, {}, '123'. False on true, null, '', ' ', '1A'\nfunction toNumber(const v: JSValue): double; assembler; // if not possible, returns NaN\nfunction toInteger(const v: JSValue): NativeInt; // if v is not an integer, returns 0\nfunction toObject(Value: JSValue): TJSObject; // If Value is not a Javascript object, returns Nil\nfunction toArray(Value: JSValue): TJSArray; // If Value is not a Javascript array, returns Nil\nfunction toBoolean(Value: JSValue): Boolean; // If Value is not a Boolean, returns False\nfunction toString(Value: JSValue): String; // If Value is not a string, returns ''\n\nType\n  TJSValueType = (jvtNull,jvtBoolean,jvtInteger,jvtFloat,jvtString,jvtObject,jvtArray);\n\nFunction GetValueType(JS : JSValue) : TJSValueType;\n\nConst\n  Null : JSValue; external name 'null';\n  Undefined : JSValue; external name 'undefined';\n\nimplementation\n\nfunction new(aElements: TJSValueDynArray): TJSObject;\n\n  function toString(I : Integer): string; external name 'String';\n\nVar\n  L,I : integer;\n  S : String;\n\nbegin\n  L:=length(aElements);\n  if (L mod 2)=1 then\n    raise EJS.Create('Number of arguments must be even');\n  I:=0;\n  // Check all arguments;\n  While (i<L) do\n    begin\n    if Not isString(aElements[i]) then\n      begin\n      S:=ToString(I);\n      raise EJS.Create('Argument '+S+' must be a string.');\n      end;\n    inc(I,2);\n    end;\n  I:=0;\n  Result:=TJSObject.New;\n  While (i<L) do\n    begin\n    S:=String(aElements[i]);\n    Result.Properties[S]:=aElements[i+1];\n    inc(I,2);\n    end;\nend;\n\nfunction JSDelete(const Obj: JSValue; const PropName: string): boolean; assembler;\nasm\n  return delete Obj[PropName];\nend;\n\nfunction hasValue(const v: JSValue): boolean; assembler;\nasm\n  if(v){ return true; } else { return false; };\nend;\n\nfunction isBoolean(const v: JSValue): boolean; assembler;\nasm\n  return typeof(v) == 'boolean';\nend;\n\nfunction isCallback(const v: JSValue): boolean; assembler;\nasm\n  return rtl.isObject(v) && rtl.isObject(v.scope) && (rtl.isString(v.fn) || rtl.isFunction(v.fn));\nend;\n\nfunction isChar(const v: JSValue): boolean; assembler;\nasm\n  return (typeof(v)!=\"string\") && (v.length==1);\nend;\n\nfunction isClass(const v: JSValue): boolean; assembler;\nasm\n  return (typeof(v)==\"object\") && (v!=null) && (v.$class == v);\nend;\n\nfunction isClassInstance(const v: JSValue): boolean; assembler;\nasm\n  return (typeof(v)==\"object\") && (v!=null) && (v.$class == Object.getPrototypeOf(v));\nend;\n\nfunction isInteger(const v: JSValue): boolean; assembler;\nasm\n  return Math.floor(v)===v;\nend;\n\nfunction isNull(const v: JSValue): boolean; assembler;\n// Note: use identity, \"==\" would fit undefined\nasm\n  return v === null;\nend;\n\nfunction isRecord(const v: JSValue): boolean; assembler;\nasm\n  return (typeof(v)===\"object\")\n      && (typeof(v.$new)===\"function\")\n      && (typeof(v.$clone)===\"function\")\n      && (typeof(v.$eq)===\"function\")\n      && (typeof(v.$assign)===\"function\");\nend;\n\nfunction isUndefined(const v: JSValue): boolean; assembler;\nasm\n  return v == undefined;\nend;\n\nfunction isDefined(const v: JSValue): boolean; assembler;\nasm\n  return !(v == undefined);\nend;\n\nfunction isUTF16Char(const v: JSValue): boolean; assembler;\nasm\n  if (typeof(v)!=\"string\") return false;\n  if ((v.length==0) || (v.length>2)) return false;\n  var code = v.charCodeAt(0);\n  if (code < 0xD800){\n    if (v.length == 1) return true;\n  } else if (code <= 0xDBFF){\n    if (v.length==2){\n      code = v.charCodeAt(1);\n      if (code >= 0xDC00 && code <= 0xDFFF) return true;\n    };\n  };\n  return false;\nend;\n\nfunction jsInstanceOf(const aFunction, aFunctionWithPrototype: JSValue\n  ): String; assembler;\nasm\n  return aFunction instanceof aFunctionWithPrototype;\nend;\n\nfunction toNumber(const v: JSValue): double; assembler;\nasm\n  return v-0;\nend;\n\nfunction toInteger(const v: JSValue): NativeInt;\nbegin\n  if IsInteger(v) then\n    Result:=NativeInt(v)\n  else\n    Result:=0;\nend;\n\nfunction toObject(Value: JSValue): TJSObject;\n\nbegin\n  if IsObject(Value) then\n    Result:=TJSObject(Value)\n  else\n    Result:=Nil;\nend;\n\nfunction toArray(Value: JSValue): TJSArray; // If not possible, returns Nil\n\nbegin\n  if IsArray(Value) then\n    Result:=TJSArray(Value)\n  else\n    Result:=Nil;\nend;\n\nfunction toBoolean(Value: JSValue): Boolean; // If not possible, returns False\n\nbegin\n  if isBoolean(Value) then\n    Result:=Boolean(Value)\n  else\n    Result:=False;\nend;\n\nfunction toString(Value: JSValue): String; // If not possible, returns ''\n\nbegin\n  if IsString(Value) then\n    Result:=String(Value)\n  else\n    Result:='';\nend;\n\n{ EJS }\n\nconstructor EJS.Create(const Msg: String);\nbegin\n  FMessage:=Msg;\nend;\n\n\nfunction GetValueType(JS: JSValue): TJSValueType;\n\nVar\n  t : string;\n\nbegin\n  if isNull(js) then   // null reported as object\n    result:=jvtNull\n  else\n    begin\n    t:=jsTypeOf(js);\n    if (t='string') then\n      Result:=jvtString\n    else if (t='boolean') then\n      Result:=jvtBoolean\n    else if (t='object') then\n      begin\n      if IsArray(JS) then\n        Result:=jvtArray\n      else\n        Result:=jvtObject;\n      end\n    else if (t='number') then\n      if isInteger(JS) then\n        result:=jvtInteger\n      else\n        result:=jvtFloat\n    end;\nend;\n\nend.\n\n","{\n    This file is part of the Pas2JS run time library.\n    Copyright (c) 2017 by Mattias Gaertner\n\n    See the file COPYING.FPC, included in this distribution,\n    for details about the copyright.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n **********************************************************************}\nunit SysUtils;\n\n{$mode objfpc}\n\ninterface\n\nuses\n  RTLConsts, js;\n\nprocedure FreeAndNil(var Obj);\n\ntype\n  TProcedure = procedure;\n\n {*****************************************************************************\n                              Various types\n  *****************************************************************************}\nConst\n  FloatRecDigits = 19;\n\ntype\n  { TFloatRec }\n  TFloatRec = Record\n    Exponent: Integer;\n    Negative: Boolean;\n    Digits: Array[0..FloatRecDigits-1] of Char;\n  End;\n  TEndian = (Little,Big);\n  TFileName = String;\n  TByteArray = array [0..32767] of Byte;\n  TWordArray = array [0..16383] of Word;\n  TBytes = Array of byte;\n  TStringArray = array of string;\n\n  TMonthNameArray = array [1..12] of string;\n  TDayTable = array [1..12] of Word;\n  TWeekNameArray = array [1..7] of string;\n  TMonthNames = TMonthNameArray;\n  TDayNames = array[0..6] of string;\n\n{*****************************************************************************\n                            Exception handling\n*****************************************************************************}\n\n  { Exception }\n\n  Exception = class(TObject)\n  private\n    fMessage: String;\n    fHelpContext: Integer;\n    {$ifdef NodeJS}\n    FNodeJSError: TJSError;\n    {$endif}\n  public\n    constructor Create(const Msg: String); reintroduce;\n    constructor CreateFmt(const Msg: string; const Args: array of jsvalue);\n    constructor CreateHelp(const Msg: String; AHelpContext: Integer);\n    constructor CreateFmtHelp(const Msg: string; const Args: array of jsvalue; AHelpContext: Integer);\n    function ToString: String; override;\n    property HelpContext: Integer read fHelpContext write fHelpContext;\n    property Message: String read fMessage write fMessage;\n    {$ifdef NodeJS}\n    property NodeJSError: TJSError read FNodeJSError write FNodeJSError;\n    {$endif}\n  end;\n\n  ExceptClass = class of Exception;\n\n  EExternal = class(Exception);\n\n  { General math errors }\n  EMathError  = class(EExternal);\n  EInvalidOp  = class(EMathError);\n  EZeroDivide = class(EMathError);\n  EOverflow   = class(EMathError);\n  EUnderflow  = class(EMathError);\n\n  EAbort           = class(Exception);\n  EInvalidCast     = class(Exception);\n  EAssertionFailed = class(Exception);\n  EObjectCheck     = class(Exception);\n\n  { String conversion errors }\n  EConvertError = class(Exception);\n  EFormatError = class(Exception);\n\n\n  { integer math exceptions }\n  EIntError    = Class(EExternal);\n  EDivByZero   = Class(EIntError);\n  ERangeError  = Class(EIntError);\n  EIntOverflow = Class(EIntError);\n\n  { General math errors }\n\n  { Run-time and I/O Errors }\n  EInOutError = class(Exception)\n  public\n    ErrorCode : Integer;\n  end;\n\n  EHeapMemoryError = class(Exception);\n  EHeapException = EHeapMemoryError;\n\n  EExternalException = class(EExternal);\n  EInvalidPointer  = Class(EHeapMemoryError);\n  EOutOfMemory     = Class(EHeapMemoryError);\n\n  { EVariantError }\n\n  EVariantError = Class(Exception)\n    ErrCode : longint;\n    Constructor CreateCode(Code : Longint);\n  end;\n\n  EAccessViolation = Class(EExternal);\n  EBusError = Class(EAccessViolation);\n  EPrivilege = class(EExternal);\n  EStackOverflow = class(EExternal);\n  EControlC = class(EExternal);\n\n  { String conversion errors }\n\n  { Other errors }\n  EAbstractError   = Class(Exception);\n\n  EPropReadOnly = class(Exception);\n  EPropWriteOnly = class(Exception);\n\n  EIntfCastError = class(Exception);\n  EInvalidContainer = class(Exception);\n  EInvalidInsert = class(Exception);\n\n  EPackageError = class(Exception);\n\n  EOSError = class(Exception)\n  public\n    ErrorCode: Longint;\n  end;\n\n  ESafecallException = class(Exception);\n  ENoThreadSupport = Class(Exception);\n  ENoWideStringSupport = Class(Exception);\n  ENotImplemented = class(Exception);\n\n  EArgumentException = class(Exception);\n  EArgumentOutOfRangeException = class(EArgumentException);\n  EArgumentNilException = class(EArgumentException);\n\n  EPathTooLongException = class(Exception);\n  ENotSupportedException = class(Exception);\n  EDirectoryNotFoundException = class(Exception);\n  EFileNotFoundException = class(Exception);\n  EPathNotFoundException = class(Exception);\n\n  ENoConstructException = class(Exception);\n\n//function GetTickCount: Integer;\n\n\n{*****************************************************************************\n                            String function\n*****************************************************************************}\n\nConst\n  EmptyStr = '';\n  EmptyWideStr = ''; // No difference here.\n  HexDisplayPrefix: string = '$';\n  LeadBytes = [] unimplemented;\n\nFunction CharInSet(Ch: Char;Const CSet : array of char) : Boolean;\n\nfunction LeftStr(const S: string; Count: Integer): String; assembler;\nfunction RightStr(const S: string; Count: Integer): String; assembler;\n\nfunction Trim(const S: String): String; assembler;\nfunction TrimLeft(const S: String): String; assembler;\nfunction TrimRight(const S: String): String; assembler;\n\nfunction UpperCase(const s: String): String; assembler; overload;\nfunction LowerCase(const s: String): String; assembler; overload;\n\nfunction CompareStr(const s1, s2: String): Integer; assembler;\nfunction SameStr(const s1, s2: String): Boolean; assembler;\nfunction CompareText(const s1, s2: String): Integer; assembler;\nfunction SameText(const s1, s2: String): Boolean; assembler;\nfunction AnsiCompareText(const s1, s2: String): Integer; assembler;\nfunction AnsiSameText(const s1, s2: String): Boolean; assembler;\nfunction AnsiCompareStr(const s1, s2: String): Integer;\nprocedure AppendStr(var Dest: String; const S: string);\n\nfunction Format(const Fmt: String; const Args: array of JSValue): String;\n\nfunction BytesOf(const AVal: string): TBytes;\nfunction StringOf(const ABytes: TBytes): string;\n\n// JavaScript built-in functions\nfunction LocaleCompare(const s1, s2, locales: String): Boolean; assembler; overload;\nfunction NormalizeStr(const S: String; const Norm: String = 'NFC'): String; assembler; overload; // not in IE\n\nfunction IsValidIdent(const Ident: string; AllowDots: Boolean = False; StrictDots: Boolean = False): Boolean;\n\nType\n  TStringReplaceFlag = (rfReplaceAll, rfIgnoreCase);\n  TReplaceFlag = TStringReplaceFlag;\n  TStringReplaceFlags = set of TStringReplaceFlag;\n  TReplaceFlags = TStringReplaceFlags;\n\nfunction StringReplace(aOriginal, aSearch, aReplace: string; Flags: TStringReplaceFlags): String;\nfunction QuoteString(aOriginal: String; AQuote: Char): String;\nfunction QuotedStr(const s: string; QuoteChar: Char = ''''): string;\nfunction DeQuoteString(aQuoted: String; AQuote: Char): String;\nfunction IsDelimiter(const Delimiters, S: string; Index: Integer): Boolean;\nfunction AdjustLineBreaks(const S: string): string;\nfunction AdjustLineBreaks(const S: string; Style: TTextLineBreakStyle): string;\nfunction WrapText(const Line, BreakStr: string; const BreakChars: Array of char;  MaxCol: Integer): string;\nfunction WrapText(const Line: string; MaxCol: Integer): string;\n\n{ *****************************************************************************\n  Integer conversions\n  *****************************************************************************}\n\nfunction IntToStr(const Value: Integer): string;\nFunction TryStrToInt(const S : String; Out res : Integer) : Boolean;\nFunction TryStrToInt(const S : String; Out res : NativeInt) : Boolean;\nFunction StrToIntDef(const S : String; Const aDef : Integer) : Integer;\nFunction StrToIntDef(const S : String; Const aDef : NativeInt) : NativeInt;\nFunction StrToInt(const S : String) : Integer;\nFunction StrToNativeInt(const S : String) : NativeInt;\n// For compatibility\nFunction StrToInt64(const S : String) : NativeLargeInt;\nFunction StrToInt64Def(const S : String; ADefault : NativeLargeInt) : NativeLargeInt;\nFunction TryStrToInt64(const S : String; Out res : NativeLargeInt) : Boolean;\nFunction StrToQWord(const S : String) : NativeLargeUInt;\nFunction StrToQWordDef(const S : String; ADefault : NativeLargeUInt) : NativeLargeUInt;\nFunction TryStrToQWord(const S : String; Out res : NativeLargeUInt) : Boolean;\nFunction StrToUInt64(const S : String) : NativeLargeUInt;\nFunction StrToUInt64Def(const S : String; ADefault : NativeLargeUInt) : NativeLargeUInt;\nFunction TryStrToUInt64(const S : String; Out res : NativeLargeUInt) : Boolean;\nFunction StrToDWord(const S : String) : DWord;\nFunction StrToDWordDef(const S : String; ADefault : DWord) : DWord;\nFunction TryStrToDWord(const S : String; Out res : DWord) : Boolean;\n\nfunction IntToHex(Value: NativeInt; Digits: integer): string;\n\n{ *****************************************************************************\n  Float conversions\n  *****************************************************************************}\n\nconst\n  // Note: Currency is internally a double, multiplied by 10000 and truncated.\n  // The below values are the safe limits, within every step exists.\n  // Since currency is a double it can take much larger values, but the result\n  // may differ from Delphi/FPC\n  MaxCurrency: Currency =  450359962737.0495; // fpc: 922337203685477.5807;\n  MinCurrency: Currency = -450359962737.0496; // fpc: -922337203685477.5808;\n\nType\n  TFloatFormat = (ffFixed,ffGeneral,ffExponent,ffNumber,ffCurrency);\n\nFunction FloatToDecimal(Value : double; Precision, Decimals : integer) :  TFloatRec;\nFunction FloatToStr(Value: Double): String;\nFunction FloatToStrF(const Value : double; format: TFloatFormat; Precision, Digits: Integer): String;\nFunction TryStrToFloat(const S : String; Out res : Extended) : Boolean; overload;\nFunction TryStrToFloat(const S : String; Out res : Double) : Boolean; overload;\nFunction StrToFloatDef(const S : String; Const aDef : Double) : Double;\nFunction StrToFloat(const S : String) : Double;\nFunction FormatFloat (Fmt : String; aValue : Double) : String;\n\n{ *****************************************************************************\n  Boolean conversions\n  *****************************************************************************}\n\nVar\n  TrueBoolStrs, FalseBoolStrs : Array of String;\n\nfunction StrToBool(const S: String): Boolean;\nfunction BoolToStr(B: Boolean; UseBoolStrs:Boolean=False): string;\nfunction BoolToStr(B: Boolean; const TrueS, FalseS: String): string;\nfunction StrToBoolDef(const S: String; Default: Boolean): Boolean;\nfunction TryStrToBool(const S: String; out Value: Boolean): Boolean;\n\n\n{*****************************************************************************\n                              OS/Environment\n*****************************************************************************}\n\nConst\n  ConfigExtension : String = '.cfg';\n  SysConfigDir    : String = '';\n\ntype\n  TOnGetEnvironmentVariable = function(Const EnvVar: String): String;\n  TOnGetEnvironmentString = function(Index: Integer): String;\n  TOnGetEnvironmentVariableCount = function: Integer;\nvar\n  OnGetEnvironmentVariable: TOnGetEnvironmentVariable;\n  OnGetEnvironmentString: TOnGetEnvironmentString;\n  OnGetEnvironmentVariableCount: TOnGetEnvironmentVariableCount;\n\nfunction GetEnvironmentVariable(Const EnvVar: String): String;\nfunction GetEnvironmentVariableCount: Integer;\nfunction GetEnvironmentString(Index: Integer): String;\n\nprocedure ShowException(ExceptObject: TObject; ExceptAddr: Pointer);\nProcedure Abort;\n\n{*****************************************************************************\n                               Events\n*****************************************************************************}\nType\n  TEventType = (etCustom,etInfo,etWarning,etError,etDebug);\n  TEventTypes = Set of TEventType;\n\n{*****************************************************************************\n                            Date and time\n*****************************************************************************}\nType\n  \n  TSystemTime = record\n     Year, Month, Day, DayOfWeek: word;\n     Hour, Minute, Second, MilliSecond: word;\n  end ;\n  TTimeStamp = record\n     Time: longint;   { Number of milliseconds since midnight }\n     Date: longint;   { One plus number of days since 1/1/0001 }\n  end ;\n\n\nVar\n  TimeSeparator : char = ':';\n  DateSeparator : char = '-';\n  ShortDateFormat : string = 'yyyy-mm-dd';\n  LongDateFormat : string = 'ddd, yyyy-mm-dd';\n  ShortTimeFormat : string = 'hh:nn';\n  LongTimeFormat : string = 'hh:nn:ss';\n  DecimalSeparator : string = '.';\n  ThousandSeparator : string;\n  TimeAMString : string = 'AM';\n  TimePMString : string = 'PM';\n\nconst\n\n  HoursPerDay = 24;\n  MinsPerHour = 60;\n  SecsPerMin  = 60;\n  MSecsPerSec = 1000;\n  MinsPerDay  = HoursPerDay * MinsPerHour;\n  SecsPerDay  = MinsPerDay * SecsPerMin;\n  MSecsPerDay = SecsPerDay * MSecsPerSec;\n  MaxDateTime: TDateTime =  2958465.99999999;\n  MinDateTime: TDateTime =  -693593.99999999;\n\n  JulianEpoch = TDateTime(-2415018.5);\n  UnixEpoch = JulianEpoch + TDateTime(2440587.5);\n\n  DateDelta = 693594;        // Days between 1/1/0001 and 12/31/1899\n  UnixDateDelta = 25569;\n\n  { True=Leapyear }\n\nVar\n  MonthDays : array [Boolean] of TDayTable =\n    ((31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31),\n     (31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31));\n  ShortMonthNames : TMonthNames = (\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec');\n  LongMonthNames : TMonthNames = (\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December');\n  ShortDayNames : TDayNames = (\n    'Sun',\n    'Mon',\n    'Tue',\n    'Wed',\n    'Thu',\n    'Fri',\n    'Sat');\n\n  LongDayNames : TDayNames = (\n    'Sunday',\n    'Monday',\n    'Tuesday',\n    'Wednesday',\n    'Thursday',\n    'Friday',\n    'Saturday');\n\ntype\n  // Stub, for easier porting of FPC/Delphi code.\n  // Reading/Writing the properties will actually set the global variables\n\n  { TFormatSettings }\n\n  TFormatSettings = class(TObject)\n  private\n    function GetCurrencyDecimals: Byte;\n    function GetCurrencyFormat: Byte;\n    function GetCurrencyString: String;\n    function GetDateSeparator: char;\n    function GetDecimalSeparator: string;\n    function GetLongDateFormat: string;\n    function GetLongDayNames: TDayNames;\n    function GetLongMonthNames: TMonthNames;\n    function GetLongTimeFormat: string;\n    function GetNegCurrFormat: Byte;\n    function GetShortDateFormat: string;\n    function GetShortDayNames: TDayNames;\n    function GetShortMonthNames: TMonthNames;\n    function GetShortTimeFormat: string;\n    function GetThousandSeparator: string;\n    function GetTimeAMString: string;\n    function GetTimePMString: string;\n    function GetTimeSeparator: char;\n    procedure SetCurrencyFormat(AValue: Byte);\n    procedure SetCurrencyString(AValue: String);\n    procedure SetDateSeparator(const Value: char);\n    procedure SetDecimalSeparator(const Value: string);\n    procedure SetLongDateFormat(const Value: string);\n    procedure SetLongDayNames(AValue: TDayNames);\n    procedure SetLongMonthNames(AValue: TMonthNames);\n    procedure SetLongTimeFormat(const Value: string);\n    procedure SetNegCurrFormat(AValue: Byte);\n    procedure SetShortDateFormat(const Value: string);\n    procedure SetShortDayNames(AValue: TDayNames);\n    procedure SetShortMonthNames(AValue: TMonthNames);\n    procedure SetShortTimeFormat(const Value: string);\n    procedure SetCurrencyDecimals(AValue: Byte);\n    procedure SetThousandSeparator(const Value: string);\n    procedure SetTimeAMString(const Value: string);\n    procedure SetTimePMString(const Value: string);\n    procedure SetTimeSeparator(const Value: char);\n  public\n    Property ShortMonthNames : TMonthNames Read GetShortMonthNames Write SetShortMonthNames;\n    Property LongMonthNames : TMonthNames Read GetLongMonthNames Write SetLongMonthNames;\n    Property ShortDayNames : TDayNames Read GetShortDayNames Write SetShortDayNames;\n    Property LongDayNames : TDayNames Read GetLongDayNames Write SetLongDayNames;\n    property TimeSeparator : char read GetTimeSeparator write SetTimeSeparator;\n    property DateSeparator : char read GetDateSeparator write SetDateSeparator;\n    property ShortDateFormat : string read GetShortDateFormat write SetShortDateFormat;\n    property LongDateFormat : string read GetLongDateFormat write SetLongDateFormat;\n    property ShortTimeFormat : string read GetShortTimeFormat write SetShortTimeFormat;\n    property LongTimeFormat : string read GetLongTimeFormat write SetLongTimeFormat;\n    property DecimalSeparator : string read GetDecimalSeparator write SetDecimalSeparator;\n    property ThousandSeparator : string read GetThousandSeparator write SetThousandSeparator;\n    property TimeAMString : string read GetTimeAMString write SetTimeAMString;\n    property TimePMString : string read GetTimePMString write SetTimePMString;\n    Property CurrencyFormat : Byte read GetCurrencyFormat Write SetCurrencyFormat;\n    Property NegCurrFormat : Byte read GetNegCurrFormat Write SetNegCurrFormat;\n    Property CurrencyDecimals : Byte Read GetCurrencyDecimals Write SetCurrencyDecimals;\n    Property CurrencyString : String Read GetCurrencyString Write SetCurrencyString;\n  end;\n\nVar\n  FormatSettings: TFormatSettings;\n  TwoDigitYearCenturyWindow : word = 50;\n                             { Threshold to be subtracted from year before age-detection.}\n\n\nfunction DateTimeToJSDate(aDateTime : TDateTime) : TJSDate;\nfunction JSDateToDateTime(aDate : TJSDate) : TDateTime;\n\nfunction DateTimeToTimeStamp(DateTime: TDateTime): TTimeStamp;\nfunction TimeStampToDateTime(const TimeStamp: TTimeStamp): TDateTime;\nfunction MSecsToTimeStamp(MSecs: NativeInt): TTimeStamp;\nfunction TimeStampToMSecs(const TimeStamp: TTimeStamp): NativeInt;\nfunction TryEncodeDate(Year, Month, Day: Word; out Date: TDateTime): Boolean;\nfunction TryEncodeTime(Hour, Min, Sec, MSec: Word; out Time: TDateTime): Boolean;\nfunction EncodeDate(Year, Month, Day :word): TDateTime;\nfunction EncodeTime(Hour, Minute, Second, MilliSecond:word): TDateTime;\nfunction ComposeDateTime(Date,Time : TDateTime) : TDateTime;\nprocedure DecodeDate(Date: TDateTime; out Year, Month, Day: word);\nfunction DecodeDateFully(const DateTime: TDateTime; out Year, Month, Day, DOW: Word): Boolean;\nprocedure DecodeTime(Time: TDateTime; out Hour, Minute, Second, MilliSecond: word);\nprocedure DateTimeToSystemTime(DateTime: TDateTime; out SystemTime: TSystemTime);\nfunction SystemTimeToDateTime(const SystemTime: TSystemTime): TDateTime;\nfunction DayOfWeek(DateTime: TDateTime): integer;\nfunction Date: TDateTime;\nfunction Time: TDateTime;\nfunction Now: TDateTime;\nfunction IncMonth(const DateTime: TDateTime; NumberOfMonths: integer = 1 ): TDateTime;\nprocedure IncAMonth(var Year, Month, Day: Word; NumberOfMonths: Integer = 1);\nfunction IsLeapYear(Year: Word): boolean;\nfunction DateToStr(Date: TDateTime): string;\n// function DateToStr(Date: TDateTime; const FormatSettings: TFormatSettings): string;\nfunction TimeToStr(Time: TDateTime): string;\n// function TimeToStr(Time: TDateTime; const FormatSettings: TFormatSettings): string;\nfunction DateTimeToStr(DateTime: TDateTime; ForceTimeIfZero : Boolean = False): string;\n// function DateTimeToStr(DateTime: TDateTime; const FormatSettings: TFormatSettings; ForceTimeIfZero : Boolean = False): string;\nfunction StrToDate(const S: String): TDateTime;\nfunction StrToDate(const S: String; separator : char): TDateTime;\nfunction StrToDate(const S: String; const useformat : string; separator : char): TDateTime;\n//function StrToDate(const S: string; FormatSettings : TFormatSettings): TDateTime;\nfunction StrToTime(const S: String): TDateTime;\nfunction StrToTime(const S: String; separator : char): TDateTime;\n// function StrToTime(const S: string; FormatSettings : TFormatSettings): TDateTime;\nfunction StrToDateTime(const S: String): TDateTime;\n//function StrToDateTime(const s: ShortString; const FormatSettings : TFormatSettings): TDateTime;\nfunction FormatDateTime(const FormatStr: string; const DateTime: TDateTime): string;\n// function FormatDateTime(const FormatStr: string; DateTime: TDateTime; const FormatSettings: TFormatSettings; Options : TFormatDateTimeOptions = []): string;\nfunction TryStrToDate(const S: String; out Value: TDateTime): Boolean;\nfunction TryStrToDate(const S: String; out Value: TDateTime; separator : char): Boolean;\nfunction TryStrToDate(const S: String; out Value: TDateTime; const useformat : string; separator : char): Boolean;\n// function TryStrToDate(const S: string; out Value: TDateTime; const FormatSettings: TFormatSettings): Boolean;\nfunction TryStrToTime(const S: String; out Value: TDateTime): Boolean;\nfunction TryStrToTime(const S: String; out Value: TDateTime; separator : char): Boolean;\nfunction TryStrToDateTime(const S: String; out Value: TDateTime): Boolean;\n// function TryStrToTime(const S: string; out Value: TDateTime; const FormatSettings: TFormatSettings): Boolean;\n// function TryStrToDateTime(const S: string; out Value: TDateTime; const FormatSettings: TFormatSettings): Boolean;\nfunction StrToDateDef(const S: String; const Defvalue : TDateTime): TDateTime;\nfunction StrToDateDef(const S: String; const Defvalue : TDateTime; separator : char): TDateTime;\nfunction StrToTimeDef(const S: String; const Defvalue : TDateTime): TDateTime;\nfunction StrToTimeDef(const S: String; const Defvalue : TDateTime; separator : char): TDateTime;\nfunction StrToDateTimeDef(const S: String; const Defvalue : TDateTime): TDateTime;\nfunction CurrentYear:Word;\nprocedure ReplaceTime(var dati: TDateTime; NewTime : TDateTime);\nprocedure ReplaceDate(var DateTime: TDateTime; const NewDate: TDateTime);\nFunction FloatToDateTime (Const Value : Extended) : TDateTime;\n\n{ *****************************************************************************\n  Currency support\n  *****************************************************************************}\n\nVar\n  CurrencyFormat : Byte = 0;\n  NegCurrFormat : Byte = 0;\n  CurrencyDecimals : Byte = 2;\n  CurrencyString : String = '$';\n\nFunction FloattoCurr (Const Value : Extended) : Currency;\nfunction TryFloatToCurr(const Value: Extended; var AResult: Currency): Boolean;\nFunction CurrToStr(Value: Currency): string;\n//Function CurrToStr(Value: Currency; Const FormatSettings: TFormatSettings): string;\nfunction StrToCurr(const S: string): Currency;\n//function StrToCurr(const S: string; Const FormatSettings: TFormatSettings): Currency;\nfunction TryStrToCurr(const S: string;Out Value : Currency): Boolean;\n//function TryStrToCurr(const S: string;Out Value : Currency; Const FormatSettings: TFormatSettings): Boolean;\nfunction StrToCurrDef(const S: string; Default : Currency): Currency;\n//function StrToCurrDef(const S: string; Default : Currency; Const FormatSettings: TFormatSettings): Currency;\n\n{*****************************************************************************\n                               File Paths\n*****************************************************************************}\ntype\n  PathStr = String;\n  TPathStrArray = Array of PathStr;\n\nfunction ChangeFileExt(const FileName, Extension: PathStr): PathStr;\nfunction ExtractFilePath(const FileName: PathStr): PathStr;\nfunction ExtractFileDrive(const FileName: PathStr): PathStr;\nfunction ExtractFileName(const FileName: PathStr): PathStr;\nfunction ExtractFileExt(const FileName: PathStr): PathStr;\nfunction ExtractFileDir(Const FileName : PathStr): PathStr;\nfunction ExtractRelativepath (Const BaseName,DestName : PathStr): PathStr;\nfunction IncludeTrailingPathDelimiter(Const Path : PathStr) : PathStr;\nfunction ExcludeTrailingPathDelimiter(Const Path: PathStr): PathStr;\nfunction IncludeLeadingPathDelimiter(Const Path : PathStr) : PathStr;\nfunction ExcludeLeadingPathDelimiter(Const Path: PathStr): PathStr;\nfunction IsPathDelimiter(Const Path: PathStr; Index: Integer): Boolean;\nFunction SetDirSeparators (Const FileName : PathStr) : PathStr;\nFunction GetDirs (DirName : PathStr) : TPathStrArray;\nfunction ConcatPaths(const Paths: array of PathStr): PathStr;\n\n\n{*****************************************************************************\n                               Interfaces\n*****************************************************************************}\n\nconst\n  GUID_NULL: TGuid = '{00000000-0000-0000-0000-000000000000}';\n\nfunction Supports(const Instance: IInterface; const AClass: TClass; out Obj): Boolean; overload;\nfunction Supports(const Instance: IInterface; const IID: TGuid; out Intf): Boolean; overload;\nfunction Supports(const Instance: TObject; const IID: TGuid; out Intf): Boolean; overload;\nfunction Supports(const Instance: TObject; const IID: TGuidString; out Intf): Boolean; overload;\n\nfunction Supports(const Instance: IInterface; const AClass: TClass): Boolean; overload;\nfunction Supports(const Instance: IInterface; const IID: TGuid): Boolean; overload;\nfunction Supports(const Instance: TObject; const IID: TGuid): Boolean; overload;\nfunction Supports(const Instance: TObject; const IID: TGuidString): Boolean; overload;\n\nfunction Supports(const AClass: TClass; const IID: TGuid): Boolean; overload;\nfunction Supports(const AClass: TClass; const IID: TGuidString): Boolean; overload;\n\nfunction TryStringToGUID(const s: string; out Guid: TGuid): Boolean;\nfunction StringToGUID(const S: string): TGuid;\nfunction GUIDToString(const guid: TGuid): string;\nfunction IsEqualGUID(const guid1, guid2: TGuid): Boolean;\nfunction GuidCase(const guid: TGuid; const List: array of TGuid): Integer;\nFunction CreateGUID(out GUID : TGUID) : Integer;\n\nimplementation\n\nprocedure ShowException(ExceptObject: TObject; ExceptAddr: Pointer);\n\nVar\n  S : String;\n\nbegin\n  S:='Application raised an exception '+ExceptObject.ClassName;\n  if ExceptObject is Exception then\n    S:=S+' : '+Exception(ExceptObject).Message;\n{$IFDEF BROWSER}\n  asm\n    window.alert(S);\n  end;\n{$ENDIF}\n{$IFDEF NODEJS}\n  Writeln(S);\n{$ENDIF}\n  if ExceptAddr=nil then;\nend;\n\nConst\n  SAbortError = 'Operation aborted';\n\nprocedure Abort;\nbegin\n  Raise EAbort.Create(SAbortError);\nend;\n\nType\n  TCharSet = Set of Char;\nFunction CharInSet(Ch: Char;Const CSet : TCharSet) : Boolean;\n\nbegin\n  Result:=Ch in CSet;\nend;\n\nfunction CharInSet(Ch: Char; const CSet: array of char): Boolean;\n\nVar\n  I : integer;\n\nbegin\n  Result:=False;\n  I:=Length(CSet)-1;\n  While (Not Result) and (I>=0) do\n    begin\n    Result:=(Ch=CSet[i]);\n    Dec(I);\n    end;\nend;\n\nfunction LeftStr(const S: string; Count: Integer): String; assembler;\nasm\n  return (Count>0) ? S.substr(0,Count) : \"\";\nend;\n\nfunction RightStr(const S: string; Count: Integer): String; assembler;\nasm\n  var l = S.length;\n  return (Count<1) ? \"\" : ( Count>=l ? S : S.substr(l-Count));\nend;\n\nfunction Trim(const S: String): String; assembler;\nasm\n  return S.trim();\nend;\n\nfunction TrimLeft(const S: String): String; assembler;\nasm\n  return S.replace(/^[\\s\\uFEFF\\xA0\\x00-\\x1f]+/,'');\nend;\n\nfunction TrimRight(const S: String): String; assembler;\nasm\n  return S.replace(/[\\s\\uFEFF\\xA0\\x00-\\x1f]+$/,'');\nend;\n\nfunction IntToStr(const Value: Integer): string;\nbegin\n  Result:=str(Value);\nend;\n\nfunction FloatToDecimal(Value: double; Precision, Decimals: integer): TFloatRec;\n\nConst\n  Rounds = '123456789:';\n\nvar\n  Buffer: String;  //Though str func returns only 25 chars, this might change in the future\n  InfNan: string;\n  OutPos,Error, N, L, C: Integer;\n  GotNonZeroBeforeDot, BeforeDot : boolean;\n\nbegin\n  Result.Negative:=False;\n  Result.Exponent:=0;\n  For C:=0 to FloatRecDigits do\n    Result.Digits[C]:='0';\n  if Value=0 then\n    exit;\n  asm\n    Buffer=Value.toPrecision(21); // Double precision\n  end;\n  // Writeln('Buffer :',Buffer);\n  N := 1;\n  L := Length(Buffer);\n  while Buffer[N]=' ' do\n    Inc(N);\n  Result.Negative := (Buffer[N] = '-');\n  if Result.Negative then\n    Inc(N)\n  else if (Buffer[N] = '+') then\n    inc(N);\n  { special cases for Inf and Nan }\n  if (L>=N+2) then\n    begin\n      InfNan:=copy(Buffer,N,3);\n      if (InfNan='Inf') then\n        begin\n          Result.Digits[0]:=#0;\n          Result.Exponent:=32767;\n          exit\n        end;\n      if (InfNan='Nan') then\n        begin\n          Result.Digits[0]:=#0;\n          Result.Exponent:=-32768;\n          exit\n        end;\n    end;\n  //Start := N;  //Start of digits\n  Outpos:=0;\n  Result.Exponent := 0; BeforeDot := true;\n  GotNonZeroBeforeDot := false;\n  while (L>=N) and (Buffer[N]<>'E') do\n    begin\n      // Writeln('Examining : ',Buffer[N],'( output pos: ',outPos,')');\n      if Buffer[N]='.' then\n        BeforeDot := false\n      else\n        begin\n        if BeforeDot then\n          begin  // Currently this is always 1 char\n            Inc(Result.Exponent);\n            Result.Digits[Outpos] := Buffer[N];\n            if Buffer[N] <> '0' then\n              GotNonZeroBeforeDot := true;\n          end\n        else\n          Result.Digits[Outpos] := Buffer[N];\n        Inc(outpos);\n        end;\n      Inc(N);\n    end;\n  Inc(N); // Pass through 'E'\n  if N<=L then\n    begin\n      Val(Copy(Buffer, N, L-N+1), C, Error); // Get exponent after 'E'\n      Inc(Result.Exponent, C);\n    end;\n  // Calculate number of digits we have from str\n  N:=OutPos;\n  // Writeln('Number of digits: ',N,' requested precision : ',Precision);\n  L:=Length(Result.Digits);\n  While N<L do\n    begin\n    Result.Digits[N]:='0';  //Zero remaining space\n    Inc(N);\n    end;\n  if Decimals + Result.Exponent < Precision Then //After this it is the same as in FloatToDecimal\n    N := Decimals + Result.Exponent\n  Else\n    N := Precision;\n  if N >= L Then\n    N := L-1;\n  // Writeln('Rounding on digit : ',N);\n  if N = 0 Then\n    begin\n      if Result.Digits[0] >= '5' Then\n        begin\n          Result.Digits[0] := '1';\n          Result.Digits[1] := #0;\n          Inc(Result.Exponent);\n        end\n      Else\n        Result.Digits[0] := #0;\n    end  //N=0\n  Else if N > 0 Then\n    begin\n      if Result.Digits[N] >= '5' Then\n        begin\n          Repeat\n            Result.Digits[N] := #0;\n            Dec(N);\n            // Writeln(N,': ',Result.Digits[N],', Rounding to : ',Rounds[StrToInt(Result.Digits[N])]);\n            Result.Digits[N]:=Rounds[StrToInt(Result.Digits[N])+1];\n          Until (N = 0) Or (Result.Digits[N] < ':');\n          If Result.Digits[0] = ':' Then\n            begin\n              Result.Digits[0] := '1';\n              Inc(Result.Exponent);\n            end;\n        end\n      Else\n        begin\n          Result.Digits[N] := '0';\n          While (N > -1) And (Result.Digits[N] = '0') Do\n            begin\n              Result.Digits[N] := #0;\n              Dec(N);\n            end;\n        end;\n      end //N>0\n  Else\n    Result.Digits[0] := #0;\n  if (Result.Digits[0] = #0) and\n     not GotNonZeroBeforeDot then\n    begin\n      Result.Exponent := 0;\n      Result.Negative := False;\n    end;\nend;\n\n\nfunction FloatToStr(Value: Double): String;\nbegin\n  Result:=FloatToStrF(Value,ffGeneral,15,0);\nend;\n\nfunction TryStrToFloat(const S: String; out res: Extended): Boolean;\nbegin\n  Result:=TryStrToFloat(S,double(res));\nend;\n\nfunction TryStrToFloat(const S: String; out res: Double): Boolean;\n\nVar\n  J : JSValue;\n  N : String;\n\nbegin\n  N:=S;\n  // Delocalize\n  if (ThousandSeparator <>'') then\n    N:=StringReplace(N,ThousandSeparator,'',[rfReplaceAll]);\n  if (DecimalSeparator<>'.') then\n    N:=StringReplace(N,DecimalSeparator,'.',[]);\n  J:=parseFloat(N);\n  Result:=Not jsIsNaN(J);\n  if Result then\n    Res:=Double(J);\nend;\n\nfunction StrToFloatDef(const S: String; const aDef: Double): Double;\nbegin\n  if not TryStrToFloat(S,Result) then\n    Result:=aDef;\nend;\n\nfunction StrToFloat(const S: String): Double;\nbegin\n  if not TryStrToFloat(S,Result) then\n    Raise EConvertError.CreateFmt(SErrInvalidFloat,[S]);\nend;\n\nfunction FormatFloat(Fmt: String; aValue: Double): String;\n\nType\n  TPosArray = Array of Integer;\n\nconst\n  MaxPrecision = 18;  // Extended precision\n\nvar\n  // Input in usable format\n  E : Extended;              // Value as extended.\n  FV: TFloatRec;             // Value as floatrec.\n  Section : String;          // Format can contain 3 sections, semicolon separated: Pos;Neg;Zero. This is the one to use.\n  SectionLength : Integer;   // Length of section.\n  // Calculated based on section. Static during output\n  ThousandSep: Boolean;      // Thousands separator detected in format ?\n  IsScientific: Boolean;     // Use Scientific notation ? (E detected in format)\n  DecimalPos: Integer;       // Position of decimal point in pattern.\n  FirstDigit: Integer;       // First actual digit in input (# or 0), relative to decimal point\n  LastDigit: Integer;        // Last required (0) digit, relative to decimal point\n  RequestedDigits: Integer;  // Number of requested digits, # and 0 alike\n  ExpSize : Integer;         // Number of digits in exponent\n  Available: Integer;        // Available digits in FV.\n  // These change during output loop\n  Current: Integer;          // Current digit in available digits\n  PadZeroes: Integer;        // Difference in requested digits before comma and exponent, needs to be padded with zeroes.\n  DistToDecimal: Integer;    // Place of current digit, relative to decimal point taking in account PadZeroes!\n\n  Procedure InitVars;\n\n  begin\n    E:=aValue;\n    Section:='';\n    SectionLength:=0;\n    ThousandSep:=false;\n    IsScientific:=false;\n    DecimalPos:=0;\n    FirstDigit:=MaxInt;\n    LastDigit:=0;\n    RequestedDigits:=0;\n    ExpSize:=0;\n    Available:=-1;\n  end;\n\n  procedure ToResult(const AChar: Char);\n  begin\n    Result:=Result+AChar;\n  end;\n\n  procedure AddToResult(const AStr: String);\n\n  begin\n    Result:=Result+AStr;\n  end;\n\n  procedure WriteDigit(ADigit: Char);\n\n  // Write a digit to result, prepend with decimalseparator or append with 1000 separator\n\n  begin\n    if ADigit=#0 then exit;\n    // Writeln('WriteDigit: ',ADigit,', DistToDecimal: ',DistToDecimal);\n    Dec(DistToDecimal);\n    // -1 -> we've arrived behind the decimal\n    if (DistToDecimal=-1) then\n      begin\n      AddToResult(DecimalSeparator);\n      ToResult(ADigit);\n      end\n    else\n      begin\n      // We're still before the decimal.\n      ToResult(ADigit);\n      if ThousandSep and ((DistToDecimal mod 3)=0) and (DistToDecimal>1) then\n        AddToResult(ThousandSeparator);\n      end;\n  end;\n\n  Function GetDigit : Char;\n\n  // Return next digit from available digits.\n  // May return #0 if none available.\n  // Will return '0' if applicable.\n\n  begin\n    // Writeln(' DistToDecimal <= LastDigit : ',DistToDecimal,' <= ',LastDigit,' have digit: ',Current<=Available, ' (',Current,')');\n    Result:=#0;\n    if (Current<=Available) then\n      begin\n      Result:=FV.Digits[Current];\n      Inc(Current);\n      end\n    else if (DistToDecimal <= LastDigit) then\n      Dec(DistToDecimal)\n    else\n      Result:='0';\n    // Writeln('GetDigit ->: ',Result);\n  end;\n\n  procedure CopyDigit;\n\n  // Copy a digit (#, 0) to the output with the correct value\n\n  begin\n    // Writeln('CopyDigit: Padzeroes: ',PadZeroes,', DistToDecimal: ',DistToDecimal);\n    if (PadZeroes=0) then\n      WriteDigit(GetDigit) // No shift needed, just copy what is available.\n    else if (PadZeroes<0) then\n      begin\n      // We must prepend zeroes\n      Inc(PadZeroes);\n      if (DistToDecimal<=FirstDigit) then\n        WriteDigit('0')\n      else\n        Dec(DistToDecimal);\n      end\n    else\n      begin\n      // We must append zeroes\n      while PadZeroes > 0 do\n        begin\n        WriteDigit(GetDigit);\n        Dec(PadZeroes);\n        end;\n      WriteDigit(GetDigit);\n      end;\n  end;\n\n  Function GetSections(Var SP : TPosArray) : Integer;\n\n  var\n    FL : Integer;\n    i : Integer;\n    C,Q : Char;\n    inQuote : Boolean;\n\n  begin\n    Result:=1;\n    SP[1]:=-1;\n    SP[2]:=-1;\n    SP[3]:=-1;\n    inQuote:=False;\n    Q:=#0;\n    I:=1;\n    FL:=Length(Fmt);\n    while (I<=FL) do\n      begin\n      C:=Fmt[I];\n      case C of\n      ';':\n        begin\n        if not InQuote then\n          begin\n          if Result>3 then\n            Raise Exception.Create('Invalid float format');\n          SP[Result]:=I+1;\n          Inc(Result);\n          end;\n        end;\n      '\"','''':\n        begin\n        if InQuote then\n          InQuote:=C<>Q\n        else\n          begin\n          InQuote:=True;\n          Q:=C;\n          end;\n        end;\n      end;\n      Inc(I);\n      end;\n    if SP[Result]=-1 then\n      SP[Result]:=FL+1;\n  end;\n\n  Procedure AnalyzeFormat;\n\n  var\n    I,Len: Integer;\n    Q,C: Char;\n    InQuote : Boolean;\n\n  begin\n    Len:=Length(Section);\n    I:=1;\n    InQuote:=False;\n    Q:=#0;\n    while (I<=Len) do\n      begin\n      C:=Section[i];\n      if C in ['\"',''''] then\n        begin\n        if InQuote then\n          InQuote:=C<>Q\n        else\n          begin\n          InQuote:=True;\n          Q:=C;\n          end;\n        end\n      else if not InQuote then\n        case C of\n        '.':\n          if (DecimalPos=0) then\n            DecimalPos:=RequestedDigits+1;\n        ',':\n            ThousandSep:=ThousandSeparator<>#0;\n        'e', 'E':\n            begin\n            Inc(I);\n            if (I<Len) then\n              begin\n              C:=Section[i];\n              IsScientific:=C in ['-','+'];\n              if IsScientific then\n                while (I<Len) and (Section[i+1]='0') do\n                  begin\n                  Inc(ExpSize);\n                  Inc(I);\n                  end;\n              if ExpSize>4 then\n                ExpSize:=4;\n              end;\n            end;\n        '#':\n            Inc(RequestedDigits);\n        '0':\n            begin\n            if RequestedDigits<FirstDigit then\n              FirstDigit:=RequestedDigits+1;\n            Inc(RequestedDigits);\n            LastDigit:=RequestedDigits+1;\n            end;\n        end;\n      Inc(I);\n      end;\n    if DecimalPos=0 then\n      DecimalPos:=RequestedDigits+1;\n    // Writeln('LastDigit: ',DecimalPos,'-',LastDigit);\n    LastDigit:=DecimalPos-LastDigit;\n    if LastDigit>0 then\n      LastDigit:=0;\n    // Writeln('FirstDigit: ',DecimalPos,'-',FirstDigit);\n    FirstDigit:=DecimalPos-FirstDigit;\n    if FirstDigit<0 then\n      FirstDigit:=0;\n  end;\n\n  Function ValueOutSideScope : Boolean;\n  begin\n    With FV do\n     Result:=((Exponent >= 18) and (not IsScientific)) or (Exponent = $7FF) or (Exponent = $800)\n  end;\n\n  Procedure CalcRunVars;\n\n  Var\n    D,P: Integer;\n\n  begin\n    if IsScientific then\n      begin\n      P:=RequestedDigits;\n      D:=9999;\n      end\n    else\n      begin\n      P:=MaxPrecision;\n      D:=RequestedDigits-DecimalPos+1;\n      end;\n    FV:=FloatToDecimal(aValue,P,D);\n    // Writeln('Number of digits available : ',Length(FV.Digits));\n    // For p:=0 to Length(FV.Digits)-1 do\n    //   Writeln(P,': ',FV.Digits[p]);\n    DistToDecimal:=DecimalPos-1;\n    // Writeln('DistToDecimal : ',DistToDecimal);\n    if IsScientific then\n      PadZeroes:=0 // No padding.\n    else\n      begin\n      PadZeroes:=FV.Exponent-(DecimalPos-1);\n      if (PadZeroes>=0) then\n        DistToDecimal:=FV.Exponent\n      end;\n    // Writeln('PadZeroes : ',PadZeroes, ', DistToDecimal : ',DistToDecimal);\n    Available:=-1;\n    while (Available<High(FV.Digits)) and (FV.Digits[Available+1]<>#0) do\n      Inc(Available);\n    // Writeln('Available: ',Available);\n  end;\n\n  Function FormatExponent(ASign: Char; aExponent: Integer) : String;\n\n  begin\n    Result:=IntToStr(aExponent);\n    Result:=StringOfChar('0',ExpSize-Length(Result))+Result;\n    if (aExponent<0) then\n      Result:='-'+Result\n    else if (aExponent>0) and (aSign='+') then\n      Result:=aSign+Result;\n  end;\n\nvar\n  I,S : Integer;\n  C,Q : Char;\n  PA : TPosArray;\n  InLiteral : Boolean;\n\nbegin\n  SetLength(PA,4);\n  Result:='';\n  Initvars;\n  // What section to use ?\n  if (E>0) then\n    S:=1\n  else if (E<0) then\n    S:=2\n  else\n    S:=3;\n  PA[0]:=0;\n  I:=GetSections(PA);\n  if (I<S) or (PA[S]-PA[S-1]=0) then\n    S:=1;\n  // Extract correct section\n  SectionLength:=PA[S]-PA[S-1]-1;\n  Section:=Copy(Fmt,PA[S-1]+1,SectionLength);\n  SetLength(Section,SectionLength);\n  // Writeln('Section ',I,' : \"',Section,'\" ',SectionLength);\n  AnalyzeFormat;\n  // Writeln('RequestedDigits: ',RequestedDigits,', DecimalPos : ',DecimalPos,', LastDigit: ',LastDigit,', FirstDigit: ',FirstDigit);\n  CalcRunVars;\n  // If we cannot process value using current settings, fallback\n  if (SectionLength=0) or ValueOutSideScope then\n    begin\n    asm\n     Section=E.toPrecision(15);\n    end;\n    Result:=Section;\n    end;\n  // Get Started\n  I:=1;\n  Current:=0;\n  Q:=' ';\n  InLiteral:=False;\n  if (FV.Negative) and (S=1) then\n    ToResult('-');\n  while (I<=SectionLength) do\n    begin\n    C:=Section[i];\n    // Writeln('Analyzing pos ',I,': \"',C,'\"');\n    If (C in ['\"', '''']) then\n      begin\n      if InLiteral then\n        InLiteral:=C<>Q\n      else\n        begin\n        inLiteral:=True;\n        Q:=C;\n        end;\n      end\n    else if InLiteral then\n      ToResult(C)\n    else\n      case C of\n      '0', '#':\n        CopyDigit;\n      '.', ',':\n        ; // Do nothing, handled by CopyDigit\n      'e', 'E':\n        begin\n        ToResult(C); // Always needed\n        Inc(I);\n        if I<=Length(Section) then\n          begin\n          C:=Section[I];\n          if (C in ['+','-']) then\n            begin\n            AddToResult(FormatExponent(C,FV.Exponent-DecimalPos+1));\n            // Skip rest\n            while (I<SectionLength) and (Section[i+1]='0') do\n              Inc(I);\n            end;\n          end;\n        end;\n      else\n        ToResult(C);\n      end;\n    Inc(i);\n    end;\nend;\n\nfunction StrToBool(const S: String): Boolean;\nbegin\n  if not(TryStrToBool(S,Result)) then\n    raise EConvertError.CreateFmt(SInvalidBoolean,[S]);\nend;\n\nprocedure CheckBoolStrs;\nbegin\n  if Length(TrueBoolStrs)=0 then\n  begin\n    SetLength(TrueBoolStrs,1);\n    TrueBoolStrs[0]:='True';\n  end;\n  if Length(FalseBoolStrs)=0 then\n  begin\n    SetLength(FalseBoolStrs,1);\n    FalseBoolStrs[0]:='False';\n  end;\nend;\n\nfunction BoolToStr(B: Boolean; UseBoolStrs: Boolean): string;\nbegin\n  if UseBoolStrs Then\n  begin\n    CheckBoolStrs;\n    if B then\n      Result:=TrueBoolStrs[0]\n    else\n      Result:=FalseBoolStrs[0];\n  end else\n    if B then\n      Result:='-1'\n    else\n      Result:='0';\nend;\n\nfunction BoolToStr(B: Boolean; const TrueS, FalseS: String): string;\nbegin\n  if B then Result:=TrueS else Result:=FalseS;\nend;\n\nfunction StrToBoolDef(const S: String; Default: Boolean): Boolean;\nbegin\n  if not TryStrToBool(S,Result) then\n    Result:=Default;\nend;\n\nfunction TryStrToBool(const S: String; out Value: Boolean): Boolean;\nVar\n  Temp : String;\n  I    : Longint;\n  D : Double;\n  Code: integer;\nbegin\n  Temp:=uppercase(S);\n  Val(Temp,D,code);\n  Result:=true;\n  If Code=0 then\n    Value:=(D<>0.0)\n  else\n    begin\n      CheckBoolStrs;\n      for I:=low(TrueBoolStrs) to High(TrueBoolStrs) do\n        if Temp=uppercase(TrueBoolStrs[I]) then\n          begin\n            Value:=true;\n            exit;\n          end;\n      for I:=low(FalseBoolStrs) to High(FalseBoolStrs) do\n        if Temp=uppercase(FalseBoolStrs[I]) then\n          begin\n            Value:=false;\n            exit;\n          end;\n      Result:=false;\n    end;\nend;\n\nfunction UpperCase(const s: String): String; assembler;\nasm\n  return s.toUpperCase();\nend;\n\nfunction LowerCase(const s: String): String; assembler;\nasm\n  return s.toLowerCase();\nend;\n\nfunction CompareStr(const s1, s2: String): Integer; assembler;\nasm\n  var l1 = s1.length;\n  var l2 = s2.length;\n  if (l1<=l2){\n    var s = s2.substr(0,l1);\n    if (s1<s){ return -1;\n    } else if (s1>s){ return 1;\n    } else { return l1<l2 ? -1 : 0; };\n  } else {\n    var s = s1.substr(0,l2);\n    if (s<s2){ return -1;\n    } else { return 1; };\n  };\nend;\n\nfunction SameStr(const s1, s2: String): Boolean; assembler;\nasm\n  return s1 == s2;\nend;\n\nfunction CompareText(const s1, s2: String): Integer; assembler;\nasm\n  var l1 = s1.toLowerCase();\n  var l2 = s2.toLowerCase();\n  if (l1>l2){ return 1;\n  } else if (l1<l2){ return -1;\n  } else { return 0; }\nend;\n\nfunction SameText(const s1, s2: String): Boolean; assembler;\nasm\n  return s1.toLowerCase() == s2.toLowerCase();\nend;\n\nfunction AnsiCompareText(const s1, s2: String): Integer; assembler;\nasm\n  return s1.localeCompare(s2);\nend;\n\nfunction AnsiSameText(const s1, s2: String): Boolean; assembler;\nasm\n  return s1.localeCompare(s2) == 0;\nend;\n\nfunction AnsiCompareStr(const s1, s2: String): Integer;\nbegin\n  {$IFDEF ECMAScript6}\n  Result:=CompareText(TJSString(s1).normalize(),TJSString(s2).normalize());\n  {$ELSE}\n  Result:=CompareText(s1,s2);\n  {$ENDIF}\nend;\n\nprocedure AppendStr(var Dest: String; const S: string);\n\nbegin\n  Dest:=Dest+S;\nend;\n\n\nConst\n  feInvalidFormat   = 1;\n  feMissingArgument = 2;\n  feInvalidArgIndex = 3;\n\nProcedure DoFormatError (ErrCode : Longint;const fmt: String);\nbegin\n  //!! must be changed to contain format string...\n  Case ErrCode of\n   feInvalidFormat : raise EConvertError.Createfmt(SInvalidFormat,[Fmt]);\n   feMissingArgument : raise EConvertError.Createfmt(SArgumentMissing,[Fmt]);\n   feInvalidArgIndex : raise EConvertError.Createfmt(SInvalidArgIndex,[Fmt]);\n  end;\nend;\n\nConst\n  maxdigits = 15;\n\nFunction ReplaceDecimalSep(S: String; Const DS : string) : string;\n\nVar\n  P : Integer;\n\nbegin\n  P:=Pos('.',S);\n  if P>0 then\n    Result:=Copy(S,1,P-1)+DS+Copy(S,P+1,Length(S)-P)\n  else\n    Result:=S;\nend;\n\nfunction FormatGeneralFloat(Value : double; Precision : Integer; DS : String) : string;\n\nVar\n  P, PE, Q, Exponent: Integer;\n\nBegin\n  If (Precision = -1) Or (Precision > maxdigits) Then\n     Precision := maxdigits;\n  { First convert to scientific format, with correct precision }\n  Str(Value:precision+7, Result);\n  { Delete leading spaces }\n  Result:=TrimLeft(Result);\n  P:=Pos('.',Result);\n  if P=0 then\n    exit;\n   { Consider removing exponent }\n  PE:=Pos('E',Result);\n  if PE=0 then\n    begin\n    Result:=ReplaceDecimalSep(Result,DS);\n    exit;\n    end;\n  { Read exponent }\n  Q:=PE+2;\n  Exponent := 0;\n  while (Q <= Length(Result)) do\n    begin\n    Exponent := Exponent*10 + Ord(Result[Q])-Ord('0');\n    Inc(Q);\n    end;\n  if Result[PE+1] = '-' then\n    Exponent := -Exponent;\n  if (P+Exponent < PE) and (Exponent > -6) then\n    begin\n    { OK to remove exponent }\n    SetLength(Result,PE-1); { Trim exponent }\n    if Exponent >= 0 then\n      begin\n        { Shift point to right }\n      for Q := 0 to Exponent-1 do\n        begin\n        Result[P] := Result[P+1];\n        Inc(P);\n        end;\n      Result[P] := '.';\n      P := 1;\n      if Result[P] = '-' then\n        Inc(P);\n      while (Result[P] = '0') and (P < Length(Result)) and (Copy(Result,P+1,Length(DS))<>DS) do\n          { Trim leading zeros; conversion above should not give any, but occasionally does\n            because of rounding }\n          System.Delete(Result,P,1);\n      end\n    else\n      begin\n      { Add zeros at start }\n      Insert(Copy('00000',1,-Exponent),Result,P-1);\n      Result[P-Exponent] := Result[P-Exponent-1]; { Copy leading digit }\n      Result[P] := '.';\n      if Exponent <> -1 then\n        Result[P-Exponent-1] := '0';\n      end;\n    { Remove trailing zeros }\n    Q := Length(Result);\n    while (Q > 0) and (Result[Q] = '0') do\n      Dec(Q);\n    if Result[Q] = '.' then\n      Dec(Q); { Remove trailing decimal point }\n    if (Q = 0) or ((Q=1) and (Result[1] = '-')) then\n      Result := '0'\n    else\n      SetLength(Result,Q);\n    end\n  else\n    begin\n    { Need exponent, but remove superfluous characters }\n    { Delete trailing zeros }\n    while Result[PE-1] = '0' do\n      begin\n      System.Delete(Result,PE-1,1);\n      Dec(PE);\n      end;\n    { If number ends in decimal point, remove it }\n    if Result[PE-1] = DS then\n      begin\n      System.Delete(Result,PE-1,1);\n      Dec(PE);\n      end;\n    { delete superfluous + in exponent }\n    if Result[PE+1]='+' then\n      System.Delete(Result,PE+1,1)\n    else\n      Inc(PE);\n    while Result[PE+1] = '0' do\n      { Delete leading zeros in exponent }\n      System.Delete(Result,PE+1,1)\n    end;\n  Result:=ReplaceDecimalSep(Result,DS)\nend;\n\nfunction FormatExponentFloat(Value : double; Precision,Digits : Integer;DS : String) : string;\n\nVar\n  P: Integer;\nBegin\n  DS:=DecimalSeparator;\n  If (Precision = -1) Or (Precision > maxdigits) Then\n    Precision := maxdigits;\n  Str(Value:Precision+7, Result);\n  { Delete leading spaces }\n  while Result[1] = ' ' do\n    System.Delete(Result, 1, 1);\n  P:=Pos('E',Result);\n  if P=0 then\n    begin\n    Result:=ReplaceDecimalSep(Result,DS);\n    exit;\n    end;\n  Inc(P, 2);\n  if Digits > 4 then\n    Digits:=4;\n  Digits:=Length(Result) - P - Digits + 1;\n  if Digits < 0 then\n    insert(copy('0000',1,-Digits),Result,P)\n  else\n    while (Digits > 0) and (Result[P] = '0') do\n      begin\n      System.Delete(Result, P, 1);\n      if P > Length(Result) then\n        begin\n        System.Delete(Result, P - 2, 2);\n        break;\n        end;\n      Dec(Digits);\n      end;\n  Result:=ReplaceDecimalSep(Result,DS);\nEnd;\n\nfunction FormatFixedFloat(Value : double; Digits : Integer; DS : String) : string;\n\nBegin\n  If Digits = -1 Then\n    Digits := 2\n  Else If Digits > 18 Then\n    Digits := 18;\n  Str(Value:0:Digits, Result);\n  if (Result<>'') and (Result[1]=' ') then\n    Delete(Result,1,1);\n  Result:=ReplaceDecimalSep(Result,DS);\nend;\n\n\nfunction FormatNumberFloat(Value : double; Digits : Integer; DS,TS : String) : string;\n\nVar\n  P : integer;\n\nBegin\n  If Digits = -1 Then\n    Digits := 2\n  else If Digits > maxdigits Then\n    Digits := maxdigits;\n  Str(Value:0:Digits, Result);\n  if (Result<>'') and (Result[1]=' ') then\n    Delete(Result,1,1);\n  P:=Pos('.',Result);\n  Result:=ReplaceDecimalSep(Result,DS);\n  Dec(P,3);\n  if (TS<>'') and (TS<>#0) then\n    While (P>1) Do\n      Begin\n      If (Result[P-1] <> '-')  Then\n        Insert(TS, Result, P);\n      Dec(P, 3);\n      End;\nEnd;\n\nfunction RemoveLeadingNegativeSign(var AValue: String; DS : String): Boolean;\n\n// removes negative sign in case when result is zero eg. -0.00\n\nvar\n  i: PtrInt;\n  TS: String;\n  StartPos: PtrInt;\n\nbegin\n  Result:=False;\n  StartPos := 2;\n  TS := ThousandSeparator;\n  for i :=StartPos to length(AValue) do\n    begin\n    Result := (AValue[i] in ['0', DS, 'E', '+']) or (aValue[i]=TS);\n    if not Result then\n      break;\n    end;\n  if (Result) and (AValue[1]='-') then\n    Delete(AValue, 1, 1);\nend;\n\nFunction FormatNumberCurrency(const Value : Currency; Digits : Integer; DS,TS : String) : string;\n\nVar\n  Negative: Boolean;\n  P : Integer;\n\nBegin\n  //  Writeln('Value ',D);\n   If Digits = -1 Then\n     Digits := CurrencyDecimals\n   Else If Digits > 18 Then\n     Digits := 18;\n   Str(Value:0:Digits, Result);\n   // Writeln('1. Result ',Result,' currencystring : ',CurrencyString);\n   Negative:=Result[1] = '-';\n   if Negative then\n     System.Delete(Result, 1, 1);\n   P := Pos('.', Result);\n   // Writeln('2. Result ',Result,' currencystring : ',CurrencyString);\n   If TS<>'' Then\n     begin\n     If P <> 0 Then\n       Result:=ReplaceDecimalSep(Result,DS)\n     else\n       P := Length(Result)+1;\n     Dec(P, 3);\n     While (P > 1) Do\n     Begin\n         Insert(TS, Result, P);\n     Dec(P, 3);\n     End;\n     end;\n   // Writeln('3. Result ',Result,' currencystring : ',CurrencyString);\n   if Negative then\n     RemoveLeadingNegativeSign(Result,DS);\n   // Writeln('4. Result ',Result,' currencystring : ',CurrencyString);\n   // Writeln('CurrencyFormat:  ',CurrencyFormat,'NegcurrencyFormat: ',NegCurrFormat);\n   If Not Negative Then\n     Case CurrencyFormat Of\n       0: Result := CurrencyString + Result;\n       1: Result := Result + CurrencyString;\n       2: Result := CurrencyString + ' ' + Result;\n       3: Result := Result + ' ' + CurrencyString;\n     end\n   else\n     Case NegCurrFormat Of\n       0: Result := '(' + CurrencyString + Result + ')';\n       1: Result := '-' + CurrencyString + Result;\n       2: Result := CurrencyString + '-' + Result;\n       3: Result := CurrencyString + Result + '-';\n       4: Result := '(' + Result + CurrencyString + ')';\n       5: Result := '-' + Result + CurrencyString;\n       6: Result := Result + '-' + CurrencyString;\n       7: Result := Result + CurrencyString + '-';\n       8: Result := '-' + Result + ' ' + CurrencyString;\n       9: Result := '-' + CurrencyString + ' ' + Result;\n       10: Result := Result + ' ' + CurrencyString + '-';\n       11: Result := CurrencyString + ' ' + Result + '-';\n       12: Result := CurrencyString + ' ' + '-' + Result;\n       13: Result := Result + '-' + ' ' + CurrencyString;\n       14: Result := '(' + CurrencyString + ' ' + Result + ')';\n       15: Result := '(' + Result + ' ' + CurrencyString + ')';\n     end;\nend;\n\nfunction FloatToStrF(const Value: double; format: TFloatFormat; Precision,\n  Digits: Integer): String;\n\nVar\n  DS: string;\n\nBegin\n  DS:=DecimalSeparator;\n  Case format Of\n    ffGeneral:\n      Result:=FormatGeneralFloat(Value,Precision,DS);\n    ffExponent:\n      Result:=FormatExponentFloat(Value,Precision,Digits,DS);\n    ffFixed:\n      Result:=FormatFixedFloat(Value,Digits,DS);\n    ffNumber:\n      Result:=FormatNumberFloat(Value,Digits,DS,ThousandSeparator);\n    ffCurrency:\n     Result:=FormatNumberCurrency(Value,Digits,DS,ThousandSeparator);\n  end;\n  if (Format<>ffCurrency) and (length(Result)>1) and (Result[1]='-') then\n    RemoveLeadingNegativeSign(Result,DS);\nend;\n\nfunction Format(const Fmt: String; const Args: array of JSValue): String;\n\nVar ChPos,OldPos,ArgPos,DoArg,Len : SizeInt;\n    Hs,ToAdd : String;\n    Index : SizeInt;\n    Width,Prec : Longint;\n    Left : Boolean;\n    Fchar : char;\n    vq : nativeint;\n\n  {\n    ReadFormat reads the format string. It returns the type character in\n    uppercase, and sets index, Width, Prec to their correct values,\n    or -1 if not set. It sets Left to true if left alignment was requested.\n    In case of an error, DoFormatError is called.\n  }\n\n  Function ReadFormat : Char;\n\n  Var Value : NativeInt;\n\n    Procedure ReadInteger;\n\n    var\n      Code: integer;\n      ArgN: SizeInt;\n    begin\n      If Value<>-1 then exit; // Was already read.\n      OldPos:=ChPos;\n      While (ChPos<=Len) and\n            (Fmt[ChPos]<='9') and (Fmt[ChPos]>='0') do inc(ChPos);\n      If ChPos>len then\n        DoFormatError(feInvalidFormat,Fmt);\n      If Fmt[ChPos]='*' then\n        begin\n\n        if Index=-1 then\n          ArgN:=Argpos\n        else\n        begin\n          ArgN:=Index;\n          Inc(Index);\n        end;\n\n        If (ChPos>OldPos) or (ArgN>High(Args)) then\n          DoFormatError(feInvalidFormat,Fmt);\n\n        ArgPos:=ArgN+1;\n\n        if IsNumber(Args[ArgN]) and IsInteger(Args[ArgN]) then\n          Value:=Integer(Args[ArgN])\n        else\n          DoFormatError(feInvalidFormat,Fmt);\n        Inc(ChPos);\n        end\n      else\n        begin\n        If (OldPos<ChPos) Then\n          begin\n          Val (Copy(Fmt,OldPos,ChPos-OldPos),value,code);\n          // This should never happen !!\n          If Code>0 then DoFormatError (feInvalidFormat,Fmt);\n          end\n        else\n          Value:=-1;\n        end;\n    end;\n\n    Procedure ReadIndex;\n\n    begin\n      If Fmt[ChPos]<>':' then\n        ReadInteger\n      else\n        value:=0; // Delphi undocumented behaviour, assume 0, #11099\n      If Fmt[ChPos]=':' then\n        begin\n        If Value=-1 then DoFormatError(feMissingArgument,Fmt);\n        Index:=Value;\n        Value:=-1;\n        Inc(ChPos);\n        end;\n    end;\n\n    Procedure ReadLeft;\n\n    begin\n      If Fmt[ChPos]='-' then\n        begin\n        left:=True;\n        Inc(ChPos);\n        end\n      else\n        Left:=False;\n    end;\n\n    Procedure ReadWidth;\n\n    begin\n      ReadInteger;\n      If Value<>-1 then\n        begin\n        Width:=Value;\n        Value:=-1;\n        end;\n    end;\n\n    Procedure ReadPrec;\n\n    begin\n      If Fmt[ChPos]='.' then\n        begin\n        inc(ChPos);\n          ReadInteger;\n        If Value=-1 then\n         Value:=0;\n        prec:=Value;\n        end;\n    end;\n\n\n  begin\n    Index:=-1;\n    Width:=-1;\n    Prec:=-1;\n    Value:=-1;\n    inc(ChPos);\n    If Fmt[ChPos]='%' then\n      begin\n      Result:='%';\n      exit;                           // VP fix\n      end;\n    ReadIndex;\n    ReadLeft;\n    ReadWidth;\n    ReadPrec;\n    Result:=Upcase(Fmt[ChPos]);\n  end;\n\n\n  function Checkarg (AT : TJSValueType; err:boolean):boolean;\n  {\n    Check if argument INDEX is of correct type (AT)\n    If Index=-1, ArgPos is used, and argpos is augmented with 1\n    DoArg is set to the argument that must be used.\n  }\n  begin\n    result:=false;\n    if Index=-1 then\n      DoArg:=Argpos\n    else\n      DoArg:=Index;\n    ArgPos:=DoArg+1;\n    If (Doarg>High(Args)) or (GetValueTYpe(Args[Doarg])<>AT) then\n     begin\n       if err then\n        DoFormatError(feInvalidArgindex,Fmt);\n       dec(ArgPos);\n       exit;\n     end;\n    result:=true;\n  end;\n\nbegin\n  Result:='';\n  Len:=Length(Fmt);\n  ChPos:=1;\n  OldPos:=1;\n  ArgPos:=0;\n  While ChPos<=len do\n    begin\n    While (ChPos<=Len) and (Fmt[ChPos]<>'%') do\n      inc(ChPos);\n    If ChPos>OldPos Then\n      Result:=Result+Copy(Fmt,OldPos,ChPos-Oldpos);\n    If ChPos<Len then\n      begin\n      FChar:=ReadFormat;\n{$ifdef fmtdebug}\n      DumpFormat(FCHar);\n{$endif}\n      Case FChar of\n        'D' : begin\n              Checkarg(jvtinteger,true);\n              toAdd:=IntToStr(NativeInt(Args[DoArg]));\n              Width:=Abs(width);\n              Index:=Prec-Length(ToAdd);\n              If ToAdd[1]<>'-' then\n                ToAdd:=StringOfChar('0',Index)+ToAdd\n              else\n                // + 1 to accomodate for - sign in length !!\n                Insert(StringOfChar('0',Index+1),toadd,2);\n              end;\n        'U' : begin\n              Checkarg(jvtinteger,True);\n              if NativeInt(Args[Doarg])<0 then\n                DoFormatError(feInvalidArgindex,Fmt);\n              Toadd:=IntToStr(NativeInt(Args[Doarg]));\n              Width:=Abs(width);\n              Index:=Prec-Length(ToAdd);\n              ToAdd:=StringOfChar('0',Index)+ToAdd\n              end;\n        'E' : begin\n              if CheckArg(jvtFloat,false) or CheckArg(jvtInteger,True) then\n                ToAdd:=FloatToStrF(Double(Args[doarg]),ffFixed,9999,Prec);\n              end;\n        'F' : begin\n              if CheckArg(jvtFloat,false) or CheckArg(jvtInteger,True) then\n                ToAdd:=FloatToStrF(Double(Args[doarg]),ffFixed,9999,Prec);\n              end;\n        'G' : begin\n              if CheckArg(jvtFloat,false) or CheckArg(jvtInteger,True) then\n                ToAdd:=FloatToStrF(Double(Args[doarg]),ffGeneral,Prec,3);\n              end;\n        'N' : begin\n              if CheckArg(jvtFloat,false) or CheckArg(jvtInteger,True) then\n                ToAdd:=FloatToStrF(Double(Args[doarg]),ffNumber,9999,Prec);\n              end;\n        'M' : begin\n              if CheckArg(jvtFloat,false) or CheckArg(jvtInteger,True) then\n                ToAdd:=FloatToStrF(Double(Args[doarg]),ffCurrency,9999,Prec);\n              end;\n        'S' : begin\n              CheckArg(jvtString,true);\n              hs:=String(Args[doarg]);\n              Index:=Length(hs);\n              If (Prec<>-1) and (Index>Prec) then\n                Index:=Prec;\n              ToAdd:=Copy(hs,1,Index);\n              end;\n        'P' : Begin\n              CheckArg(jvtInteger,true);\n              ToAdd:=IntToHex(NativeInt(Args[DoArg]),31);\n              end;\n        'X' : begin\n              Checkarg(jvtinteger,true);\n              vq:=nativeInt(Args[Doarg]);\n              index:=31; // May need to adjust to NativeInt\n              If Prec>index then\n                ToAdd:=IntToHex(vq,index)\n              else\n                begin\n                // determine minimum needed number of hex digits.\n                Index:=1;\n                While (NativeInt(1) shl (Index*4)<=vq) and (index<16) do\n                  inc(Index);\n                If Index>Prec then\n                  Prec:=Index;\n                ToAdd:=IntToHex(vq,Prec);\n                end;\n              end;\n        '%': ToAdd:='%';\n      end;\n      If Width<>-1 then\n        If Length(ToAdd)<Width then\n          If not Left then\n            ToAdd:=StringOfChar(' ',Width-Length(ToAdd))+ToAdd\n          else\n            ToAdd:=ToAdd+StringOfChar(' ',Width-Length(ToAdd));\n      Result:=Result+ToAdd;\n      end;\n    inc(ChPos);\n    Oldpos:=ChPos;\n    end;\nend;\n\nfunction BytesOf(const AVal: string): TBytes;\nvar\n  I: SizeUInt;\nbegin\n  SetLength(Result, Length(AVal));\n  for I := 0 to Length(AVal)-1 do\n    Result[I] := Ord(AVal[I+1]);\nend;\n\nfunction StringOf(const ABytes: TBytes): string;\nvar\n  I: Integer;\nbegin\n  Result:='';\n  for I := 0 to Length(ABytes)-1 do\n    Result:=Result+Char(ABytes[I]);\nend;\n\nfunction LocaleCompare(const s1, s2, locales: String): Boolean; assembler;\nasm\n  return s1.localeCompare(s2,locales) == 0;\nend;\n\nfunction NormalizeStr(const S: String; const Norm: String): String; assembler;\nasm\n  return S.normalize(Norm);\nend;\n\nfunction IsValidIdent(const Ident: string; AllowDots: Boolean = False; StrictDots: Boolean = False): Boolean;\nconst\n  Alpha = ['A'..'Z', 'a'..'z', '_'];\n  AlphaNum = Alpha + ['0'..'9'];\n  Dot = '.';\nvar\n  First: Boolean;\n  I, Len: Integer;\nbegin\n  Len := Length(Ident);\n  if Len < 1 then\n    Exit(False);\n  First := True;\n  Result:=false;\n  I:=1;\n  While I<=len do\n    begin\n    if First then\n    begin\n      if not (Ident[I] in Alpha) then exit;\n      First := False;\n    end\n    else if AllowDots and (Ident[I] = Dot) then\n    begin\n      if StrictDots then\n      begin\n        if I >= Len then exit;\n        First := True;\n      end;\n    end\n    else\n      if not (Ident[I] in AlphaNum) then exit;\n    I:=I+1;\n    end;\n  Result:=true;\nend;\n\nprocedure FreeAndNil(var Obj);\nvar\n  o: TObject;\nbegin\n  o:=TObject(Obj);\n  if o=nil then exit;\n  TObject(Obj):=nil;\n  o.Destroy;\nend;\n\n{ EVariantError }\n\nconstructor EVariantError.CreateCode(Code: Longint);\nbegin\n  ErrCode:=Code;\nend;\n\n{ Exception }\n\nconstructor Exception.Create(const Msg: String);\nbegin\n  fMessage:=Msg;\n  {$ifdef nodejs}\n  FNodeJSError:=TJSError.new;\n  {$endif}\nend;\n\nconstructor Exception.CreateFmt(const Msg: string; const Args: array of jsvalue\n  );\nbegin\n  //writeln('Exception.CreateFmt START ',ClassName,' \"',Msg,'\" Args=',Args);\n  Create(Format(Msg,Args));\n  //writeln('Exception.CreateFmt END ',ClassName,' \"',Msg,'\" fMessage=',fMessage);\nend;\n\nconstructor Exception.CreateHelp(const Msg: String; AHelpContext: Integer);\nbegin\n  Create(Msg);\n  fHelpContext:=AHelpContext;\nend;\n\nconstructor Exception.CreateFmtHelp(const Msg: string;\n  const Args: array of jsvalue; AHelpContext: Integer);\nbegin\n  Create(Format(Msg,Args));\n  fHelpContext:=AHelpContext;\nend;\n\nfunction Exception.ToString: String;\nbegin\n  Result:=ClassName+': '+Message;\nend;\n\nConst\n  RESpecials = '([\\+\\[\\]\\(\\)\\\\\\.\\*])';\n\nfunction StringReplace(aOriginal, aSearch, aReplace: string;\n  Flags: TStringReplaceFlags): String;\n\nVar\n  REFlags : String;\n  REString : String;\n\nbegin\n  REFlags:='';\n  if rfReplaceAll in flags then\n    ReFlags:='g';\n  if rfIgnoreCase in flags then\n    ReFlags:=ReFlags+'i';\n  REString:=TJSString(aSearch).replace(TJSRegexp.new(RESpecials,'g'),'\\$1');\n  Result:=TJSString(aOriginal).replace(TJSRegexp.new(REString,REFlags),aReplace);\nend;\n\nfunction QuoteString(aOriginal: String; AQuote: Char): String;\n\nbegin\n  Result:=AQuote+StringReplace(aOriginal,aQuote,aQuote+aQuote,[rfReplaceAll])+AQuote;\nend;\n\nfunction QuotedStr(const s: string; QuoteChar : Char = ''''): string;\n\nbegin\n  Result:=QuoteString(S,QuoteChar);\nend;\n\nfunction DeQuoteString(aQuoted: String; AQuote: Char): String;\nvar\n  i: Integer;\nbegin\n  Result:=aQuoted;\n  if TJSString(Result).substr(0,1)<>AQuote then exit;\n  Result:=TJSString(Result).slice(1);\n  i:=1;\n  while i<=length(Result) do\n    begin\n    if Result[i]=AQuote then\n      begin\n      if (i=length(Result)) or (Result[i+1]<>AQuote) then\n        begin\n        Result:=TJSString(Result).slice(0,i-1);\n        exit;\n        end\n      else\n        Result:=TJSString(Result).slice(0,i-1)+TJSString(Result).slice(i);\n      end\n    else\n      inc(i);\n    end;\nend;\n\nfunction IsDelimiter(const Delimiters, S: string; Index: Integer): Boolean;\nbegin\n  Result:=False;\n  if (Index>0) and (Index<=Length(S)) then\n    Result:=Pos(S[Index],Delimiters)<>0; // Note we don't do MBCS yet\nend;\n\nfunction AdjustLineBreaks(const S: string): string;\n\nbegin\n  Result:=AdjustLineBreaks(S,DefaultTextLineBreakStyle);\nend;\n\nfunction AdjustLineBreaks(const S: string; Style: TTextLineBreakStyle): string;\n\nvar\n  I,L: Longint;\n  Res : String;\n\n  Procedure Add(C  : Char);\n  begin\n    Res:=Res+C;\n  end;\n\nbegin\n  I:=0;\n  L:=Length(S);\n  Result:='';\n  While (I<=L) do\n    case S[I] of\n      #10: begin\n          if Style in [tlbsCRLF,tlbsCR] then\n            Add(#13);\n          if Style=tlbsCRLF then\n            Add(#10);\n          Inc(I);\n          end;\n     #13: begin\n          if Style=tlbsCRLF then\n            Add(#13);\n          Add(#10);\n          Inc(I);\n          if S[I]=#10 then\n            Inc(I);\n          end;\n    else\n      Add(S[i]);\n      Inc(I);\n    end;\n  Result:=Res;\nend;\n\nfunction WrapText(const Line, BreakStr: string;\n  const BreakChars: array of char; MaxCol: Integer): string;\n\nconst\n  Quotes = ['''', '\"'];\n\nVar\n  L : String;\n  C,LQ,BC : Char;\n  P,BLen,Len : Integer;\n  HB,IBC : Boolean;\n\nbegin\n  Result:='';\n  L:=Line;\n  Blen:=Length(BreakStr);\n  If (BLen>0) then\n    BC:=BreakStr[1]\n  else\n    BC:=#0;\n  Len:=Length(L);\n  While (Len>0) do\n    begin\n    P:=1;\n    LQ:=#0;\n    HB:=False;\n    IBC:=False;\n    While ((P<=Len) and ((P<=MaxCol) or not IBC)) and ((LQ<>#0) or Not HB) do\n      begin\n      C:=L[P];\n      If (C=LQ) then\n        LQ:=#0\n      else If (C in Quotes) then\n        LQ:=C;\n      If (LQ<>#0) then\n        Inc(P)\n      else\n        begin\n        HB:=((C=BC) and (BreakStr=Copy(L,P,BLen)));\n        If HB then\n          Inc(P,Blen)\n        else\n          begin\n          If (P>=MaxCol) then\n            IBC:=CharInSet(C,BreakChars);\n          Inc(P);\n          end;\n        end;\n//      Writeln('\"',C,'\" : IBC : ',IBC,' HB  : ',HB,' LQ  : ',LQ,' P>MaxCol : ',P>MaxCol);\n      end;\n    Result:=Result+Copy(L,1,P-1);\n    Delete(L,1,P-1);\n    Len:=Length(L);\n    If (Len>0) and Not HB then\n      Result:=Result+BreakStr;\n    end;\nend;\n\nfunction WrapText(const Line: string; MaxCol: Integer): string;\n\nbegin\n  Result:=WrapText(Line,sLineBreak, [' ', '-', #9], MaxCol);\nend;\n\n\nfunction GetEnvironmentVariable(const EnvVar: String): String;\nbegin\n  if Assigned(OnGetEnvironmentVariable) then\n    Result:=OnGetEnvironmentVariable(EnvVar)\n  else\n    Result:='';\nend;\n\nfunction GetEnvironmentVariableCount: Integer;\nbegin\n  if Assigned(OnGetEnvironmentVariableCount) then\n    Result:=OnGetEnvironmentVariableCount()\n  else\n    Result:=0;\nend;\n\nfunction GetEnvironmentString(Index: Integer): String;\nbegin\n  if Assigned(OnGetEnvironmentString) then\n    Result:=OnGetEnvironmentString(Index)\n  else\n    Result:='';\nend;\n\n{ Date/Time routines}\n\nFunction DoEncodeDate(Year, Month, Day: Word): longint;\n\nVar\n  D : TDateTime;\n\nbegin\n  If TryEncodeDate(Year,Month,Day,D) then\n    Result:=Trunc(D)\n  else\n    Result:=0;\nend;\n\nfunction DoEncodeTime(Hour, Minute, Second, MilliSecond: word): TDateTime;\n\nbegin\n  If not TryEncodeTime(Hour,Minute,Second,MilliSecond,Result) then\n    Result:=0;\nend;\n\nfunction DateTimeToJSDate(aDateTime: TDateTime): TJSDate;\n\nVar\n  Y,M,D,h,n,s,z : Word;\n\nbegin\n  DecodeDate(Trunc(aDateTime),Y,M,D);\n  DecodeTime(Frac(aDateTime),H,N,S,Z);\n  Result:=TJSDate.New(Y,M,D,h,n,s,z);\nend;\n\nfunction JSDateToDateTime(aDate: TJSDate): TDateTime;\n\nbegin\n  Result:=EncodeDate(ADate.FullYear,ADate.Month+1,ADate.Date) +\n          EncodeTime(ADate.Hours,ADate.Minutes,ADate.Seconds,ADate.Milliseconds);\nend;\n\n\n{   ComposeDateTime converts a Date and a Time into one TDateTime   }\nfunction ComposeDateTime(Date,Time : TDateTime) : TDateTime;\n\nbegin\n  if Date < 0 then\n    Result := trunc(Date) - Abs(frac(Time))\n  else\n    Result := trunc(Date) + Abs(frac(Time));\nend;\n\nfunction TryEncodeDate(Year, Month, Day: Word; out Date: TDateTime): Boolean;\n\nvar\n  c, ya: LongWord;\nbegin\n  Result:=(Year>0) and (Year<10000) and\n          (Month >= 1) and (Month<=12) and\n          (Day>0) and (Day<=MonthDays[IsleapYear(Year),Month]);\n If Result then\n   begin\n     if month > 2 then\n      Dec(Month,3)\n     else\n      begin\n        Inc(Month,9);\n        Dec(Year);\n      end;\n     c:= Year DIV 100;\n     ya:= Year - 100*c;\n     Date := (146097*c) SHR 2 + (1461*ya) SHR 2 + (153*LongWord(Month)+2) DIV 5 + LongWord(Day);\n     // Note that this line can't be part of the line above, since TDateTime is\n     // signed and c and ya are not\n     Date := Date - 693900;\n   end\nend;\n\nfunction TryEncodeTime(Hour, Min, Sec, MSec: Word; out Time: TDateTime\n  ): Boolean;\n\nbegin\n  Result:=(Hour<24) and (Min<60) and (Sec<60) and (MSec<1000);\n  If Result then\n    Time:=TDateTime(LongWord(Hour)*3600000+LongWord(Min)*60000+LongWord(Sec)*1000+MSec)/MSecsPerDay;\nend;\n\n{   EncodeDate packs three variables Year, Month and Day into a\n    TDateTime value the result is the number of days since 12/30/1899   }\n\nfunction EncodeDate(Year, Month, Day: word): TDateTime;\n\nbegin\n  If Not TryEncodeDate(Year,Month,Day,Result) then\n    Raise EConvertError.CreateFmt('%s-%s-%s is not a valid date specification',\n                              [IntToStr(Year),IntToStr(Month),IntToStr(Day)]);\nend;\n\n{   EncodeTime packs four variables Hour, Minute, Second and MilliSecond into\n    a TDateTime value     }\n\nfunction EncodeTime(Hour, Minute, Second, MilliSecond:word):TDateTime;\n\nbegin\n  If not TryEncodeTime(Hour,Minute,Second,MilliSecond,Result) then\n    Raise EConvertError.CreateFmt('%s:%s:%s.%s is not a valid time specification',\n                              [IntToStr(Hour),IntToStr(Minute),IntToStr(Second),IntToStr(MilliSecond)]);\nend;\n\n\n{   DecodeDate unpacks the value Date into three values:\n    Year, Month and Day   }\n\nprocedure DecodeDate(Date: TDateTime; out Year, Month, Day: word);\nvar\n  ly,ld,lm,j : LongWord;\nbegin\n  if Date <= -datedelta then  // If Date is before 1-1-1 then return 0-0-0\n    begin\n    Year := 0;\n    Month := 0;\n    Day := 0;\n    end\n  else\n    begin\n    if Date>0 then\n      Date:=(Date+(1/(msecsperday*2)))\n    else\n      Date:=Date-(1/(msecsperday*2));\n    if Date>MaxDateTime then\n      Date:=MaxDateTime;\n//       Raise EConvertError.CreateFmt('%f is not a valid TDatetime encoding, maximum value is %f.',[Date,MaxDateTime]);\n    j := ((Trunc(Date) + 693900) SHL 2)-1;\n    ly:= j DIV 146097;\n    j:= j - 146097 * LongWord(ly);\n    ld := j SHR 2;\n    j:=(ld SHL 2 + 3) DIV 1461;\n    ld:= ((ld SHL 2) + 7 - 1461*j) SHR 2;\n    lm:=(5 * ld-3) DIV 153;\n    ld:= (5 * ld +2 - 153*lm) DIV 5;\n    ly:= 100 * LongWord(ly) + j;\n    if lm < 10 then\n     inc(lm,3)\n    else\n      begin\n        dec(lm,9);\n        inc(ly);\n      end;\n    year:=ly;\n    month:=lm;\n    day:=ld;\n    end;\nend;\n\n\nfunction DecodeDateFully(const DateTime: TDateTime; out Year, Month, Day, DOW: Word): Boolean;\nbegin\n  DecodeDate(DateTime,Year,Month,Day);\n  DOW:=DayOfWeek(DateTime);\n  Result:=IsLeapYear(Year);\nend;\n  {   DateTimeToTimeStamp converts DateTime to a TTimeStamp   }\n\nfunction DateTimeToTimeStamp(DateTime: TDateTime): TTimeStamp;\n\nVar\n  D : Double;\nbegin\n  D:=DateTime * Double(MSecsPerDay);\n  if D<0 then\n    D:=D-0.5\n  else\n    D:=D+0.5;\n  result.Time := Trunc(Abs(Trunc(D)) Mod MSecsPerDay);\n  result.Date := DateDelta + (Trunc(D) div MSecsPerDay);\nend;\n\n{   TimeStampToDateTime converts TimeStamp to a TDateTime value   }\n\nfunction TimeStampToDateTime(const TimeStamp: TTimeStamp): TDateTime;\nbegin\n  Result := ComposeDateTime(TimeStamp.Date - DateDelta,TimeStamp.Time/MSecsPerDay)\nend;\n\n{   MSecsToTimeStamp   }\n\nfunction MSecsToTimeStamp(MSecs: NativeInt): TTimeStamp;\nbegin\n  result.Date := Trunc(msecs/msecsperday);\n  msecs:= msecs-NativeInt(result.date)*msecsperday;\n  result.Time := Round(MSecs);\nend;\n\nfunction TimeStampToMSecs(const TimeStamp: TTimeStamp): NativeInt;\nbegin\n  result := TimeStamp.Time + (timestamp.date*msecsperday);\nend ;\n\n\n\n{   DecodeTime unpacks Time into four values:\n    Hour, Minute, Second and MilliSecond    }\n\nprocedure DecodeTime(Time: TDateTime; out Hour, Minute, Second, MilliSecond: word);\nVar\n  l : LongWord;\nbegin\n  l := DateTimeToTimeStamp(Time).Time;\n  Hour   := l div 3600000;\n  l := l mod 3600000;\n  Minute := l div 60000;\n  l := l mod 60000;\n  Second := l div 1000;\n  l := l mod 1000;\n  MilliSecond := l;\nend;\n\n{   DateTimeToSystemTime converts DateTime value to SystemTime   }\n\nprocedure DateTimeToSystemTime(DateTime: TDateTime; out SystemTime: TSystemTime);\nbegin\n  DecodeDateFully(DateTime, SystemTime.Year, SystemTime.Month, SystemTime.Day,SystemTime.DayOfWeek);\n  DecodeTime(DateTime, SystemTime.Hour, SystemTime.Minute, SystemTime.Second, SystemTime.MilliSecond);\n  Dec(SystemTime.DayOfWeek);\nend ;\n\n{   SystemTimeToDateTime converts SystemTime to a TDateTime value   }\n\nfunction SystemTimeToDateTime(const SystemTime: TSystemTime): TDateTime;\nbegin\n  result := ComposeDateTime(DoEncodeDate(SystemTime.Year, SystemTime.Month, SystemTime.Day),\n                            DoEncodeTime(SystemTime.Hour, SystemTime.Minute, SystemTime.Second, SystemTime.MilliSecond));\nend ;\n\nfunction DayOfWeek(DateTime: TDateTime): integer;\nbegin\n  Result := 1 + ((Trunc(DateTime) - 1) mod 7);\n  If (Result<=0) then\n    Inc(Result,7);\nend;\n\n\n\nfunction Now: TDateTime;\nbegin\n  Result:=JSDateToDateTime(TJSDate.New());\nend;\n\nfunction Date: TDateTime;\n\nbegin\n  Result:=Trunc(Now);\nend;\n\nfunction Time: TDateTime;\nbegin\n  Result:=Now-Date;\nend ;\n\n{   IncMonth increments DateTime with NumberOfMonths months,\n    NumberOfMonths can be less than zero   }\n\nfunction IncMonth(const DateTime: TDateTime; NumberOfMonths: integer = 1 ): TDateTime;\nvar\n  Year, Month, Day : word;\nbegin\n  DecodeDate(DateTime, Year, Month, Day);\n  IncAMonth(Year, Month, Day, NumberOfMonths);\n  result := ComposeDateTime(DoEncodeDate(Year, Month, Day), DateTime);\nend ;\n\n{   IncAMonth is the same as IncMonth, but operates on decoded date  }\n\nprocedure IncAMonth(var Year, Month, Day: Word; NumberOfMonths: Integer = 1);\nvar\n  TempMonth, S: Integer;\nbegin\n  If NumberOfMonths>=0 then\n    s:=1\n  else\n    s:=-1;\n  inc(Year,(NumberOfMonths div 12));\n  TempMonth:=Month+(NumberOfMonths mod 12)-1;\n  if (TempMonth>11) or\n     (TempMonth<0) then\n   begin\n     Dec(TempMonth, S*12);\n     Inc(Year, S);\n   end;\n  Month:=TempMonth+1;          {   Months from 1 to 12   }\n  If (Day>MonthDays[IsLeapYear(Year)][Month]) then\n    Day:=MonthDays[IsLeapYear(Year)][Month];\nend;\n\n{  IsLeapYear returns true if Year is a leap year   }\n\nfunction IsLeapYear(Year: Word): boolean;\nbegin\n  Result := (Year mod 4 = 0) and ((Year mod 100 <> 0) or (Year mod 400 = 0));\nend;\n\n{  DateToStr returns a string representation of Date using ShortDateFormat   }\n\nfunction DateToStr(Date: TDateTime): string;\nbegin\n  Result:=FormatDateTime('ddddd', Date);\nend ;\n\n{  TimeToStr returns a string representation of Time using LongTimeFormat   }\n\nfunction TimeToStr(Time: TDateTime): string;\nbegin\n  Result:=FormatDateTime('tt',Time);\nend ;\n\n{   DateTimeToStr returns a string representation of DateTime using LongDateTimeFormat   }\n\nVar\n  DateTimeToStrFormat : Array[Boolean] of string = ('c','f');\n\nfunction DateTimeToStr(DateTime: TDateTime; ForceTimeIfZero : Boolean = False): string;\nbegin\n  Result:=FormatDateTime(DateTimeToStrFormat[ForceTimeIfZero], DateTime)\nend ;\n\n\n{   StrToDate converts the string S to a TDateTime value\n    if S does not represent a valid date value\n    an EConvertError will be raised   }\n\nfunction IntStrToDate(Out ErrorMsg : String; const S: String; const useformat : string; separator : char): TDateTime;\n\nConst\n  WhiteSpace = ' '#8#9#10#12#13;\n  Digits = '0123456789';\n\n  procedure FixErrorMsg(const errmarg : String);\n\n  begin\n    ErrorMsg:=Format(SInvalidDateFormat,[errmarg]);\n  end;\n\nvar\n   df:string;\n   d,m,y,ly,ld,lm:word;\n   n,i,len:longint;\n   c: integer;\n   dp,mp,yp,which : Byte;\n   s1:string;\n   values: array of integer;\n   YearMoreThenTwoDigits : boolean;\n\nbegin\n  SetLength(values,4);\n  Result:=0;\n  Len:=Length(S);\n  ErrorMsg:='';\n  While (Len>0) and (Pos(S[Len],WhiteSpace)>0) do\n    Dec(len);\n  if (Len=0) then\n    begin\n    FixErrorMsg(S);\n    exit;\n    end;\n  YearMoreThenTwoDigits := False;\n  if separator = #0 then\n    if (DateSeparator<>#0) then\n      separator := DateSeparator\n    else\n      separator:='-';\n  // Writeln('Separator: ',Separator);\n  df := UpperCase(useFormat);\n  { Determine order of D,M,Y }\n  yp:=0;\n  mp:=0;\n  dp:=0;\n  Which:=0;\n  i:=0;\n  while (i<Length(df)) and (Which<3) do\n   begin\n     inc(i);\n     Case df[i] of\n       'Y' :\n         if yp=0 then\n          begin\n            Inc(Which);\n            yp:=which;\n          end;\n       'M' :\n         if mp=0 then\n          begin\n            Inc(Which);\n            mp:=which;\n          end;\n       'D' :\n         if dp=0 then\n          begin\n            Inc(Which);\n            dp:=which;\n          end;\n     end;\n   end;\n  // Writeln('YP: ',Yp,', MP: ',Mp,', DP: ',DP);\n  for i := 1 to 3 do\n    values[i] := 0;\n  s1 := '';\n  n := 0;\n  for i := 1 to len do\n     begin\n     if Pos(s[i],Digits)>0 then\n       s1 := s1 + s[i];\n     { space can be part of the shortdateformat, and is defaultly in slovak\n       windows, therefor it shouldn't be taken as separator (unless so specified)\n       and ignored }\n     if (Separator <> ' ') and (s[i] = ' ') then\n       Continue;\n     if (s[i] = separator) or ((i = len) and (Pos(s[i],Digits)>0)) then\n      begin\n        inc(n);\n        if n>3 then\n          begin\n//            Writeln('More than 3 separators');\n            FixErrorMsg(S);\n            exit;\n          end;\n         // Check if the year has more then two digits (if n=yp, then we are evaluating the year.)\n        if (n=yp) and (length(s1)>2) then YearMoreThenTwoDigits := True;\n        val(s1, values[n], c);\n        if c<>0 then\n          begin\n//            Writeln('S1 not a number ',S1);\n            FixErrorMsg(s);\n            Exit;\n          end;\n        s1 := '';\n      end\n     else if (Pos(s[i],Digits)=0) then\n       begin\n//       Writeln('Not a number at pos ',I,' ',S[i]);\n       FixErrorMsg(s);\n       Exit;\n       end;\n   end ;\n//   Writeln('Which : ',Which,' N : ',N);\n   if (Which<3) and (N>Which) then\n    begin\n    FixErrorMsg(s);\n    Exit;\n    end;\n  // Fill in values.\n  DecodeDate(Date,Ly,LM,LD);\n  If N=3 then\n   begin\n     y:=values[yp];\n     m:=values[mp];\n     d:=values[dp];\n   end\n  Else\n  begin\n    Y:=ly;\n    If n<2 then\n     begin\n       d:=values[1];\n       m := LM;\n     end\n    else\n     If dp<mp then\n      begin\n        d:=values[1];\n        m:=values[2];\n      end\n    else\n      begin\n        d:=values[2];\n        m:=values[1];\n      end;\n  end;\n  if (y >= 0) and (y < 100) and not YearMoreThenTwoDigits then\n    begin\n    ly := ly - TwoDigitYearCenturyWindow;\n    Inc(Y, ly div 100 * 100);\n    if (TwoDigitYearCenturyWindow > 0) and (Y < ly) then\n      Inc(Y, 100);\n    end;\n  if not TryEncodeDate(y, m, d, result) then\n    errormsg:=SErrInvalidDate;\nend;\n\nfunction StrToDate(const S: String; const useformat : string; separator : char): TDateTime;\nVar\n  MSg : String;\nbegin\n  Result:=IntStrToDate(Msg,S,useFormat,Separator);\n  If (Msg<>'') then\n    Raise EConvertError.Create(Msg);\nend;\n\nfunction StrToDate(const S: String; separator : char): TDateTime;\nbegin\n    result := StrToDate(S,ShortDateFormat,separator)\nend;\n\nfunction StrToDate(const S: String): TDateTime;\nbegin\n  result := StrToDate(S,ShortDateFormat,#0);\nend;\n\n{   StrToTime converts the string S to a TDateTime value\n    if S does not represent a valid time value an\n    EConvertError will be raised   }\n\n\nfunction IntStrToTime(Out ErrorMsg : String; const S: String; Len : integer; separator : char): TDateTime;\n\nconst\n  AMPM_None = 0;\n  AMPM_AM = 1;\n  AMPM_PM = 2;\n  tiHour = 0;\n  tiMin = 1;\n  tiSec = 2;\n  tiMSec = 3;\n\ntype\n  TTimeValues = array of Word;\n\nvar\n   AmPm: integer;\n   TimeValues: TTimeValues;\n\n\n   function SplitElements(out TimeValues: TTimeValues; out AmPm: Integer): Boolean;\n   //Strict version. It does not allow #32 as Separator, it will treat it as whitespace always\n   const\n     Digits = '0123456789';\n   var\n      Cur, Offset, ElemLen, Err, TimeIndex, FirstSignificantDigit: Integer;\n      Value: Integer;\n      DigitPending, MSecPending: Boolean;\n      AmPmStr: String;\n      CurChar: Char;\n      I : Integer;\n      allowedchars : string;\n\n   begin\n     Result := False;\n     AmPm := AMPM_None; //No Am or PM in string found yet\n     MSecPending := False;\n     TimeIndex := 0; //indicating which TTimeValue must be filled next\n     For I:=tiHour to tiMSec do\n      TimeValues[i]:=0;\n     Cur := 1;\n     //skip leading blanks\n     While (Cur < Len) and (S[Cur] =#32) do Inc(Cur);\n     Offset := Cur;\n     //First non-blank cannot be Separator or DecimalSeparator\n     if (Cur > Len - 1) or (S[Cur] = Separator) or (S[Cur] = Decimalseparator) then\n       begin\n       // Writeln('Error in sep S[Cur]',S[Cur],' ',separator,' ',GetDecimalSeparator);\n       Exit;\n       end;\n     DigitPending := (Pos(S[Cur],Digits)>0);\n     While (Cur <= Len) do\n     begin\n       //writeln;\n       // writeln('Main While loop:  Cur = ',Cur,' S[Cur] = \"',S[Cur],'\" Len = ',Len,' separator : ',Separator);\n       CurChar := S[Cur];\n       if Pos(CurChar,Digits)>0 then\n       begin//Digits\n         //HH, MM, SS, or Msec?\n         // writeln('Digit: ', CurChar);\n         //Digits are only allowed after starting Am/PM or at beginning of string or after Separator\n         //and TimeIndex must be <= tiMSec\n         //Uncomment \"or (#32 = Separator)\" and it will allllow #32 as separator\n         if (not (DigitPending {or (#32 = Separator)})) or (TimeIndex > tiMSec) then\n            begin\n            // Writeln('DigitPending',ElemLen);\n            Exit;\n            end;\n         OffSet := Cur;\n         if (CurChar <> '0') then FirstSignificantDigit := OffSet else FirstSignificantDigit := -1;\n         while (Cur < Len) and (Pos(S[Cur + 1],Digits)>0) do\n         begin\n           //Mark first Digit that is not '0'\n           if (FirstSignificantDigit = -1) and (S[Cur] <> '0') then FirstSignificantDigit := Cur;\n           Inc(Cur);\n         end;\n         if (FirstSignificantDigit = -1) then FirstSignificantDigit := Cur;\n         ElemLen := 1+ Cur - FirstSignificantDigit;\n         // writeln('  S[FirstSignificantDigit] = ',S[FirstSignificantDigit], ' S[Cur] = ',S[Cur],' ElemLen = ',ElemLen,' -> ', S[Offset], ElemLen);\n         // writeln('  Cur = ',Cur);\n         //this way we know that Val() will never overflow Value !\n         if (ElemLen <= 2) or ((ElemLen <= 3) and (TimeIndex = tiMSec) ) then\n         begin\n           Val(Copy(S,FirstSignificantDigit, ElemLen), Value, Err);\n           // writeln('  Value = ',Value,' HH = ',TimeValues[0],' MM = ',TimeValues[1],' SS = ',TimeValues[2],' MSec = ',Timevalues[3]);\n           //This is safe now, because we know Value < High(Word)\n           TimeValues[TimeIndex] := Value;\n           Inc(TimeIndex);\n           DigitPending := False;\n         end\n         else\n           begin\n           // Writeln('Wrong elemlen: ',ElemLen, ' timeIndex: ',timeindex);\n           Exit; //Value to big, so it must be a wrong timestring\n           end;\n       end//Digits\n       else if (CurChar = #32) then\n       begin\n         //writeln('#32');\n         //just skip, but we must adress this, or it will be parsed by either AM/PM or Separator\n       end\n       else if (CurChar = Separator) then\n       begin\n         // writeln('Separator ',Separator);\n         if DigitPending or (TimeIndex > tiSec) then\n           begin\n           // Writeln ('DigitPending ',DigitPending,' or (TimeIndex',Timeindex,' > tiSec,', tiSec,')');\n           Exit;\n           end;\n         DigitPending := True;\n         MSecPending := False;\n       end\n       else if (CurChar = DecimalSeparator) then\n       begin\n         //writeln('DecimalSeparator');\n         if DigitPending or MSecPending or (TimeIndex <> tiMSec) then\n            begin\n            // Writeln('DigitPending ',DigitPending,' or MSecPending ',MSecPending,' (',TimeIndex,',Timeindex, >', tiMSec,'  tiSec)');\n            Exit;\n            end;\n         DigitPending := True;\n         MSecPending := True;\n       end\n       else\n       begin//AM/PM?\n         //None of the above, so this char _must_ be the start of AM/PM string\n         //If we already have found AM/PM or we expect a digit then then timestring must be wrong at this point\n         //writeln('AM/PM?');\n         if (AmPm <> AMPM_None) or DigitPending then\n           begin\n           // Writeln('AmPm <> AMPM_None) or DigitPending');\n           Exit;\n           end;\n         OffSet := Cur;\n         allowedchars:=DecimalSeparator+' ';\n         if Separator<>#0 then\n           allowedchars:=allowedchars+Separator;\n         while (Cur < Len -1) and (Pos(S[Cur + 1],AllowedChars)=0)\n           and (Pos(S[Cur + 1],Digits)=0) do Inc(Cur);\n         ElemLen := 1 + Cur - OffSet;\n         // writeln('  S[Offset] = ',S[1+Offset], ' S[Cur] = ',S[Cur],' ElemLen = ',ElemLen,' -> ', S[1+Offset], ElemLen);\n         // writeln('  Cur = ',Cur, 'S =',S);\n         AmPmStr := Copy(S,1+OffSet, ElemLen);\n\n         // writeln('AmPmStr = ',ampmstr,' (',length(ampmstr),')');\n         //We must compare to TimeAMString before hardcoded 'AM' for delphi compatibility\n         //Also it is perfectly legal, though insane to have TimeAMString = 'PM' and vice versa\n         if (CompareText(AmPmStr, TimeAMString) = 0) then AmPm := AMPM_AM\n         else if (CompareText(AmPmStr, TimePMString) = 0) then AmPm := AMPM_PM\n         else if (CompareText(AmPmStr, 'AM') = 0) then AmPm := AMPM_AM\n         else if (CompareText(AmPmStr, 'PM') = 0) then AmPm := AMPM_PM\n         else\n           begin\n           // Writeln('No timestring ',AmPmStr);\n           Exit; //If text does not match any of these, timestring must be wrong;\n           end;\n         //if AM/PM is at beginning of string, then a digit is mandatory after it\n         if (TimeIndex = tiHour) then\n         begin\n           DigitPending := True;\n         end\n         //otherwise, no more TimeValues allowed after this\n         else\n         begin\n           TimeIndex := tiMSec + 1;\n           DigitPending := False;\n         end;\n       end;//AM/PM\n       Inc(Cur)\n     end;//while\n\n     //If we arrive here, parsing the elements has been successfull\n     //if not at least Hours specified then input is not valid\n     //when am/pm is specified Hour must be <= 12 and not 0\n     if (TimeIndex = tiHour) or ((AmPm <> AMPM_None) and ((TimeValues[tiHour] > 12) or (TimeValues[tiHour] = 0))) or DigitPending then\n       Exit;\n     Result := True;\n   end;\n\nbegin\n  setlength(timevalues,4);\n  if separator = #0 then\n     if (TimeSeparator<>#0) then\n       separator := TimeSeparator\n      else\n       separator:=':';\n  AmPm := AMPM_None;\n  if not SplitElements(TimeValues, AmPm) then\n  begin\n    ErrorMsg:=Format(SErrInvalidTimeFormat,[S]);\n    Exit;\n  end;\n  if (AmPm=AMPM_PM) and (TimeValues[tiHour]<>12) then Inc(TimeValues[tiHour], 12)\n  else if (AmPm=AMPM_AM) and (TimeValues[tiHour]=12) then TimeValues[tiHour]:=0;\n  // Writeln(      TimeValues[tiHour], TimeValues[tiMin], TimeValues[tiSec], TimeValues[tiMSec]);\n  if not TryEncodeTime(TimeValues[tiHour], TimeValues[tiMin], TimeValues[tiSec], TimeValues[tiMSec], result) Then\n\n    ErrorMsg:=Format(SErrInvalidTimeFormat,[S]);\nend ;\n\nfunction StrToTime(const S: String; separator: char): TDateTime;\n\nVar\n  Msg : String;\n\nbegin\n  Result:=IntStrToTime(Msg,S,Length(S),Separator);\n  If (Msg<>'') then\n    Raise EConvertError.Create(Msg);\nend;\n\nfunction StrToTime(const S: String): TDateTime;\nbegin\n   result:= StrToTime(s, TimeSeparator);\nend;\n\n{   StrToDateTime converts the string S to a TDateTime value\n    if S does not represent a valid date and/or time value\n    an EConvertError will be raised   }\n\nfunction SplitDateTimeStr(DateTimeStr: String; out DateStr, TimeStr: String): Integer;\n\n{ Helper function for StrToDateTime\n  Pre-condition\n    Date is before Time\n    If either Date or Time is omitted then see what fits best, a time or a date (issue #0020522)\n    Date and Time are separated by whitespace (space Tab, Linefeed or carriage return)\n    FS.DateSeparator can be the same as FS.TimeSeparator (issue #0020522)\n    If they are both #32 and TrimWhite(DateTimeStr) contains a #32 a date is assumed.\n  Post-condition\n    DateStr holds date as string or is empty\n    TimeStr holds time as string or is empty\n    Result = number of strings returned, 0 = error\n}\nconst\n  WhiteSpace = #9#10#13#32;\n\nvar\n  p: Integer;\n  DummyDT: TDateTime;\nbegin\n  Result := 0;\n  DateStr := '';\n  TimeStr := '';\n  DateTimeStr := Trim(DateTimeStr);\n  if Length(DateTimeStr) = 0 then exit;\n  if (DateSeparator = #32) and (TimeSeparator = #32) and (Pos(#32, DateTimeStr) > 0) then\n    begin\n    DateStr:=DateTimeStr;\n    {\n      Assume a date: dd [mm [yy]].\n      Really fancy would be counting the number of whitespace occurrences and decide\n      and split accordingly\n    }\n    Exit(1);\n    end;\n  p:=1;\n  //find separator\n  if (DateSeparator<>#32) then\n    begin\n    while (p<Length(DateTimeStr)) and (not (Pos(DateTimeStr[p+1],WhiteSpace)>0)) do\n      Inc(p);\n    end\n  else\n    begin\n    p:=Pos(TimeSeparator, DateTimeStr);\n    if (p<>0) then\n      repeat\n        Dec(p);\n      until (p=0) or (Pos(DateTimeStr[p],WhiteSpace)>0);\n    end;\n  //Always fill DateStr, it eases the algorithm later\n  if (p=0) then\n    p:=Length(DateTimeStr);\n  DateStr:=Copy(DateTimeStr,1,p);\n  TimeStr:=Trim(Copy(DateTimeStr,p+1,100));\n  if (Length(TimeStr)<>0) then\n    Result:=2\n  else\n    begin\n    Result:=1; //found 1 string\n    // 2 cases when DateTimeStr only contains a time:\n    // Date/time separator differ, and string contains a timeseparator\n    // Date/time separators are equal, but transformation to date fails.\n    if ((DateSeparator<>TimeSeparator) and (Pos(TimeSeparator,DateStr) > 0))\n       or ((DateSeparator=TimeSeparator) and (not TryStrToDate(DateStr, DummyDT)))  then\n      begin\n      TimeStr := DateStr;\n      DateStr := '';\n      end;\n    end;\nend;\n\nfunction StrToDateTime(const S: String): TDateTime;\n\nvar\n  TimeStr, DateStr: String;\n  PartsFound: Integer;\nbegin\n  PartsFound := SplitDateTimeStr(S, DateStr, TimeStr);\n  case PartsFound of\n    0: Result:=StrToDate('');\n    1: if (Length(DateStr) > 0) then\n         Result := StrToDate(DateStr,ShortDateFormat,DateSeparator)\n       else\n         Result := StrToTime(TimeStr);\n    2: Result := ComposeDateTime(StrTodate(DateStr,ShortDateFormat,DateSeparator),\n                                  StrToTime(TimeStr));\n  end;\nend;\n\nfunction FormatDateTime(const FormatStr: string; const DateTime: TDateTime\n  ): string;\n\n  procedure StoreStr(APos,Len: Integer);\n  begin\n//    Writeln('StoreStr: ',Result,'+',Copy(FormatStr,APos,Len));\n    Result:=Result+Copy(FormatStr,APos,Len);\n  end;\n\n  procedure StoreString(const AStr: string);\n\n  begin\n//    Writeln('StoreString: ',Result,'+',AStr);\n    Result:=Result+AStr;\n  end;\n\n  procedure StoreInt(Value, Digits: Integer);\n  var\n    S: string;\n\n  begin\n    S:=IntToStr(Value);\n    While (Length(S)<Digits) do\n      S:='0'+S;\n    StoreString(S);\n  end;\n\nvar\n  Year, Month, Day, DayOfWeek, Hour, Minute, Second, MilliSecond: word;\n\n  procedure StoreFormat(const FormatStr: string; Nesting: Integer; TimeFlag: Boolean);\n  var\n    Token, lastformattoken, prevlasttoken: char;\n    Count: integer;\n    Clock12: boolean;\n    tmp: integer;\n    isInterval: Boolean;\n    P,FormatCurrent,FormatEnd : Integer;\n  begin\n    if Nesting > 1 then  // 0 is original string, 1 is included FormatString\n      Exit;\n    FormatCurrent := 1;\n    FormatEnd := Length(FormatStr);\n    Clock12 := false;\n    isInterval := false;\n    // look for unquoted 12-hour clock token\n    P:=1;\n    while P<=FormatEnd do\n      begin\n      Token := FormatStr[P];\n      case Token of\n        '''', '\"':\n        begin\n          Inc(P);\n          while (P < FormatEnd) and (FormatStr[P]<>Token) do\n            Inc(P);\n        end;\n        'A', 'a':\n        begin\n          if (CompareText(Copy(FormatStr,P,3),'A/P')=0) or\n             (CompareText(Copy(FormatStr,P,4),'AMPM')=0) or\n             (CompareText(Copy(FormatStr,P,5),'AM/PM')=0) then\n          begin\n            Clock12 := true;\n            break;\n          end;\n        end;\n      end;  // case\n      Inc(P);\n    end ;\n    token := #255;\n    lastformattoken := ' ';\n    prevlasttoken := 'H';\n    while FormatCurrent <= FormatEnd do\n    begin\n      Token := UpperCase(FormatStr[FormatCurrent])[1];\n     //  Writeln('Treating token at pos ',FormatCurrent,', : ',Token,' (',FormatStr,')');\n      Count := 1;\n      P := FormatCurrent + 1;\n      case Token of\n        '''', '\"':\n        begin\n          while (P < FormatEnd) and (FormatStr[P]<>Token) do\n            Inc(P);\n          Inc(P);\n          Count := P - FormatCurrent;\n          StoreStr(FormatCurrent + 1, Count - 2);\n        end ;\n        'A':\n        begin\n          if CompareText(Copy(FormatStr,FormatCurrent,4), 'AMPM') = 0 then\n          begin\n            Count := 4;\n            if Hour < 12 then\n              StoreString(TimeAMString)\n            else\n              StoreString(TimePMString);\n          end\n          else if CompareText(Copy(FormatStr,FormatCurrent,5), 'AM/PM') = 0 then\n          begin\n            Count := 5;\n            if Hour < 12 then StoreStr(FormatCurrent, 2)\n                         else StoreStr(FormatCurrent+3, 2);\n          end\n          else if CompareText(Copy(FormatStr,FormatCurrent,3), 'A/P') = 0 then\n          begin\n            Count := 3;\n            if Hour < 12 then StoreStr(FormatCurrent, 1)\n            else StoreStr(FormatCurrent+2, 1);\n          end\n          else\n            raise EConvertError.Create('Illegal character in format string');\n        end ;\n        '/':\n          begin\n           //  Writeln('Detected date separator');\n          StoreString(DateSeparator);\n          end;\n        ':': StoreString(TimeSeparator);\n        ' ', 'C', 'D', 'H', 'M', 'N', 'S', 'T', 'Y', 'Z', 'F' :\n        begin\n          // Writeln(FormatCurrent,' Special Token: ',Token,', Count: ',Count,', P: ',P);\n          while (P <= FormatEnd) and (UpperCase(FormatStr[P]) = Token) do\n            Inc(P);\n          Count := P - FormatCurrent;\n          // Writeln(FormatCurrent,' Special Token: ',Token,', Count: ',Count,', P: ',P);\n          case Token of\n            ' ': StoreStr(FormatCurrent, Count);\n            'Y': begin\n              if Count > 2 then\n                StoreInt(Year, 4)\n              else\n                StoreInt(Year mod 100, 2);\n            end;\n            'M': begin\n\t      if isInterval and ((prevlasttoken = 'H') or TimeFlag) then\n\t        StoreInt(Minute + (Hour + trunc(abs(DateTime))*24)*60, 0)\n\t      else\n              if (lastformattoken = 'H') or TimeFlag then\n              begin\n                if Count = 1 then\n                  StoreInt(Minute, 0)\n                else\n                  StoreInt(Minute, 2);\n              end\n              else\n              begin\n                case Count of\n                  1: StoreInt(Month, 0);\n                  2: StoreInt(Month, 2);\n                  3: StoreString(ShortMonthNames[Month]);\n                else\n                  StoreString(LongMonthNames[Month]);\n                end;\n              end;\n            end;\n            'D': begin\n              case Count of\n                1: StoreInt(Day, 0);\n                2: StoreInt(Day, 2);\n                3: StoreString(ShortDayNames[DayOfWeek]);\n                4: StoreString(LongDayNames[DayOfWeek]);\n                5: StoreFormat(ShortDateFormat, Nesting+1, False);\n              else\n                StoreFormat(LongDateFormat, Nesting+1, False);\n              end ;\n            end ;\n            'H':\n\t      if isInterval then\n\t        StoreInt(Hour + trunc(abs(DateTime))*24, 0)\n\t      else\n\t      if Clock12 then\n              begin\n                tmp := hour mod 12;\n                if tmp=0 then tmp:=12;\n                if Count = 1 then\n                  StoreInt(tmp, 0)\n                else\n                  StoreInt(tmp, 2);\n              end\n              else begin\n                if Count = 1 then\n\t\t  StoreInt(Hour, 0)\n                else\n                  StoreInt(Hour, 2);\n              end;\n            'N': if isInterval then\n\t           StoreInt(Minute + (Hour + trunc(abs(DateTime))*24)*60, 0)\n\t\t else\n\t\t if Count = 1 then\n                   StoreInt(Minute, 0)\n                 else\n                   StoreInt(Minute, 2);\n            'S': if isInterval then\n\t           StoreInt(Second + (Minute + (Hour + trunc(abs(DateTime))*24)*60)*60, 0)\n\t         else\n\t         if Count = 1 then\n                   StoreInt(Second, 0)\n                 else\n                   StoreInt(Second, 2);\n            'Z': if Count = 1 then\n                   StoreInt(MilliSecond, 0)\n                 else\n\t\t   StoreInt(MilliSecond, 3);\n            'T': if Count = 1 then\n\t\t   StoreFormat(ShortTimeFormat, Nesting+1, True)\n                 else\n\t           StoreFormat(LongTimeFormat, Nesting+1, True);\n            'C': begin\n                   StoreFormat(ShortDateFormat, Nesting+1, False);\n                   if (Hour<>0) or (Minute<>0) or (Second<>0) then\n                     begin\n                      StoreString(' ');\n                      StoreFormat(LongTimeFormat, Nesting+1, True);\n                     end;\n                 end;\n            'F': begin\n                   StoreFormat(ShortDateFormat, Nesting+1, False);\n                   StoreString(' ');\n                   StoreFormat(LongTimeFormat, Nesting+1, True);\n                 end;\n          end;\n\t  prevlasttoken := lastformattoken;\n          lastformattoken := token;\n        end;\n        else\n          StoreString(Token);\n      end ;\n      Inc(FormatCurrent, Count);\n    end;\n  end;\n\nbegin\n  DecodeDateFully(DateTime, Year, Month, Day, DayOfWeek);\n  DecodeTime(DateTime, Hour, Minute, Second, MilliSecond);\n  // Writeln(DateTime,'->',Year,',', Month, ',',Day, ',',DayOfWeek,',',Hour, ',',Minute, ',',Second, ',',MilliSecond);\n  if FormatStr <> '' then\n    StoreFormat(FormatStr, 0, False)\n  else\n    StoreFormat('C', 0, False);\nend ;\n\n\n\nfunction CurrentYear: Word;\n\nbegin\n  Result:=TJSDate.New().FullYear;\nend;\n\nfunction TryStrToDate(const S: String; out Value: TDateTime): Boolean;\nbegin\n  Result:=TryStrToDate(S,Value,ShortDateFormat,#0);\nend;\n\nfunction TryStrToDate(const S: String; out Value: TDateTime; separator : char): Boolean;\n\nbegin\n  Result:=TryStrToDate(S,Value,ShortDateFormat,Separator);\nend;\n\nfunction TryStrToDate(const S: String; out Value: TDateTime;\n                    const useformat : string; separator : char = #0): Boolean;\n\nVar\n  Msg : String;\n\nbegin\n  Result:=Length(S)<>0;\n  If Result then\n    begin\n    Value:=IntStrToDate(Msg,S,useformat,Separator);\n    Result:=(Msg='');\n    end;\nend;\n\n\n\n\nfunction TryStrToTime(const S: String; out Value: TDateTime; separator : char): Boolean;\nVar\n  Msg : String;\nbegin\n  Result:=Length(S)<>0;\n  If Result then\n    begin\n      Value:=IntStrToTime(Msg,S,Length(S),Separator);\n      Result:=(Msg='');\n    end;\nend;\n\nfunction TryStrToTime(const S: String; out Value: TDateTime): Boolean;\nbegin\n  result:=TryStrToTime(S,Value,#0);\nend;\n\nfunction TryStrToDateTime(const S: String; out Value: TDateTime): Boolean;\n\nvar\n  I: integer;\n  dtdate, dttime :TDateTime;\nbegin\n  result:=false;\n  I:=Pos(TimeSeparator,S);\n  If (I>0) then\n    begin\n      While (I>0) and (S[I]<>' ') do\n        Dec(I);\n      If I>0 then\n        begin\n          if not TryStrToDate(Copy(S,1,I-1),dtdate) then\n            exit;\n          if not TryStrToTime(Copy(S,i+1, Length(S)-i),dttime) then\n            exit;\n          Value:=ComposeDateTime(dtdate,dttime);\n          result:=true;\n        end\n      else\n         result:=TryStrToTime(s,Value);\n    end\n  else\n    result:=TryStrToDate(s,Value);\nend;\n\n\n\nfunction StrToDateDef(const S: String; const Defvalue : TDateTime): TDateTime;\nbegin\n   result := StrToDateDef(S,DefValue,#0);\nend;\n\nfunction StrToTimeDef(const S: String; const Defvalue : TDateTime): TDateTime;\nbegin\n   result := StrToTimeDef(S,DefValue,#0);\nend;\n\nfunction StrToDateTimeDef(const S: String; const Defvalue : TDateTime): TDateTime;\nbegin\n  if not TryStrToDateTime(s,Result) Then\n    result:=defvalue;\nend;\n\nfunction StrToDateDef(const S: String; const Defvalue : TDateTime; separator : char): TDateTime;\nbegin\n  if not TryStrToDate(s,Result, separator) Then\n    result:=defvalue;\nend;\n\nfunction StrToTimeDef(const S: String; const Defvalue : TDateTime; separator : char): TDateTime;\nbegin\n  if not TryStrToTime(s,Result, separator) Then\n    result:=defvalue;\nend;\n\nprocedure ReplaceTime(var dati:TDateTime; NewTime : TDateTime);\nbegin\n  dati:= ComposeDateTime(dati, newtime);\nend;\n\nprocedure ReplaceDate(var DateTime: TDateTime; const NewDate: TDateTime);\nvar\n  tmp : TDateTime;\nbegin\n  tmp:=NewDate;\n  ReplaceTime(tmp,DateTime);\n  DateTime:=tmp;\nend;\n\nfunction FloatToDateTime(const Value: Extended): TDateTime;\nbegin\n  If (Value<MinDateTime) or (Value>MaxDateTime) then\n    Raise EConvertError.CreateFmt (SInvalidDateTime,[FloatToStr(Value)]);\n  Result:=Value;\nend;\n\nfunction FloattoCurr(const Value: Extended): Currency;\nbegin\n  if not TryFloatToCurr(Value, Result) then\n    Raise EConvertError.CreateFmt(SInvalidCurrency, [FloatToStr(Value)]);\nend;\n\nfunction TryFloatToCurr(const Value: Extended; var AResult: Currency): Boolean;\nbegin\n  Result:=(Value>=MinCurrency) and (Value<=MaxCurrency);\n  if Result then\n    AResult := Value;\nend;\n\nfunction CurrToStr(Value: Currency): string;\nbegin\n  Result:=FloatToStrF(Value,ffGeneral,-1,0);\nend;\n\n(*\nfunction CurrToStr(Value: Currency; const FormatSettings: TFormatSettings): string;\nbegin\n\nend;\n*)\n\nfunction StrToCurr(const S: string): Currency;\n\nbegin\n  if not TryStrToCurr(S,Result) then\n    Raise EConvertError.createfmt(SInvalidCurrency,[S]);\nend;\n\n(*\nfunction StrToCurr(const S: string; const FormatSettings: TFormatSettings): Currency;\nbegin\n\nend;\n*)\n\nfunction TryStrToCurr(const S: string; out Value: Currency): Boolean;\n\nVar\n  D : Double;\n\nbegin\n  Result:=TryStrToFloat(S,D);\n  if Result then\n    Value:=D;\nend;\n\n(*\nfunction TryStrToCurr(const S: string; out Value: Currency; const FormatSettings: TFormatSettings): Boolean;\nbegin\n\nend;\n*)\n\nfunction StrToCurrDef(const S: string; Default: Currency): Currency;\n\nVar\n  R : Currency;\n\nbegin\n  if TryStrToCurr(S,R) then\n    Result:=R\n  else\n    Result:=Default;\nend;\n\n(*\nfunction StrToCurrDef(const S: string; Default: Currency; const FormatSettings: TFormatSettings): Currency;\nbegin\n\nend;\n*)\n\n{ ---------------------------------------------------------------------\n  Interface related\n  ---------------------------------------------------------------------}\nfunction Supports(const Instance: IInterface; const AClass: TClass; out Obj\n  ): Boolean;\nbegin\n  Result := (Instance<>nil) and (Instance.QueryInterface(IObjectInstance,Obj)=S_OK)\n     and (TObject(Obj).InheritsFrom(AClass));\nend;\n\nfunction Supports(const Instance: IInterface; const IID: TGuid; out Intf\n  ): Boolean;\nbegin\n  Result:=(Instance<>nil) and (Instance.QueryInterface(IID,Intf)=S_OK);\nend;\n\nfunction Supports(const Instance: TObject; const IID: TGuid; out Intf): Boolean;\nbegin\n  Result:=(Instance<>nil) and Instance.GetInterface(IID,Intf);\nend;\n\nfunction Supports(const Instance: TObject; const IID: TGuidString; out Intf\n  ): Boolean;\nbegin\n  Result:=(Instance<>nil) and Instance.GetInterfaceByStr(IID,Intf);\nend;\n\nfunction Supports(const Instance: IInterface; const AClass: TClass): Boolean;\nvar\n  Temp: TObject;\nbegin\n  Result:=Supports(Instance,AClass,Temp);\nend;\n\nfunction Supports(const Instance: IInterface; const IID: TGuid): Boolean;\nvar\n  Temp: IInterface;\nbegin\n  Result:=Supports(Instance,IID,Temp);\nend;\n\nfunction Supports(const Instance: TObject; const IID: TGuid): Boolean;\nvar\n  Temp: TJSObject;\nbegin\n  Result:=Supports(Instance,IID,Temp);\n  asm\n    if (Temp && Temp.$kind==='com') Temp._Release();\n  end;\nend;\n\nfunction Supports(const Instance: TObject; const IID: TGuidString): Boolean;\nvar\n  Temp: TJSObject;\nbegin\n  Result:=Supports(Instance,IID,Temp);\n  asm\n    if (Temp && Temp.$kind==='com') Temp._Release();\n  end;\nend;\n\nfunction Supports(const AClass: TClass; const IID: TGuid): Boolean;\nvar\n  maps: JSValue;\nbegin\n  if AClass=nil then exit(false);\n  maps := TJSObject(AClass)['$intfmaps'];\n  if not maps then exit(false);\n  if TJSObject(maps)[GUIDToString(IID)] then exit(true);\n  Result:=false;\nend;\n\nfunction Supports(const AClass: TClass; const IID: TGuidString): Boolean;\nvar\n  maps: JSValue;\nbegin\n  if AClass=nil then exit(false);\n  maps := TJSObject(AClass)['$intfmaps'];\n  if not maps then exit(false);\n  if TJSObject(maps)[uppercase(IID)] then exit(true);\n  Result:=false;\nend;\n\nfunction TryStringToGUID(const s: string; out Guid: TGuid): Boolean;\nvar\n  re: TJSRegexp;\nbegin\n  if Length(s)<>38 then Exit(False);\n  re:=TJSRegexp.new('^\\{[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\}$');\n  Result:=re.test(s);\n  if not Result then\n    begin\n    Guid.D1:=0;\n    exit;\n    end;\n  asm\n    rtl.strToGUIDR(s,Guid);\n  end;\n  Result:=true;\nend;\n\nfunction StringToGUID(const S: string): TGuid;\nbegin\n  if not TryStringToGUID(S, Result) then\n    raise EConvertError.CreateFmt(SInvalidGUID, [S]);\nend;\n\nfunction GUIDToString(const guid: TGuid): string;\nbegin\n  Result:=System.GUIDToString(guid);\nend;\n\nfunction IsEqualGUID(const guid1, guid2: TGuid): Boolean;\nvar\n  i: integer;\nbegin\n  if (guid1.D1<>guid2.D1) or (guid1.D2<>guid2.D2) or (guid1.D3<>guid2.D3) then\n    exit(false);\n  for i:=0 to 7 do if guid1.D4[i]<>guid2.D4[i] then exit(false);\n  Result:=true;\nend;\n\nfunction GuidCase(const guid: TGuid; const List: array of TGuid): Integer;\nbegin\n  for Result := High(List) downto 0 do\n    if IsEqualGUID(guid, List[Result]) then\n      Exit;\n  Result := -1;\nend;\n\nfunction CreateGUID(out GUID: TGUID): Integer;\n\n  Function R(B: Integer) : NativeInt;\n\n  Var\n    v : NativeInt;\n  begin\n    v:=Random(256);\n    While B>1 do\n      begin\n      v:=v*256+Random(256);\n      Dec(B);\n      end;\n    Result:=V;\n  end;\n\nVar\n  I : Integer;\n\nbegin\n  Result:=0;\n  GUID.D1:= R(4);\n  GUID.D2:= R(2);\n  GUID.D3:= R(2);\n  For I:=0 to 7 do\n   GUID.D4[I]:=R(1);\nend;\n{ ---------------------------------------------------------------------\n  Integer/Ordinal related\n  ---------------------------------------------------------------------}\n\nfunction TryStrToInt(const S: String; out res: Integer): Boolean;\n\nVar\n  NI : NativeInt;\n\nbegin\n  Result:=TryStrToInt(S,NI);\n  if Result then\n    res:=NI;\nend;\n\nfunction TryStrToInt(const S: String; out res: NativeInt): Boolean;\n\nVar\n  Radix : Integer = 10;\n  N : String;\n  J : JSValue;\n\nbegin\n  N:=S;\n  case Copy(N,1,1) of\n  '$': Radix:=16;\n  '&': Radix:=8;\n  '%': Radix:=2;\n  end;\n  If Radix<>10 then\n    Delete(N,1,1);\n  J:=parseInt(N,Radix);\n  Result:=Not jsIsNan(j);\n  if Result then\n    res:=NativeInt(J);\nend;\n\nfunction StrToIntDef(const S: String; const aDef: Integer): Integer;\n\nVar\n  R : NativeInt;\n\nbegin\n  if TryStrToInt(S,R) then\n    Result:=R\n  else\n    Result:=aDef;\nend;\n\nfunction StrToIntDef(const S: String; const aDef: NativeInt): NativeInt;\n\nVar\n  R : NativeInt;\n\nbegin\n  if TryStrToInt(S,R) then\n    Result:=R\n  else\n    Result:=aDef;\nend;\n\nfunction StrToInt(const S: String): Integer;\n\nVar\n  R : NativeInt;\n\nbegin\n  if not TryStrToInt(S,R) then\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\n  Result:=R;\nend;\n\nfunction StrToNativeInt(const S: String): NativeInt;\n\nbegin\n  if not TryStrToInt(S,Result) then\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\nend;\n\nfunction StrToInt64(const S: String): NativeLargeInt;\n\nVar\n  N : NativeInt;\n\nbegin\n  if not TryStrToInt(S,N) then\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\n  Result:=N;\nend;\n\nfunction TryStrToInt64(const S: String; out res: NativeLargeInt): Boolean;\n\nVar\n  R : nativeint;\n\nbegin\n  Result:=TryStrToInt(S,R);\n  If Result then\n    Res:=R;\nend;\n\nfunction StrToInt64Def(const S: String; ADefault: NativeLargeInt\n  ): NativeLargeInt;\n\n\nbegin\n  if TryStrToInt64(S,Result) then\n    Result:=ADefault;\nend;\n\nfunction StrToQWord(const S: String): NativeLargeUInt;\n\nVar\n  N : NativeInt;\n\nbegin\n  if (not TryStrToInt(S,N)) or (N<0) then\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\n  Result:=N;\nend;\n\nfunction TryStrToQWord(const S: String; out res: NativeLargeUInt): Boolean;\n\nVar\n  R : nativeint;\n\nbegin\n  Result:=TryStrToInt(S,R) and (R>=0);\n  If Result then\n    Res:=R;\nend;\n\nfunction StrToQWordDef(const S: String; ADefault: NativeLargeUInt\n  ): NativeLargeUInt;\n\nbegin\n  if Not TryStrToQword(S,Result) then\n    Result:=ADefault;\nend;\n\n\nfunction StrToUInt64(const S: String): NativeLargeUInt;\n\nVar\n  N : NativeInt;\n\nbegin\n  if (not TryStrToInt(S,N)) or (N<0) then\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\n  Result:=N;\nend;\n\nfunction TryStrToUInt64(const S: String; out res: NativeLargeUInt): Boolean;\n\nVar\n  R : nativeint;\n\nbegin\n  Result:=TryStrToInt(S,R) and (R>=0);\n  If Result then\n    Res:=R;\nend;\n\nfunction StrToUInt64Def(const S: String; ADefault: NativeLargeUInt\n  ): NativeLargeUInt;\n\n\nbegin\n  if Not TryStrToUInt64(S,Result) then\n    Result:=ADefault;\nend;\n\nfunction TryStrToDWord(const S: String; out res: DWord): Boolean;\n\nVar\n  R : nativeint;\n\nbegin\n  Result:=TryStrToInt(S,R) and (R>=0) and (R<=DWord($FFFFFFFF));\n  If Result then\n    Res:=R;\nend;\n\nfunction StrToDWord(const S: String): DWord;\n\nbegin\n  if not TryStrToDWord(S,Result) then\n    Raise EConvertError.CreateFmt(SErrInvalidInteger,[S]);\nend;\n\n\nfunction StrToDWordDef(const S: String; ADefault: DWord): DWord;\n\nbegin\n  if Not TryStrToDWord(S,Result) then\n    Result:=ADefault;\nend;\n\n\nfunction IntToHex(Value: NativeInt; Digits: integer): string;\nconst\n  HexDigits = '0123456789ABCDEF';\nbegin\n  If Digits=0 then\n    Digits:=1;\n  Result:='';\n  While Value>0 do\n    begin\n    result:=HexDigits[(value and 15)+1]+Result;\n    value := value shr 4;\n    end ;\n  while (Length(Result)<Digits) do\n    Result:='0'+Result;\nend;\n\n\n{ TFormatSettings }\n\nfunction TFormatSettings.GetCurrencyDecimals: Byte;\nbegin\n  Result:=Sysutils.CurrencyDecimals;\nend;\n\nfunction TFormatSettings.GetCurrencyFormat: Byte;\nbegin\n  Result:=Sysutils.CurrencyFormat;\nend;\n\nfunction TFormatSettings.GetCurrencyString: String;\nbegin\n  Result:=Sysutils.CurrencyString;\nend;\n\nfunction TFormatSettings.GetDateSeparator: char;\nbegin\n  Result := SysUtils.DateSeparator;\nend;\n\nfunction TFormatSettings.GetDecimalSeparator: string;\nbegin\n  Result := SysUtils.DecimalSeparator;\nend;\n\nfunction TFormatSettings.GetLongDateFormat: string;\nbegin\n  Result := SysUtils.LongDateFormat;\nend;\n\nfunction TFormatSettings.GetLongDayNames: TDayNames;\nbegin\n  Result:=Sysutils.LongDayNames;\nend;\n\nfunction TFormatSettings.GetLongMonthNames: TMonthNames;\nbegin\n Result:=Sysutils.LongMonthNames;\nend;\n\nfunction TFormatSettings.GetLongTimeFormat: string;\nbegin\n  Result := SysUtils.LongTimeFormat;\nend;\n\nfunction TFormatSettings.GetNegCurrFormat: Byte;\nbegin\n  Result:=Sysutils.NegCurrFormat;\nend;\n\nfunction TFormatSettings.GetShortDateFormat: string;\nbegin\n  Result := SysUtils.ShortDateFormat;\nend;\n\nfunction TFormatSettings.GetShortDayNames: TDayNames;\nbegin\n Result:=Sysutils.ShortDayNames;\nend;\n\nfunction TFormatSettings.GetShortMonthNames: TMonthNames;\nbegin\n Result:=Sysutils.ShortMonthNames;\nend;\n\nfunction TFormatSettings.GetShortTimeFormat: string;\nbegin\n  Result := SysUtils.ShortTimeFormat;\nend;\n\nfunction TFormatSettings.GetThousandSeparator: string;\nbegin\n  Result := SysUtils.ThousandSeparator;\nend;\n\nfunction TFormatSettings.GetTimeAMString: string;\nbegin\n  Result := SysUtils.TimeAMString;\nend;\n\nfunction TFormatSettings.GetTimePMString: string;\nbegin\n  Result := SysUtils.TimePMString;\nend;\n\nfunction TFormatSettings.GetTimeSeparator: char;\nbegin\n  Result := SysUtils.TimeSeparator;\nend;\n\nprocedure TFormatSettings.SetCurrencyFormat(AValue: Byte);\nbegin\n  Sysutils.CurrencyFormat:=AValue;\nend;\n\nprocedure TFormatSettings.SetCurrencyString(AValue: String);\nbegin\n  Sysutils.CurrencyString:=AValue;\nend;\n\nprocedure TFormatSettings.SetDateSeparator(const Value: char);\nbegin\n  SysUtils.DateSeparator := Value;\nend;\n\nprocedure TFormatSettings.SetDecimalSeparator(const Value: string);\nbegin\n  SysUtils.DecimalSeparator := Value;\nend;\n\nprocedure TFormatSettings.SetLongDateFormat(const Value: string);\nbegin\n  SysUtils.LongDateFormat := Value;\nend;\n\nprocedure TFormatSettings.SetLongDayNames(AValue: TDayNames);\nbegin\n  SysUtils.LongDayNames:=AValue;\nend;\n\nprocedure TFormatSettings.SetLongMonthNames(AValue: TMonthNames);\nbegin\n  SysUtils.LongMonthNames:=AValue;\nend;\n\nprocedure TFormatSettings.SetLongTimeFormat(const Value: string);\nbegin\n  SysUtils.LongTimeFormat := Value;\nend;\n\nprocedure TFormatSettings.SetNegCurrFormat(AValue: Byte);\nbegin\n  Sysutils.NegCurrFormat:=AValue;\nend;\n\nprocedure TFormatSettings.SetShortDateFormat(const Value: string);\nbegin\n  SysUtils.ShortDateFormat := Value;\nend;\n\nprocedure TFormatSettings.SetShortDayNames(AValue: TDayNames);\nbegin\n  SysUtils.ShortDayNames:=AValue;\nend;\n\nprocedure TFormatSettings.SetShortMonthNames(AValue: TMonthNames);\nbegin\n  SysUtils.ShortMonthNames:=AValue;\nend;\n\nprocedure TFormatSettings.SetShortTimeFormat(const Value: string);\nbegin\n  SysUtils.ShortTimeFormat := Value;\nend;\n\nprocedure TFormatSettings.SetCurrencyDecimals(AValue: Byte);\nbegin\n  Sysutils.CurrencyDecimals:=aValue;\nend;\n\nprocedure TFormatSettings.SetThousandSeparator(const Value: string);\nbegin\n  SysUtils.ThousandSeparator := Value;\nend;\n\nprocedure TFormatSettings.SetTimeAMString(const Value: string);\nbegin\n  SysUtils.TimeAMString := Value;\nend;\n\nprocedure TFormatSettings.SetTimePMString(const Value: string);\nbegin\n  SysUtils.TimePMString := Value;\nend;\n\nprocedure TFormatSettings.SetTimeSeparator(const Value: char);\nbegin\n  SysUtils.TimeSeparator := Value;\nend;\n\n{ ---------------------------------------------------------------------\n  FileNames\n  ---------------------------------------------------------------------}\n\nfunction ChangeFileExt(const FileName, Extension: PathStr): PathStr;\nvar\n  i : longint;\n  EndSep : Set of Char;\n  SOF : Boolean;\n\nbegin\n  i := Length(FileName);\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators+[ExtensionSeparator];\n  while (I > 0) and not(FileName[I] in EndSep) do\n    Dec(I);\n  if (I = 0) or (FileName[I] <> ExtensionSeparator) then\n    I := Length(FileName)+1\n  else\n    begin\n        SOF:=(I=1) or (FileName[i-1] in AllowDirectorySeparators);\n        if (SOF) and not FirstDotAtFileNameStartIsExtension then\n          I:=Length(FileName)+1;\n        end;\n  Result := Copy(FileName, 1, I - 1) + Extension;\nend;\n\nfunction ExtractFilePath(const FileName: PathStr): PathStr;\nvar\n  i : longint;\n  EndSep : Set of Char;\nbegin\n  i := Length(FileName);\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators;\n  while (i > 0) and not CharInSet(FileName[i],EndSep) do\n    Dec(i);\n  If I>0 then\n    Result := Copy(FileName, 1, i)\n  else\n    Result:='';\nend;\n\nfunction ExtractFileDir(const FileName: PathStr): PathStr;\nvar\n  i : longint;\n  EndSep : Set of Char;\nbegin\n  I := Length(FileName);\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators;\n  while (I > 0) and not CharInSet(FileName[I],EndSep) do\n    Dec(I);\n  if (I > 1) and CharInSet(FileName[I],AllowDirectorySeparators) and\n     not CharInSet(FileName[I - 1],EndSep) then\n    Dec(I);\n  Result := Copy(FileName, 1, I);\nend;\n\nfunction ExtractFileDrive(const FileName: PathStr): PathStr;\nvar\n  i,l: longint;\nbegin\n  Result := '';\n  l:=Length(FileName);\n  if (l<2) then\n    exit;\n  If CharInSet(FileName[2],AllowDriveSeparators) then\n    result:=Copy(FileName,1,2)\n  else if CharInSet(FileName[1],AllowDirectorySeparators) and\n          CharInSet(FileName[2],AllowDirectorySeparators) then\n    begin\n      i := 2;\n\n      { skip share }\n      While (i<l) and Not CharInSet(Filename[i+1],AllowDirectorySeparators) do\n        inc(i);\n      inc(i);\n\n      While (i<l) and Not CharInSet(Filename[i+1],AllowDirectorySeparators) do\n        inc(i);\n      Result:=Copy(FileName,1,i);\n    end;\nend;\n\nfunction ExtractFileName(const FileName: PathStr): PathStr;\nvar\n  i : longint;\n  EndSep : Set of Char;\nbegin\n  I := Length(FileName);\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators;\n  while (I > 0) and not CharInSet(FileName[I],EndSep) do\n    Dec(I);\n  Result := Copy(FileName, I + 1, MaxInt);\nend;\n\nfunction ExtractFileExt(const FileName: PathStr): PathStr;\nvar\n  i : longint;\n  EndSep : Set of Char;\n  SOF : Boolean; // Dot at Start of filename ?\n\nbegin\n  Result:='';\n  I := Length(FileName);\n  EndSep:=AllowDirectorySeparators+AllowDriveSeparators+[ExtensionSeparator];\n  while (I > 0) and not CharInSet(FileName[I],EndSep) do\n    Dec(I);\n  if (I > 0) and (FileName[I] = ExtensionSeparator) then\n    begin\n        SOF:=(I=1) or (FileName[i-1] in AllowDirectorySeparators);\n        if (Not SOF) or FirstDotAtFileNameStartIsExtension then\n          Result := Copy(FileName, I, MaxInt);\n        end\n  else\n    Result := '';\nend;\n\nfunction ExtractRelativepath(const BaseName, DestName: PathStr): PathStr;\n\nVar\n  OneLevelBack,Source, Dest   : PathStr;\n  Sc,Dc,I,J      : Longint;\n  SD,DD          : TPathStrArray;\n\n\nbegin\n  OneLevelBack := '..'+PathDelim;\n  If Uppercase(ExtractFileDrive(BaseName))<>Uppercase(ExtractFileDrive(DestName)) Then\n    begin\n    Result:=DestName;\n    exit;\n    end;\n  Source:=ExcludeTrailingPathDelimiter(ExtractFilePath(BaseName));\n  Dest:=ExcludeTrailingPathDelimiter(ExtractFilePath(DestName));\n  SD:=GetDirs (Source);\n  SC:=Length(SD);\n  DD:=GetDirs (Dest);\n  DC:=Length(SD);\n  I:=0;\n  While (I<DC) and (I<SC) do\n    begin\n    If SameText(DD[i],SD[i]) then\n      Inc(i)\n    else\n      Break;\n    end;\n  Result:='';\n  For J:=I to SC do Result:=Result+OneLevelBack;\n  For J:=I to DC do Result:=Result+DD[J]+PathDelim;\n  Result:=Result+ExtractFileName(DestName);\nend;\n\nfunction SetDirSeparators(const FileName: PathStr): PathStr;\n\nVar\n  I : integer;\n\nbegin\n  Result:=FileName;\n  For I:=1 to Length(Result) do\n    If CharInSet(Result[I],AllowDirectorySeparators) then\n      Result[i]:=PathDelim;\nend;\n\nfunction GetDirs(DirName: PathStr): TPathStrArray;\n\nVar\n  I,J,L : Longint;\n  D : String;\n\nbegin\n  I:=1;\n  J:=0;\n  L:=0;\n  SetLength(Result,Length(DirName));\n  While I<=Length(DirName) do\n    begin\n    If CharInSet(DirName[i],AllowDirectorySeparators) then\n      begin\n      D:=Copy(DirName,J+1,J-I);\n      if (D<>'') then\n        begin\n        Result[L]:=D;\n        Inc(L);\n        end;\n      J:=I;\n      end;\n    Inc(I);\n    end;\n  SetLength(Result,L);\nend;\n\nfunction IncludeTrailingPathDelimiter(const Path: PathStr): PathStr;\n\nVar\n  l : Integer;\n\nbegin\n  Result:=Path;\n  l:=Length(Result);\n  If (L=0) or not CharInSet(Result[l],AllowDirectorySeparators) then\n    Result:=Result+PathDelim;\nend;\n\nfunction ExcludeTrailingPathDelimiter(const Path: PathStr): PathStr;\n\nVar\n  L : Integer;\n\nbegin\n  L:=Length(Path);\n  If (L>0) and CharInSet(Path[L],AllowDirectorySeparators) then\n    Dec(L);\n  Result:=Copy(Path,1,L);\nend;\n\nfunction IncludeLeadingPathDelimiter(const Path: PathStr): PathStr;\n\nVar\n  l : Integer;\n\nbegin\n  Result:=Path;\n  l:=Length(Result);\n  If (L=0) or not CharInSet(Result[1],AllowDirectorySeparators) then\n    Result:=PathDelim+Result;\nend;\n\nfunction ExcludeLeadingPathDelimiter(const Path: PathStr): PathStr;\n\nVar\n  L : Integer;\n\nbegin\n  Result:=Path;\n  L:=Length(Result);\n  If (L>0) and CharInSet(Result[1],AllowDirectorySeparators) then\n    Delete(Result,1,1);\nend;\n\nfunction IsPathDelimiter(const Path: PathStr; Index: Integer): Boolean;\n\nbegin\n  Result:=(Index>0) and (Index<=Length(Path)) and CharInSet(Path[Index],AllowDirectorySeparators);\nend;\n\nfunction ConcatPaths(const Paths: array of PathStr): PathStr;\nvar\n  I: Integer;\nbegin\n  if Length(Paths) > 0 then\n  begin\n    Result := Paths[0];\n    for I := 1 to Length(Paths) - 1 do\n      Result := IncludeTrailingPathDelimiter(Result) + ExcludeLeadingPathDelimiter(Paths[I]);\n  end else\n    Result := '';\nend;\n\n\ninitialization\n  FormatSettings := TFormatSettings.Create;\n\nend.\n\n","{\n    This file is part of the Pas2JS run time library.\n    Copyright (c) 2017 by Mattias Gaertner\n\n    See the file COPYING.FPC, included in this distribution,\n    for details about the copyright.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n **********************************************************************}\nunit Math;\n\n{$mode objfpc}\n\ninterface\n\nuses\n  SysUtils;\n\nconst\n  MinInteger = -$fffffffffffff-1;\n  MaxInteger = $fffffffffffff;\n  MinDouble  =  5.0e-324;\n  MaxDouble  =  1.7e+308;\n\n\nconst\n  NaN: Double; external name 'NaN';\n  Infinity: Double; external name 'Infinity';\n  NegInfinity: Double; external name '-Infinity';\n\ntype\n  float = double;\n\n  //EInvalidArgument = class(EMathError);\n\nfunction Min(const a, b: Double): Double; varargs; external name 'Math.min'; overload;\nfunction Max(const a, b: Double): Double; varargs; external name 'Math.max'; overload;\nfunction Min(const a, b: NativeLargeUInt): NativeLargeUInt; varargs; external name 'Math.min'; overload;\nfunction Max(const a, b: NativeLargeUInt): NativeLargeUInt; varargs; external name 'Math.max'; overload;\nfunction Min(const a, b: NativeLargeInt): NativeLargeInt; varargs; external name 'Math.min'; overload;\nfunction Max(const a, b: NativeLargeInt): NativeLargeInt; varargs; external name 'Math.max'; overload;\nfunction Min(const a, b: Integer): Integer; varargs; external name 'Math.min'; overload;\nfunction Max(const a, b: Integer): Integer; varargs; external name 'Math.max'; overload;\n\nfunction InRange(const AValue, AMin, AMax: Integer): Boolean; assembler; overload;\nfunction InRange(const AValue, AMin, AMax: Double): Boolean; assembler; overload;\n\nfunction EnsureRange(const AValue, AMin, AMax: Integer): Integer; assembler; overload;\nfunction EnsureRange(const AValue, AMin, AMax: Double): Double; assembler; overload;\n\ntype\n  TRoundToRange = -37..37;\n\nfunction RoundTo(const AValue: Double; const Digits: TRoundToRange): Double;\nfunction SimpleRoundTo(const AValue: Double; const Digits: TRoundToRange = -2): Double;\n\nfunction randg(mean,stddev : float) : float;\nfunction RandomRange(const aFrom, aTo: Integer): Integer;\nfunction RandomRange(const aFrom, aTo: NativeLargeInt): NativeLargeInt;\n\nconst\n  NegativeValue = -1;\n  ZeroValue = 0;\n  PositiveValue = 1;\n\nfunction Sign(const AValue: Integer): Integer; external name 'Math.sign'; overload;\nfunction Sign(const AValue: Double): Double; external name 'Math.sign'; overload;\n\nfunction IsZero(const d: Double; Epsilon: Double): Boolean; overload;\nfunction IsZero(const d: Double): Boolean; overload;\n\nfunction IsNaN(const v: JSValue): boolean; external name {$IFDEF ECMAScript5}'isNaN'{$ELSE}'Number.isNaN'{$ENDIF}; overload;\nfunction IsFinite(const d: JSValue): Boolean; external name 'isFinite'; overload;// false if NaN, positive or negative infinity\nfunction IsInfinite(const d: JSValue): Boolean; assembler; overload; // negative or positive infinity\n{$IFDEF ECMAScript6}\nfunction IsInteger(const d: JSValue): Boolean; external name 'Number.isInteger'; // any integer representable by a double\nfunction IsSafeInteger(const d: JSValue): Boolean; external name 'Number.isSafeInteger'; // an integer between MinInteger and MaxInteger, inclusive\n{$ENDIF}\n\nfunction SameValue(const A, B: Double; Epsilon: Double = 0.0): Boolean; overload;\n\n// function Abs is in System.pas\nfunction ArcCos(const A : Double): Double; external name 'Math.acos';\nfunction ArcCosH(const A: Double): Double; external name 'Math.acosh'; // not on IE\nfunction ArcSin(const A : Double): Double; external name 'Math.asin';\nfunction ArcSinH(const A : Double): Double; external name 'Math.asinh'; // not on IE\nfunction ArcTanH(const A: Double): Double; external name 'Math.atanh'; // not on IE\nfunction CosH(const A: Double): Double; external name 'Math.cosh'; // not on IE\nfunction ExpM1(const A: Double): Double; external name 'Math.expm1'; // not on IE\nfunction FRound(const A: Double): Double; overload; external name 'Math.fround'; // not on IE\nfunction FTrunc(const A: Double): double; overload; external name 'Math.trunc'; // not on IE\nfunction Hypot(const A : Double): Double; varargs; external name 'Math.hypot'; // not on IE\nfunction IMul(const A, B: Integer): Integer; external name 'Math.imul'; // not on IE\nfunction Log10(const A: Double): Double; external name 'Math.log10';\nfunction Log1p(const A: Double): Double; external name 'Math.log1p'; // not on IE\nfunction Log2(const A: Double): Double; external name 'Math.log2'; // not on IE\nfunction LogN(const A, Base: Double): Double; \nfunction Power(const Base, Exponent: Double): Double; external name 'Math.pow';\n// ln, round, sqrt, trunc, cos, sin, arctan, round, exp are in unit system\nfunction Ceil(const A: Double): Integer;\nfunction Floor(const A: Double): Integer;\nfunction Ceil64(const A: Double): NativeLargeInt;\nfunction Floor64(const A: Double): NativeLargeInt;\nfunction ldexp(x : double;const p : Integer) : double;\nprocedure Frexp(X: double; out Mantissa: double; out Exponent: integer);\nfunction lnxp1(x : double) : double;\n\nfunction IntPower(base : float;const exponent : Integer) : double;\n\nprocedure DivMod(Dividend: LongInt; Divisor: Word; out Result, Remainder: Word);\nprocedure DivMod(Dividend: LongInt; Divisor: Word; out Result, Remainder: SmallInt);\nprocedure DivMod(Dividend: DWord; Divisor: DWord; out Result, Remainder: DWord);\nprocedure DivMod(Dividend: LongInt; Divisor: LongInt; out Result, Remainder: LongInt);\n\n{ Angle conversion }\nfunction DegToRad(deg : double) : double;\nfunction RadToDeg(rad : double) : double;\nfunction GradToRad(grad : double) : double;\nfunction RadToGrad(rad : double) : double;\nfunction DegToGrad(deg : double) : double;\nfunction GradToDeg(grad : double) : double;\n{ one cycle are 2*Pi rad }\nfunction CycleToRad(cycle : double) : double;\nfunction RadToCycle(rad : double) : double;\nFunction DegNormalize(deg : double) : double;\n\nfunction Norm(const data : array of double) : double;\n\n// Statistical functions\nfunction Mean(const data : array of double) : double;\nfunction Sum(const data : array of double) : double;\nprocedure SumsAndSquares(const data : Array of Double; out Sum,SumOfSquares : double);\n\nfunction StdDev(const data : array of Double) : float;\nprocedure MeanAndStdDev(const data : array of Double; out Mean,StdDev : double);\nfunction Variance(const data : array of Double) : double;\nfunction TotalVariance(const data : array of Double) : double;\nfunction PopNStdDev(const data : array of Double) : double;\nfunction PopNVariance(const data : array of Double) : double;\nprocedure MomentSkewKurtosis(const data : array of Double; out m1,m2,m3,m4,skew,kurtosis : double);\n\n// Financial functions\n\nType\n  TPaymentTime = (ptEndOfPeriod,ptStartOfPeriod);\n\nfunction FutureValue(ARate: double; NPeriods: Integer;\n  APayment, APresentValue: double; APaymentTime: TPaymentTime): double;\n\nfunction InterestRate(NPeriods: Integer; APayment, APresentValue, AFutureValue: double;\n  APaymentTime: TPaymentTime): double;\n\nfunction NumberOfPeriods(ARate, APayment, APresentValue, AFutureValue: double;\n  APaymentTime: TPaymentTime): double;\n\nfunction Payment(ARate: double; NPeriods: Integer;\n  APresentValue, AFutureValue: double; APaymentTime: TPaymentTime): double;\n\nfunction PresentValue(ARate: double; NPeriods: Integer;\n  APayment, AFutureValue: double; APaymentTime: TPaymentTime): double;\n\n// Miscellaneous\n\nfunction IfThen(val:boolean;const ifTrue:integer; const ifFalse:integer= 0) :integer; overload;\nfunction IfThen(val:boolean;const ifTrue:double ; const ifFalse:double =0.0):double; overload;\n\nType\n  TValueRelationship = -1..1;\n\nconst\n  EqualsValue = 0;\n  LessThanValue = Low(TValueRelationship);\n  GreaterThanValue = High(TValueRelationship);\n\nfunction CompareValue ( const A, B  : Integer) : TValueRelationship;\nfunction CompareValue ( const A, B  : NativeLargeInt) : TValueRelationship;\nfunction CompareValue ( const A, B  : NativeLargeUInt) : TValueRelationship;\nfunction CompareValue ( const A, B : Double; delta : Double = 0.0) : TValueRelationship;\n\nimplementation\n\nfunction InRange(const AValue, AMin, AMax: Integer): Boolean; assembler;\nasm\n  return (AValue >= AMin) && (AValue <= AMax);\nend;\n\nfunction InRange(const AValue, AMin, AMax: Double): Boolean; assembler;\nasm\n  return (AValue >= AMin) && (AValue <= AMax);\nend;\n\nfunction EnsureRange(const AValue, AMin, AMax: Integer): Integer; assembler;\nasm\n  if (AValue<AMin){ return AMin;\n  } else if (AValue>AMax){ return AMax;\n  } else return AValue;\nend;\n\nfunction EnsureRange(const AValue, AMin, AMax: Double): Double; assembler;\nasm\n  if (AValue<AMin){ return AMin;\n  } else if (AValue>AMax){ return AMax;\n  } else return AValue;\nend;\n\nfunction RoundTo(const AValue: Double; const Digits: TRoundToRange): Double;\nvar\n  RV : Double;\n\nbegin\n  RV:=IntPower(10,Digits);\n  Result:=Round(AValue/RV)*RV;\nend;\n\nfunction SimpleRoundTo(const AValue: Double; const Digits: TRoundToRange): Double;\nvar\n  RV : Double;\n\nbegin\n  RV := IntPower(10, -Digits);\n  if AValue < 0 then\n    Result := Int((AValue*RV) - 0.5)/RV\n  else\n    Result := Int((AValue*RV) + 0.5)/RV;\nend;\n\nfunction randg(mean,stddev : float) : float;\n\nVar\n  U1,S2 : Float;\n\nbegin\n  repeat\n    u1:= 2*random-1;\n    S2:=Sqr(U1)+sqr(2*random-1);\n  until s2<1;\n  Result:=Sqrt(-2*ln(S2)/S2)*u1*stddev+Mean;\nend;\n\n\nfunction RandomRange(const aFrom, aTo: Integer): Integer;\nbegin\n  Result:=Random(Abs(aFrom-aTo))+Min(aTo,AFrom);\nend;\n\n\nfunction RandomRange(const aFrom, aTo: NativeLargeInt): NativeLargeInt;\n\nVar\n  m : NativeLargeInt;\nbegin\n  if aFrom<aTo then\n    M:=aFrom\n  else\n    M:=aTo;\n  Result:=Random(Abs(aFrom-aTo))+M;\nend;\n\nconst\n  DZeroResolution = 1E-12;\n\nfunction IsZero(const d: Double; Epsilon: Double): Boolean;\nbegin\n  if Epsilon=0 then\n    Epsilon:=DZeroResolution;\n  Result:=Abs(d)<=Epsilon;\nend;\n\nfunction IsZero(const d: Double): Boolean;\nbegin\n  Result:=Abs(d)<=DZeroResolution;\nend;\n\nfunction IsInfinite(const d: JSValue): Boolean; assembler;\nasm\n  return (d==Infinity) || (d==-Infinity);\nend;\n\nfunction SameValue(const A, B: Double; Epsilon: Double): Boolean;\nbegin\n  if (Epsilon=0.0) then\n    Epsilon:=Max(Min(Abs(A),Abs(B))*DZeroResolution,DZeroResolution);\n  if (A>B) then\n    Result:=((A-B)<=Epsilon)\n  else\n    Result:=((B-A)<=Epsilon);\nend;\n\nfunction JSFloor(const A: Double): Double; external name 'Math.floor';\nfunction JSCeil(const A: Double): Double; external name 'Math.ceil';\n\nfunction Ceil(const A: Double): Integer;\n\nbegin\n  // TODO: add Range check ?\n  Result:=trunc(JSCeil(a));\nend;\n\nfunction Floor(const A: Double): Integer;\n\nbegin\n  // TODO: add Range check ?\n  Result:=trunc(JSFloor(a));\nend;\n\nfunction Ceil64(const A: Double): NativeLargeInt;\n\nbegin\n  Result:=trunc(JSCeil(a));\nend;\n\nfunction Floor64(const A: Double): NativeLargeInt;\n\nbegin\n  Result:=trunc(JSCeil(a));\nend;\n\nprocedure Frexp(X: double; out Mantissa: double; out Exponent: integer);\n\nbegin\n  Exponent:=0;\n  if (X<>0) then\n    if (abs(X)<0.5) then\n      repeat\n        X:=X*2;\n        Dec(Exponent);\n      until (abs(X)>=0.5)\n    else\n      while (abs(X)>=1) do\n        begin\n        X:=X/2;\n        Inc(Exponent);\n        end;\n  Mantissa:=X;\nend;\n\nfunction LogN(const A, Base: Double): Double; \n\nbegin\n  Result:=Ln(A)/Ln(Base);\nend;\n\nfunction lnxp1(x: double): double;\n\nvar\n  y: float;\n\nbegin\n  if (x>=4.0) then\n    result:=ln(1.0+x)\n  else\n    begin\n    y:=1.0+x;\n    if (y=1.0) then\n      result:=x\n    else\n      begin\n      result:=ln(y);     { lnxp1(-1) = ln(0) = -Inf }\n      if y>0.0 then\n        result:=result+(x-(y-1.0))/y;\n      end;\n    end;\nend;\n\nfunction ldexp(x : double;const p : Integer) : double;\n\nbegin\n   result:=x*intpower(2.0,p);\nend;\n\n\nfunction IntPower(base: float; const exponent: Integer): double;\n\nvar\n  i : longint;\n\nbegin\n  if (base = 0.0) and (exponent = 0) then\n    result:=1\n  else\n    begin\n    i:=abs(exponent);\n    Result:=1.0;\n    while i>0 do\n      begin\n      while (i and 1)=0 do\n        begin\n        i:=i shr 1;\n        base:=sqr(base);\n        end;\n      i:=i-1;\n      Result:=Result*base;\n      end;\n    if exponent<0 then\n      Result:=1.0/Result;\n    end;\nend;\n\nprocedure DivMod(Dividend: LongInt; Divisor: Word; out Result, Remainder: Word);\nbegin\n  if Dividend < 0 then\n    begin\n    Dividend:=-Dividend;\n    Result:=-(Dividend Div Divisor);\n    Remainder:=-(Dividend+(Result*Divisor));\n    end\n  else\n    begin\n    Result:=Dividend Div Divisor;\n    Remainder:=Dividend-(Result*Divisor);\n    end;\nend;\n\n\nprocedure DivMod(Dividend: LongInt; Divisor: Word; out Result,\n  Remainder: SmallInt);\nbegin\n  if Dividend < 0 then\n    begin\n    Dividend:=-Dividend;\n    Result:=-(Dividend Div Divisor);\n    Remainder:=-(Dividend+(Result*Divisor));\n    end\n  else\n    begin\n    Result:=Dividend Div Divisor;\n    Remainder:=Dividend-(Result*Divisor);\n    end;\nend;\n\n\nprocedure DivMod(Dividend: DWord; Divisor: DWord; out Result, Remainder: DWord);\nbegin\n  Result:=Dividend Div Divisor;\n  Remainder:=Dividend-(Result*Divisor);\nend;\n\n\nprocedure DivMod(Dividend: LongInt; Divisor: LongInt; out Result,\n  Remainder: LongInt);\n\nbegin\n  if Dividend < 0 then\n    begin\n    Dividend:=-Dividend;\n    Result:=-(Dividend Div Divisor);\n    Remainder:=-(Dividend+(Result*Divisor));\n    end\n  else\n    begin\n    Result:=Dividend Div Divisor;\n    Remainder:=Dividend-(Result*Divisor);\n    end;\nend;\n\n{ ---------------------------------------------------------------------\n  Angle conversion\n  ---------------------------------------------------------------------}\nfunction DegToRad(deg: double): double;\n\nbegin\n  Result:=deg*(pi/180.0);\nend;\n\n\nfunction RadToDeg(rad: double): double;\n\nbegin\n  Result:=rad*(180.0/pi);\nend;\n\n\nfunction GradToRad(grad: double): double;\n\nbegin\n  Result:=grad*(pi/200.0);\nend;\n\n\nfunction RadToGrad(rad: double): double;\n\nbegin\n  Result:=rad*(200.0/pi);\nend;\n\n\nfunction DegToGrad(deg: double): double;\n\nbegin\n  Result:=deg*(200.0/180.0);\nend;\n\n\nfunction GradToDeg(grad: double): double;\n\nbegin\n  Result:=grad*(180.0/200.0);\nend;\n\n\nfunction CycleToRad(cycle: double): double;\n\nbegin\n  Result:=(2*pi)*cycle;\nend;\n\n\nfunction RadToCycle(rad: double): double;\n\nbegin\n  Result:=rad*(1/(2*pi));\nend;\n\n\nfunction DegNormalize(deg: double): double;\n\nbegin\n  Result:=Deg-Int(Deg/360)*360;\n  If (Result<0) then Result:=Result+360;\nend;\n\nfunction sumofsquares(const data : array of double) : double;\nvar\n  i,N : longint;\n\nbegin\n  N:=Length(Data);\n  Result:=0.0;\n  for i:=0 to N-1 do\n    Result:=Result+sqr(data[i]);\nend;\n\nfunction Norm(const data: array of double): double;\nbegin\n  Result:=sqrt(sumofsquares(data));\nend;\n\n{ ---------------------------------------------------------------------\n  Statistical functions\n  ---------------------------------------------------------------------}\n\nfunction Sum(const data: array of double): double;\n\nvar\n  i,N : longint;\n\nbegin\n  N:=Length(Data);\n  Result:=0.0;\n  for i:=0 to N-1 do\n    Result:=Result+data[i];\nend;\n\nfunction Mean(const data: array of double): double;\n\nVar\n  N : integer;\n\nbegin\n  N:=Length(Data);\n  if N=0 then\n    Result:=0\n  else\n    Result:=Sum(Data)/N;\nend;\nprocedure SumsAndSquares(const data: array of Double; out Sum,\n  SumOfSquares: double);\n\nvar\n  i,n : Integer;\n  t,s,ss: double;\n\nbegin\n  n:=length(Data);\n  ss:=0.0; // Use local vars, var is very inefficient in js\n  s:=0.0;\n  for i:=0 to N-1 do\n    begin\n    t:=data[i];\n    ss:=ss+sqr(t);\n    s:=s+t;\n    end;\n  Sum:=s;\n  SumOfSquares:=ss;\nend;\n\nfunction StdDev(const data: array of Double): float;\n\nbegin\n  Result:=Sqrt(Variance(Data));\nend;\n\nfunction Variance(const data: array of Double): double;\n\nvar\n  n : integer;\n\nbegin\n  N:=Length(Data);\n  If N=1 then\n    Result:=0\n  else\n    Result:=TotalVariance(Data)/(N-1);\nend;\n\nfunction TotalVariance(const data: array of Double): double;\n\nvar\n  S,SS : Float;\n  N : integer;\nbegin\n  N:=Length(Data);\n  If Length(Data)=1 then\n    Result:=0\n  else\n    begin\n    SumsAndSquares(Data,S,SS);\n    Result := SS-Sqr(S)/N;\n    end;\nend;\n\nprocedure MeanAndStdDev(const data: array of Double; out Mean, StdDev: double);\n\nVar\n  I,N : longint;\n  M,S : Double;\n\nbegin\n  N:=Length(Data);\n  M:=0;\n  S:=0;\n  For I:=0 to N-1 do\n    begin\n    M:=M+Data[i];\n    S:=S+Sqr(Data[i]);\n    end;\n  M:=M/N;\n  S:=(S-N*Sqr(M));\n  If N>1 then\n    S:=Sqrt(S/(N-1))\n  else\n    S:=0;\n  Mean:=M;\n  StdDev:=S;\nend;\n\nfunction PopNStdDev(const data : array of Double) : double;\n\nbegin\n  Result:=Sqrt(PopnVariance(Data));\nend;\n\nfunction PopNVariance(const data : array of Double) : double;\n\nVar\n  N : integer;\n\nbegin\n  N:=Length(Data);\n  if N=0 then\n    Result:=0\n  else\n    Result:=TotalVariance(Data)/N;\nend;\n\nprocedure MomentSkewKurtosis(const data: array of Double; out m1, m2, m3, m4, skew, kurtosis: double);\n\nvar\n  i,N: integer;\n  deviation, deviation2: double;\n  reciprocalN: float;\n  // Use local vars for all calculations, var is very slow\n  lm1, lm2, lm3, lm4, lskew, lkurtosis: double;\n\nbegin\n  N:=length(Data);\n  lm1 := 0;\n  reciprocalN := 1/N;\n  for i := 0 to N-1 do\n    lm1 := lm1 + data[i];\n  lm1 := reciprocalN * lm1;\n\n  lm2 := 0;\n  lm3 := 0;\n  lm4 := 0;\n  for i := 0 to N-1 do\n    begin\n    deviation := (data[i]-lm1);\n    deviation2 := deviation * deviation;\n    lm2 := lm2 + deviation2;\n    lm3 := lm3 + deviation2 * deviation;\n    lm4 := lm4 + deviation2 * deviation2;\n    end;\n  lm2 := reciprocalN * lm2;\n  lm3 := reciprocalN * lm3;\n  lm4 := reciprocalN * lm4;\n\n  lskew := lm3 / (sqrt(lm2)*lm2);\n  lkurtosis := lm4 / (lm2 * lm2);\n\n  m1:=lm1;\n  m2:=lm2;\n  m3:=lm3;\n  m4:=lm4;\n  skew:=lskew;\n  kurtosis:=lkurtosis;\nend;\n\n{ ---------------------------------------------------------------------\n  Financial functions\n  ---------------------------------------------------------------------}\n\nfunction FutureValue(ARate: double; NPeriods: Integer;\n  APayment, APresentValue: double; APaymentTime: TPaymentTime): double;\nvar\n  q, qn, factor: double;\nbegin\n  if ARate = 0 then\n    Result := -APresentValue - APayment * NPeriods\n  else begin\n    q := 1.0 + ARate;\n    qn := power(q, NPeriods);\n    factor := (qn - 1) / (q - 1);\n    if APaymentTime = ptStartOfPeriod then\n      factor := factor * q;\n    Result := -(APresentValue * qn + APayment*factor);\n  end;\nend;\n\nfunction InterestRate(NPeriods: Integer; APayment, APresentValue, AFutureValue: double;\n  APaymentTime: TPaymentTime): double;\n{ The interest rate cannot be calculated analytically. We solve the equation\n  numerically by means of the Newton method:\n  - guess value for the interest reate\n  - calculate at which interest rate the tangent of the curve fv(rate)\n    (straight line!) has the requested future vale.\n  - use this rate for the next iteration. }\nconst\n  DELTA = 0.001;\n  EPS = 1E-9;   // required precision of interest rate (after typ. 6 iterations)\n  MAXIT = 20;   // max iteration count to protect agains non-convergence\nvar\n  r1, r2, dr: double;\n  fv1, fv2: double;\n  iteration: Integer;\nbegin\n  iteration := 0;\n  r1 := 0.05;  // inital guess\n  repeat\n    r2 := r1 + DELTA;\n    fv1 := FutureValue(r1, NPeriods, APayment, APresentValue, APaymentTime);\n    fv2 := FutureValue(r2, NPeriods, APayment, APresentValue, APaymentTime);\n    dr := (AFutureValue - fv1) / (fv2 - fv1) * delta;  // tangent at fv(r)\n    r1 := r1 + dr;      // next guess\n    inc(iteration);\n  until (abs(dr) < EPS) or (iteration >= MAXIT);\n  Result := r1;\nend;\n\nfunction NumberOfPeriods(ARate, APayment, APresentValue, AFutureValue: double;\n  APaymentTime: TPaymentTime): double;\n{ Solve the cash flow equation (1) for q^n and take the logarithm }\nvar\n  q, x1, x2: double;\nbegin\n  if ARate = 0 then\n    Result := -(APresentValue + AFutureValue) / APayment\n  else begin\n    q := 1.0 + ARate;\n    if APaymentTime = ptStartOfPeriod then\n      APayment := APayment * q;\n    x1 := APayment - AFutureValue * ARate;\n    x2 := APayment + APresentValue * ARate;\n    if   (x2 = 0)                    // we have to divide by x2\n      or (sign(x1) * sign(x2) < 0)   // the argument of the log is negative\n    then\n      Result := Infinity\n    else begin\n      Result := ln(x1/x2) / ln(q);\n    end;\n  end;\nend;\n\nfunction Payment(ARate: double; NPeriods: Integer;\n  APresentValue, AFutureValue: double; APaymentTime: TPaymentTime): double;\nvar\n  q, qn, factor: double;\nbegin\n  if ARate = 0 then\n    Result := -(AFutureValue + APresentValue) / NPeriods\n  else begin\n    q := 1.0 + ARate;\n    qn := power(q, NPeriods);\n    factor := (qn - 1) / (q - 1);\n    if APaymentTime = ptStartOfPeriod then\n      factor := factor * q;\n    Result := -(AFutureValue + APresentValue * qn) / factor;\n  end;\nend;\n\nfunction PresentValue(ARate: double; NPeriods: Integer;\n  APayment, AFutureValue: double; APaymentTime: TPaymentTime): double;\nvar\n  q, qn, factor: double;\nbegin\n  if ARate = 0.0 then\n    Result := -AFutureValue - APayment * NPeriods\n  else begin\n    q := 1.0 + ARate;\n    qn := power(q, NPeriods);\n    factor := (qn - 1) / (q - 1);\n    if APaymentTime = ptStartOfPeriod then\n      factor := factor * q;\n    Result := -(AFutureValue + APayment*factor) / qn;\n  end;\nend;\n\n{ ---------------------------------------------------------------------\n  Miscellaneous\n  ---------------------------------------------------------------------}\n\nfunction IfThen(val: boolean; const ifTrue: integer; const ifFalse: integer): integer;\n\nbegin\n  if val then result:=iftrue else result:=iffalse;\nend;\n\nfunction IfThen(val: boolean; const ifTrue: double; const ifFalse: double): double;\n\nbegin\n  if val then result:=iftrue else result:=iffalse;\nend;\n\nfunction CompareValue(const A, B  : Integer): TValueRelationship;\n\nbegin\n  result:=GreaterThanValue;\n  if a=b then\n    result:=EqualsValue\n  else\n   if a<b then\n     result:=LessThanValue;\nend;\n\nfunction CompareValue(const A, B: NativeLargeInt): TValueRelationship;\n\nbegin\n  result:=GreaterThanValue;\n  if a=b then\n    result:=EqualsValue\n  else\n   if a<b then\n     result:=LessThanValue;\nend;\n\nfunction CompareValue(const A, B: NativeLargeUInt): TValueRelationship;\n\nbegin\n  result:=GreaterThanValue;\n  if a=b then\n    result:=EqualsValue\n  else\n   if a<b then\n     result:=LessThanValue;\nend;\n\nfunction CompareValue(const A, B: Double; delta: Double): TValueRelationship;\nbegin\n  result:=GreaterThanValue;\n  if abs(a-b)<=delta then\n    result:=EqualsValue\n  else\n   if a<b then\n     result:=LessThanValue;\nend;\n\nend.\n\n","{\n    This file is part of the Pas2JS run time library.\n    Copyright (C) 2019 Silvio Clecio (silvioprog)\n\n    Pascal mapping for ChartJS: https://www.chartjs.org\n\n    See the file COPYING.FPC, included in this distribution,\n    for details about the copyright.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n **********************************************************************}\n\nunit ChartJS;\n\n{$MODE OBJFPC}\n{$MODESWITCH EXTERNALCLASS}\n\ninterface\n\nuses\n  JS,\n  Web;\n\ntype\n  TChart = class;\n  TChartController = class;\n  TChartOptions = class;\n  TChartAnimationCallback = class;\n  TChartMoment = class;\n\n  { Chart Moment display formats class. }\n  TChartMomentDisplayFormats = class external name 'Object' (TJSObject)\n  public\n    millisecond: string;\n    second: string;\n    minute: string;\n    hour: string;\n    day: string;\n    week: string;\n    month: string;\n    quarter: string;\n    year: string;\n  end;\n\n  { Chart Moment time type. }\n  TChartMomentTime = JSValue;\n\n  { Chart Moment parser. }\n  TChartMomentParser = reference to function(const data: JSValue): TChartMoment;\n\n  { Chart Moment class. }\n  TChartMoment = class external name 'Object' (TJSObject)\n  public\n    { Sets how different time units are displayed. }\n    displayFormats: TChartMomentDisplayFormats;\n    { If true and the unit is set to 'week', then the first day of the week will\n      be Monday. Otherwise, it will be Sunday. }\n    isoWeekday: Boolean;\n    { If defined, this will override the data maximum. }\n    max: TChartMomentTime;\n    { If defined, this will override the data minimum. }\n    min: TChartMomentTime;\n    { Custom parser for dates. }\n    parser: string;\n    parser_: TChartMomentParser; external name 'parser';\n    { If defined, dates will be rounded to the start of this unit. See Time\n      Units below for the allowed units. }\n    round: string;\n    { The moment js format string to use for the tooltip. }\n    tooltipFormat: string;\n    { If defined, will force the unit to be a certain type. See Time Units\n      section below for details. }\n    unit_: string; external name 'unit';\n    { The number of units between grid lines. }\n    stepSize: NativeUInt;\n    { The minimum display format to be used for a time unit. }\n    minUnit: string;\n  end;\n\n  { Chart size. }\n  TChartSize = class external name 'Object' (TJSObject)\n  public\n    { Width of the chart. }\n    width: NativeUInt;\n    { Height of the chart. }\n    height: NativeUInt;\n  end;\n\n  { Dataset class. }\n  TChartDataset = class external name 'Object' (TJSObject)\n  public\n    { Chart type. }\n    type_: string; external name 'type';\n    { The label for the dataset which appears in the legend and tooltips. }\n    label_: string; external name 'label';\n    { If true, it represents a hidden dataset. }\n    hidden: Boolean;\n  end;\n\n  { Called when a resize occurs. }\n  TChartResizeEventHandler = reference to procedure(const chart: TChart;\n    const newSize: TChartSize);\n\n  { Hover class. }\n  TChartHover = class external name 'Object' (TJSObject)\n  public\n    { Called when any of the events fire. Called in the context of the chart and\n      passed the event and an array of active elements (bars, points, etc). }\n    onHover: TJSMouseEventHandler;\n    { Sets which elements appear in the tooltip. }\n    mode: string;\n    { If true, the hover mode only applies when the mouse position intersects an\n      item on the chart. }\n    intersect: Boolean;\n    { Can be set to 'x', 'y', or 'xy' to define which directions are used in\n      calculating distances. Defaults to 'x' for index mode and 'xy' in dataset\n      and nearest modes. }\n    axis: string;\n    { Duration in milliseconds it takes to animate hover style changes. }\n    animationDuration: NativeUInt;\n  end;\n\n  { Animation render event. }\n  TChartAnimationRenderEventHandler = reference to procedure(\n    const chart: TChart; const animation: TChartAnimationCallback);\n\n  { Animation event. }\n  TChartAnimationEventHandler = reference to procedure(\n    const animation: TChartAnimationCallback);\n\n  { Animation callbacks class. }\n  TChartAnimationCallback = class external name 'Object' (TJSObject)\n  public\n    { Chart object. }\n    chart: TChart;\n    { Current Animation frame number. }\n    currentStep: NativeUInt;\n    { Number of animation frames. }\n    numSteps: NativeUInt;\n    { Animation easing to use. }\n    easing: string;\n    { Function that renders the chart. }\n    render: TChartAnimationRenderEventHandler;\n    { User callback. }\n    onAnimationProgress: TChartAnimationEventHandler;\n    { User callback. }\n    onAnimationComplete: TChartAnimationEventHandler;\n  end;\n\n  { Animation configuration class. }\n  TChartAnimationConfiguration = class external name 'Object' (TJSObject)\n  public\n    { The number of milliseconds an animation takes. }\n    duration: NativeUInt;\n    { Easing function to use. }\n    easing: string;\n    { Callback called on each step of an animation. }\n    onProgress: TChartAnimationEventHandler;\n    { Callback called at the end of an animation. }\n    onComplete: TChartAnimationEventHandler;\n    { If true, the chart will animate in with a rotation animation. }\n    animateRotate: Boolean;\n    { If true, will animate scaling the chart from the center outwards. }\n    animateScale: Boolean;\n  end;\n\n  { Padding to add inside the chart. }\n  TChartPadding = class external name 'Object' (TJSObject)\n  public\n    top: NativeInt;\n    right: NativeInt;\n    bottom: NativeInt;\n    left:NativeInt;\n  end;\n\n  { Layout configuration class. }\n  TChartLayoutConfiguration = class external name 'Object' (TJSObject)\n  public\n    { The padding to add inside the chart. }\n    padding: NativeInt;\n    { The padding to add inside the chart. }\n    padding_: TChartPadding; external name 'padding';\n  end;\n\n  { Legend item class. }\n  TChartLegendItem = class external name 'Object' (TJSObject)\n  public\n    { Label that will be displayed. }\n    text: string;\n    { Fill style of the legend box. }\n    fillStyle: string;\n    { If true, this item represents a hidden dataset. Label will be rendered\n      with a strike-through effect. }\n    hidden: Boolean;\n    { For box border. See\n      https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap. }\n    lineCap: string;\n    { For box border. See\n      https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash. }\n    lineDash: array of NativeUInt;\n    lineDash_: TJSArray; external name 'lineDash';\n    { For box border. See\n      https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset. }\n    lineDashOffset: NativeUInt;\n    { For box border. See\n      https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin. }\n    lineJoin: string;\n    { Width of box border. }\n    lineWidth: NativeUInt;\n    { Stroke style of the legend box. }\n    strokeStyle: string;\n    { Point style of the legend box (only used if usePointStyle is true). }\n    pointStyle: string;\n  end;\n\n  { Legend click event. }\n  TChartLegendClickEventHandler = reference to procedure(\n    const ev: TJSMouseEvent; const legendItem: TChartLegendItem);\n\n  { Legend event handler. }\n  TChartLegendEventHandler = reference to function(\n    const legendItem: TChartLegendItem): TChartLegendItem;\n\n  { Legend label class. }\n  TChartLegendLabel = class external name 'Object' (TJSObject)\n  public\n    { Width of coloured box. }\n    boxWidth: NativeUInt;\n    { Font size of text. }\n    fontSize: NativeUInt;\n    { Font style of text. }\n    fontStyle: string;\n    { Color of text. }\n    fontColor: string;\n    { Font family of legend text. }\n    fontFamily: string;\n    { Padding between rows of colored boxes. }\n    padding: NativeInt;\n    { Generates legend items for each thing in the legend. Default\n      implementation returns the text + styling for the color box. }\n    generateLabels: TChartLegendEventHandler;\n    { Filters legend items out of the legend. Receives 2 parameters,\n      a Legend Item and the chart data. }\n    filter: TChartLegendEventHandler;\n    { Label style will match corresponding point style (size is based on\n      fontSize, boxWidth is not used in this case). }\n    usePointStyle: Boolean;\n  end;\n\n  { Legend configuration class. }\n  TChartLegendConfiguration = class external name 'Object' (TJSObject)\n  public\n    { Is the legend shown? }\n    display: Boolean;\n    { Position of the legend. }\n    position: string;\n    { Marks that this box should take the full width of the canvas (pushing down\n      other boxes). This is unlikely to need to be changed in day-to-day use. }\n    fullWidth: Boolean;\n    { A callback that is called when a click event is registered on a label\n      item. }\n    onClick: TChartLegendClickEventHandler;\n    { A callback that is called when a 'mousemove' event is registered on top of\n    a label item. }\n    onHover: TJSMouseEventHandler;\n    { Legend will show datasets in reverse order. }\n    reverse: Boolean;\n    { Legend weight. }\n    weight: NativeUInt;\n    { Legend label configuration. }\n    labels: TChartLegendLabel;\n  end;\n\n  { Title configuration class. }\n  TChartTitleConfiguration = class external name 'Object' (TJSObject)\n  public\n    { Is the title shown? }\n    display: Boolean;\n    { Position of title. }\n    position: string;\n    { Font size. }\n    fontSize: NativeUInt;\n    { Font family for the title text. }\n    fontFamily: string;\n    { Font color. }\n    fontColor: string;\n    { Font style. }\n    fontStyle: string;\n    { Number of pixels to add above and below the title text. }\n    padding: NativeInt;\n    { Height of an individual line of text. }\n    lineHeight: JSValue;\n    { Title text to display. If specified as an array, text is rendered on\n      multiple lines. }\n    text: string;\n    texts: TJSStringDynArray; external name 'text';\n    text_: TJSArray; external name 'text';\n  end;\n\n  { Tooltip item class. }\n  TChartTooltipItem = class external name 'Object' (TJSObject)\n  public\n    { X Value of the tooltip as a string. }\n    xLabel: String;\n    { Y value of the tooltip as a string. }\n    yLabel: String;\n    { Index of the dataset the item comes from. }\n    datasetIndex: NativeInt;\n    { Index of this data item in the dataset. }\n    index: NativeInt;\n    { X position of matching point. }\n    x: NativeInt;\n    { Y position of matching point. }\n    y: NativeInt;\n  end;\n\n  { Tooltip model body class. }\n  TChartTooltipModelBody = class external name 'Object' (TJSObject)\n  public\n    { Lines of text before the line with the color square. }\n    before: TJSStringDynArray;\n    { Lines of text to render as the main item with color square. }\n    lines: TJSStringDynArray;\n    { Lines of text to render after the main lines. }\n    after: TJSStringDynArray;\n  end;\n\n  { Tooltip model class. }\n  TChartTooltipModel = class external name 'Object' (TJSObject)\n  public\n    { The items that we are rendering in the tooltip. }\n    dataPoints: array of TChartTooltipItem;\n    dataPoints_: TJSArray; external name 'dataPoints';\n    { Positioning. }\n    xPadding: NativeInt;\n    yPadding: NativeInt;\n    xAlign: string;\n    yAlign: string;\n    { X and Y properties are the top left of the tooltip. }\n    x: NativeInt;\n    y: NativeInt;\n    width: NativeUInt;\n    height: NativeUInt;\n    { Where the tooltip points to. }\n    caretX: NativeInt;\n    caretY: NativeInt;\n    { Body\n       The body lines that need to be rendered.\n       Each object contains 3 parameters.\n       before: String[] // lines of text before the line with the color square.\n       lines: String[] // lines of text to render as the main item with color square.\n       after: String[] // lines of text to render after the main lines. }\n    body: array of TChartTooltipModelBody;\n    body_: TJSArray; external name 'body';\n    { Lines of text that appear after the title but before the body. }\n    beforeBody: TJSStringDynArray;\n    beforeBody_: TJSArray; external name 'beforeBody';\n    { Line of text that appear after the body and before the footer. }\n    afterBody: TJSStringDynArray;\n    afterBody_: TJSArray; external name 'afterBody';\n    bodyFontColor: string;\n    _bodyFontFamily: string;\n    _bodyFontStyle: string;\n    _bodyAlign: string;\n    bodyFontSize: NativeUInt;\n    bodySpacing: NativeInt;\n    { Title\n       lines of text that form the title. }\n    title: TJSStringDynArray;\n    title_: TJSArray; external name 'title';\n    titleFontColor: string;\n    _titleFontFamily: string;\n    _titleFontStyle: string;\n    titleFontSize: NativeUInt;\n    _titleAlign: string;\n    titleSpacing: NativeInt;\n    titleMarginBottom: NativeInt;\n    { Footer\n       lines of text that form the footer. }\n    footer: TJSStringDynArray;\n    footer_: TJSArray; external name 'footer';\n    footerFontColor: string;\n    _footerFontFamily: string;\n    _footerFontStyle: string;\n    footerFontSize: NativeUInt;\n    _footerAlign: string;\n    footerSpacing: NativeInt;\n    footerMarginTop: NativeInt;\n    { Appearance. }\n    caretSize: NativeUInt;\n    cornerRadius: NativeInt;\n    backgroundColor: string;\n    { Colors to render for each item in body[]. This is the color of the squares\n      in the tooltip. }\n    labelColors: TJSStringDynArray;\n    labelColors_: TJSArray; external name 'labelColors';\n    { 0 opacity is a hidden tooltip. }\n    opacity: NativeUInt;\n    legendColorBackground: string;\n    displayColors: Boolean;\n  end;\n\n  { Tooltips custom event handler. }\n  TChartTooltipsCustomEventHandler = reference to procedure(\n    const tooltipModel: TChartTooltipModel);\n\n  { Tooltip array event handler. }\n  TChartTooltipArrayEventHandler = reference to function(\n    const arr: array of TChartTooltipItem; const data: JSValue): string;\n\n  { Tooltip item event handler. }\n  TChartTooltipItemEventHandler = reference to function(\n    const item: TChartTooltipItem; const data: JSValue): string;\n\n  { Tooltip return colors class. }\n  TChartTooltipReturnColors = class external name 'Object' (TJSObject)\n  public\n    { Border color. }\n    borderColor: string;\n    { Background color. }\n    backgroundColor: string;\n  end;\n\n  { Tooltip colors event handler. }\n  TChartTooltipColorsEventHandler = reference to function(\n    const item: TChartTooltipItem;\n    const data: JSValue): TChartTooltipReturnColors;\n\n  { Tooltip callbacks class. }\n  TChartTooltipCallbacks = class external name 'Object' (TJSObject)\n  public\n    { Returns the text to render before the title. }\n    beforeTitle: TChartTooltipArrayEventHandler;\n    { Returns text to render as the title of the tooltip. }\n    title: TChartTooltipArrayEventHandler;\n    { Returns text to render after the title. }\n    afterTitle: TChartTooltipArrayEventHandler;\n    { Returns text to render before the body section. }\n    beforeBody: TChartTooltipArrayEventHandler;\n    { Returns text to render before an individual label. This will be called for\n      each item in the tooltip. }\n    beforeLabel: TChartTooltipItemEventHandler;\n    { Returns text to render for an individual item in the tooltip. }\n    label_: TChartTooltipItemEventHandler; external name 'label';\n    { Returns the colors to render for the tooltip item. }\n    labelColor: TChartTooltipColorsEventHandler;\n    { Returns the colors for the text of the label for the tooltip item. }\n    labelTextColor: TChartTooltipItemEventHandler;\n    { Returns text to render after an individual label. }\n    afterLabel: TChartTooltipItemEventHandler;\n    { Returns text to render after the body section. }\n    afterBody: TChartTooltipArrayEventHandler;\n    { Returns text to render before the footer section. }\n    beforeFooter: TChartTooltipArrayEventHandler;\n    { Returns text to render as the footer of the tooltip. }\n    footer: TChartTooltipArrayEventHandler;\n    { Text to render after the footer section. }\n    afterFooter: TChartTooltipArrayEventHandler;\n  end;\n\n  { Tooltip configuration class. }\n  TChartTooltipsConfiguration = class external name 'Object' (TJSObject)\n  public\n    { Are on-canvas tooltips enabled. }\n    enabled: Boolean;\n    { Custom tooltips allow you to hook into the tooltip rendering process so\n      that you can render the tooltip in your own custom way. Generally this is\n      used to create an HTML tooltip instead of an oncanvas one. }\n    custom: TChartTooltipsCustomEventHandler;\n    { Sets which elements appear in the tooltip. }\n    mode: string;\n    { If true, the tooltip mode applies only when the mouse position intersects\n      with an element. If false, the mode will be applied at all times. }\n    intersect: Boolean;\n    { The mode for positioning the tooltip. }\n    position: string;\n    { Tooltip callbacks. }\n    callbacks: TChartTooltipCallbacks;\n    { Allows sorting of tooltip items. }\n    itemSort: TJSArrayCompareEvent;\n    { Allows filtering of tooltip items. }\n    filter: TJSArrayCallback;\n    { Background color of the tooltip. }\n    backgroundColor: string;\n    { Title font. }\n    titleFontFamily: string;\n    { Title font size. }\n    titleFontSize: NativeUInt;\n    { Title font style. }\n    titleFontStyle: string;\n    { Title font color. }\n    titleFontColor: string;\n    { Spacing to add to top and bottom of each title line. }\n    titleSpacing: NativeInt;\n    { Margin to add on bottom of title section. }\n    titleMarginBottom: NativeInt;\n    { Body line font. }\n    bodyFontFamily: string;\n    { Body font size. }\n    bodyFontSize: NativeUInt;\n    { Body font style. }\n    bodyFontStyle: string;\n    { Body font color. }\n    bodyFontColor: string;\n    { Spacing to add to top and bottom of each tooltip item. }\n    bodySpacing: NativeInt;\n    { Footer font. }\n    footerFontFamily: string;\n    { Footer font size. }\n    footerFontSize: NativeUInt;\n    { Footer font style. }\n    footerFontStyle: string;\n    { Footer font color. }\n    footerFontColor: string;\n    { Spacing to add to top and bottom of each footer line. }\n    footerSpacing: NativeInt;\n    { Margin to add before drawing the footer. }\n    footerMarginTop: NativeInt;\n    { Padding to add on left and right of tooltip. }\n    xPadding: NativeInt;\n    { Padding to add on top and bottom of tooltip. }\n    yPadding: NativeInt;\n    { Extra distance to move the end of the tooltip arrow away from the tooltip\n      point. }\n    caretPadding: NativeInt;\n    { Size, in px, of the tooltip arrow. }\n    caretSize: NativeUInt;\n    { Radius of tooltip corner curves. }\n    cornerRadius: NativeInt;\n    { Color to draw behind the colored boxes when multiple items are in the\n      tooltip. }\n    multiKeyBackground: string;\n    { If true, color boxes are shown in the tooltip. }\n    displayColors: Boolean;\n    { Color of the border. }\n    borderColor: string;\n    { Size of the border. }\n    borderWidth: NativeUInt;\n  end;\n\n  { Element point class. }\n  TChartElementPoint = class external name 'Object' (TJSObject)\n  public\n    { Point radius. }\n    radius: NativeInt;\n    radius_: JSValue; external name 'radius';\n    { Point style. }\n    pointStyle: string;\n    { Point rotation (in degrees). }\n    rotation: NativeInt;\n    { Point fill color. }\n    backgroundColor: string;\n    backgroundColor_: JSValue; external name 'backgroundColor';\n    { Point stroke width. }\n    borderWidth: NativeUInt;\n    borderWidth_: JSValue; external name 'borderWidth';\n    { Point stroke color. }\n    borderColor: string;\n    borderColor_: JSValue; external name 'borderColor';\n    { Extra radius added to point radius for hit detection. }\n    hitRadius: NativeInt;\n    { Point radius when hovered. }\n    hoverRadius: NativeInt;\n    { Stroke width when hovered. }\n    hoverBorderWidth: NativeUInt;\n    hoverBorderWidth_: JSValue; external name 'hoverBorderWidth';\n    { Background colour when hovered. }\n    hoverBackgroundColor: string;\n    hoverBackgroundColor_: JSValue; external name 'hoverBackgroundColor';\n    { Border colour when hovered. }\n    hoverBorderColor: string;\n    hoverBorderColor_: JSValue; external name 'hoverBorderColor';\n  end;\n\n  { Element line class. }\n  TChartElementLine = class external name 'Object' (TJSObject)\n  public\n    { Bzier curve tension (0 for no Bzier curves). }\n    tension: Double;\n    { Line fill color. }\n    backgroundColor: string;\n    backgroundColor_: JSValue; external name 'backgroundColor';\n    { Line stroke width. }\n    borderWidth: NativeUInt;\n    borderWidth_: JSValue; external name 'borderWidth';\n    { Line stroke color. }\n    borderColor: string;\n    borderColor_: JSValue; external name 'borderColor';\n    { Line cap style. }\n    borderCapStyle: string;\n    { Line dash. }\n    borderDash: array of NativeInt;\n    borderDash_: TJSArray; external name 'borderDash';\n    { Line dash offset. }\n    borderDashOffset: NativeInt;\n    { Line join style. }\n    borderJoinStyle: string;\n    { true to keep Bzier control inside the chart, false for no restriction. }\n    capBezierPoints: Boolean;\n    { Fill location: 'zero', 'top', 'bottom', true (eq. 'zero') or false\n      (no fill). }\n    fill: JSValue;\n    { true to show the line as a stepped line (tension will be ignored). }\n    stepped: Boolean;\n  end;\n\n  { Element rectangle class. }\n  TChartElementRectangle = class external name 'Object' (TJSObject)\n  public\n    { Bar fill color. }\n    backgroundColor: string;\n    backgroundColor_: JSValue; external name 'backgroundColor';\n    { Bar stroke width. }\n    borderWidth: NativeUInt;\n    borderWidth_: JSValue; external name 'borderWidth';\n    { Bar stroke color. }\n    borderColor: string;\n    borderColor_: JSValue; external name 'borderColor';\n    { Skipped (excluded) border: 'bottom', 'left', 'top' or 'right'. }\n    borderSkipped: string;\n  end;\n\n  { Element arc class. }\n  TChartElementArc = class external name 'Object' (TJSObject)\n  public\n    { Arc fill color. }\n    backgroundColor: string;\n    backgroundColor_: JSValue; external name 'backgroundColor';\n    { Arc stroke color. }\n    borderColor: string;\n    borderColor_: JSValue; external name 'borderColor';\n    { Arc stroke width. }\n    borderWidth: NativeUInt;\n    borderWidth_: JSValue; external name 'borderWidth';\n  end;\n\n  { Elements configuration class. }\n  TChartElementsConfiguration = class external name 'Object' (TJSObject)\n  public\n    { Point configuration. }\n    point: TChartElementPoint;\n    { Line configuration. }\n    line: TChartElementLine;\n    { Rectangle configuration. }\n    rectangle: TChartElementRectangle;\n    { Arc configuration. }\n    arc: TChartElementArc;\n  end;\n\n  { Scale service class. }\n  TCharScaleService = class external name 'Object' (TJSObject)\n  public\n    (* Scale config defaults. *)\n    procedure registerScaleType(const type_: string;\n      const scaleConstructor, scaleDefaults: JSValue);\n    function getScaleConstructor(const type_: string): JSValue;\n    function getScaleDefaults(const type_: string): JSValue;\n    procedure updateScaleDefaults(const type_: string; const additions: JSValue);\n    procedure addScalesToLayout(chart: TChart);\n  end;\n\n  { Scale callback. }\n  TChartScaleCallback = reference to procedure(const axis: TJSObject);\n\n  { Scale callbacks class. }\n  TChartScaleCallbacks = class external name 'Object' (TJSObject)\n  public\n    { Callback called before the update process starts. }\n    beforeUpdate: TChartScaleCallback;\n    { Callback that runs before dimensions are set. }\n    beforeSetDimensions: TChartScaleCallback;\n    { Callback that runs after dimensions are set. }\n    afterSetDimensions: TChartScaleCallback;\n    { Callback that runs before data limits are determined. }\n    beforeDataLimits: TChartScaleCallback;\n    { Callback that runs after data limits are determined. }\n    afterDataLimits: TChartScaleCallback;\n    { Callback that runs before ticks are created. }\n    beforeBuildTicks: TChartScaleCallback;\n    { Callback that runs after ticks are created. Useful for filtering ticks. }\n    afterBuildTicks: TChartScaleCallback;\n    { Callback that runs before ticks are converted into strings. }\n    beforeTickToLabelConversion: TChartScaleCallback;\n    { Callback that runs after ticks are converted into strings. }\n    afterTickToLabelConversion: TChartScaleCallback;\n    { Callback that runs before tick rotation is determined. }\n    beforeCalculateTickRotation: TChartScaleCallback;\n    { Callback that runs after tick rotation is determined. }\n    afterCalculateTickRotation: TChartScaleCallback;\n    { Callback that runs before the scale fits to the canvas. }\n    beforeFit: TChartScaleCallback;\n    { Callback that runs after the scale fits to the canvas. }\n    afterFit: TChartScaleCallback;\n    { Callback that runs at the end of the update process. }\n    afterUpdate: TChartScaleCallback;\n  end;\n\n  { Scale class. }\n  TChartScaleConfiguration = class external name 'Object' (TJSObject)\n  public\n    { If set to false the axis is hidden from view. Overrides gridLines.display,\n      scaleLabel.display, and ticks.display. }\n    display: Boolean;\n    { Callback functions to hook into the axis lifecycle. }\n    callbacks: TChartScaleCallbacks;\n    { The weight used to sort the axis. Higher weights are further away from the\n      chart area. }\n    weight: NativeUInt;\n  end;\n\n  { Scales class. }\n  TChartScalesConfiguration = class external name 'Object' (TJSObject)\n  public\n    { xAxes properties. }\n    xAxes: array of JSValue;\n    xAxes_: TJSArray; external name 'xAxes';\n    { yAxes properties. }\n    yAxes: array of JSValue;\n    yAxes_: TJSArray; external name 'yAxes';\n  end;\n\n  { Base axes class. }\n  TChartAxes = class external name 'Object' (TChartDataset)\n  public\n    { Stacked chart. }\n    stacked: Boolean;\n  end;\n\n  { Scale grid line class. }\n  TChartScaleGridLine = class external name 'Object' (TJSObject)\n  public\n    { If false, do not display grid lines for this axis. }\n    display: Boolean;\n    { If true, gridlines are circular (on radar chart only). }\n    circular: Boolean;\n    { The color of the grid lines. If specified as an array, the first color applies to the first grid line, the second to the second grid line and so on. }\n    color: string;\n    colors: string; external name 'color';\n    color_: TJSArray; external name 'color';\n    { Length and spacing of dashes on grid lines. }\n    borderDash: NativeInt;\n    borderDashs: array of NativeInt; external name 'borderDash';\n    borderDash_: TJSArray; external name 'borderDash';\n    { Offset for line dashes. }\n    borderDashOffset: NativeInt;\n    { Stroke width of grid lines. }\n    lineWidth: NativeUInt;\n    lineWidths: array of NativeUInt; external name 'lineWidth';\n    lineWidth_: TJSArray; external name 'lineWidth';\n    { If true, draw border at the edge between the axis and the chart area. }\n    drawBorder: Boolean;\n    { If true, draw lines on the chart area inside the axis lines. This is\n      useful when there are multiple axes and you need to control which grid\n      lines are drawn. }\n    drawOnChartArea: Boolean;\n    { If true, draw lines beside the ticks in the axis area beside the chart. }\n    drawTicks: Boolean;\n    { Length in pixels that the grid lines will draw into the axis area. }\n    tickMarkLength: NativeUInt;\n    { Stroke width of the grid line for the first index (index 0). }\n    zeroLineWidth: NativeUInt;\n    { Stroke color of the grid line for the first index (index 0). }\n    zeroLineColor: string;\n    { Length and spacing of dashes of the grid line for the first\n      index (index 0). }\n    zeroLineBorderDash: NativeInt;\n    zeroLineBorderDashs: array of NativeInt; external name 'zeroLineBorderDash';\n    zeroLineBorderDash_: TJSArray; external name 'zeroLineBorderDash';\n    { Offset for line dashes of the grid line for the first index (index 0). }\n    zeroLineBorderDashOffset: NativeInt;\n    { If true, grid lines will be shifted to be between labels. This is set to\n      true for a category scale in a bar chart by default. }\n    offsetGridLines: Boolean;\n  end;\n\n  { Scale label class. }\n  TChartScaleLabel = class external name 'Object' (TJSObject)\n  public\n    { If true, display the axis title. }\n    display: Boolean;\n    { The text for the title. (i.e. \"# of People\" or \"Response Choices\"). }\n    labelString: string;\n    { Height of an individual line of text. }\n    lineHeight: JSValue;\n    { Font color for scale title. }\n    fontColor: string;\n    { Font family for the scale title, follows CSS font-family options. }\n    fontFamily: string;\n    { Font size for scale title. }\n    fontSize: NativeUInt;\n    { Font style for the scale title, follows CSS font-style options (i.e.\n      normal, italic, oblique, initial, inherit). }\n    fontStyle: string;\n    { Padding to apply around scale labels. Only top and bottom are\n      implemented. }\n    padding: JSValue;\n  end;\n\n  { Scale cartesian tick class. }\n  TChartScaleCartesianTick = class external name 'Object' (TChartAxes)\n  public\n    { If true, automatically calculates how many labels that can be shown and\n      hides labels accordingly. Turn it off to show all labels no matter what. }\n    autoSkip: Boolean;\n    { Padding between the ticks on the horizontal axis when autoSkip is enabled.\n      Note: Only applicable to horizontal scales. }\n    autoSkipPadding: NativeInt;\n    { Distance in pixels to offset the label from the centre point of the\n      tick (in the y direction for the x axis, and the x direction for the\n      y axis). Note: this can cause labels at the edges to be cropped by\n      the edge of the canvas. }\n    labelOffset: NativeInt;\n    { Maximum rotation for tick labels when rotating to condense labels.\n      Note: Rotation doesn't occur until necessary. Note: Only applicable to\n      horizontal scales. }\n    maxRotation: NativeInt;\n    { Minimum rotation for tick labels. Note: Only applicable to horizontal\n      scales. }\n    minRotation: NativeInt;\n    { Flips tick labels around axis, displaying the labels inside the chart\n      instead of outside. Note: Only applicable to vertical scales. }\n    mirror: Boolean;\n    { Padding between the tick label and the axis. When set on a vertical axis,\n      this applies in the horizontal (X) direction. When set on a horizontal\n      axis, this applies in the vertical (Y) direction. }\n    padding: NativeInt;\n  end;\n\n  { Scale cartesian class. }\n  TChartScaleCartesian = class external name 'Object' (TChartAxes)\n  public\n    { type (inherited):\n      Type of scale being employed. Custom scales can be created and registered\n      with a string key. This allows changing the type of an axis for a chart. }\n    { Position of the axis in the chart. Possible values are: 'top', 'left',\n      'bottom', 'right'. }\n    position: string;\n    { If true, extra space is added to the both edges and the axis is scaled to\n      fit into the chart area. This is set to true for a category scale in a bar\n      chart by default. }\n    offset: Boolean;\n    { The ID is used to link datasets and scale axes together. }\n    id: string;\n    { Grid lines configuration. }\n    gridLines: TChartScaleGridLine;\n    { Scale label configuration. }\n    scaleLabel: TChartScaleLabel;\n    { Tick configuration. }\n    ticks: TChartScaleCartesianTick;\n  end;\n\n  { Scale cartesian category tick class. }\n  TChartScaleCartesianCategoryTick = class external name 'Object' (TChartScaleCartesianTick)\n  public\n    { An array of labels to display. }\n    labels: TJSStringDynArray;\n    labels_: TJSArray; external name 'labels';\n    { The minimum item to display. }\n    min: string;\n    { The maximum item to display. }\n    max: string;\n  end;\n\n  { Scale cartesian linear tick class. }\n  TChartScaleCartesianLinearTick = class external name 'Object' (TChartScaleCartesianTick)\n  public\n    { If true, scale will include 0 if it is not already included. }\n    beginAtZero: Boolean;\n    { User defined minimum number for the scale, overrides minimum value from\n      data. }\n    min: NativeUInt;\n    { User defined maximum number for the scale, overrides maximum value from\n      data. }\n    max: NativeUInt;\n    { Maximum number of ticks and gridlines to show. }\n    maxTicksLimit: NativeUInt;\n    { If defined and stepSize is not specified, the step size will be rounded to\n      this many decimal places. }\n    precision: NativeInt;\n    { User defined fixed step size for the scale. }\n    stepSize: NativeUInt;\n    { Adjustment used when calculating the maximum data value. }\n    suggestedMax: NativeUInt;\n    { Adjustment used when calculating the minimum data value. }\n    suggestedMin: NativeUInt;\n  end;\n\n  { Scale cartesian logarithmic tick class. }\n  TChartScaleCartesianLogarithmicTick = class external name 'Object' (TChartScaleCartesianTick)\n  public\n    { User defined minimum number for the scale, overrides minimum value from\n      data. }\n    min: NativeUInt;\n    { User defined maximum number for the scale, overrides maximum value from\n      data. }\n    max: NativeUInt;\n  end;\n\n  { Scale cartesian time tick class. }\n  TChartScaleCartesianTimeTick = class external name 'Object' (TJSObject)\n  public\n    { How ticks are generated. }\n    source: string;\n  end;\n\n  { Scale cartesian time class. }\n  TChartScaleCartesianTime = class external name 'Object' (TChartScaleCartesianTick)\n  public\n    { Is the time shown? }\n    display: Boolean;\n    { How data is plotted. }\n    distribution: string;\n    { Determines the scale bounds. }\n    bounds: string;\n    {\n    ticks.source:\n      How ticks are generated. }\n    ticks: TChartScaleCartesianTimeTick;\n    {\n    time.displayFormats:\n      Sets how different time units are displayed. time.isoWeekday - If true and\n      the unit is set to 'week', then the first day of the week will be Monday.\n      Otherwise, it will be Sunday.\n    time.max:\n      If defined, this will override the data maximum.\n    time.min:\n      If defined, this will override the data minimum.\n    time.parser:\n      Custom parser for dates.\n    time.round:\n      If defined, dates will be rounded to the start of this unit. See Time\n      Units below for the allowed units.\n    time.tooltipFormat:\n      The moment js format string to use for the tooltip.\n    time.unit:\n      If defined, will force the unit to be a certain type. See Time Units\n      section below for details.\n    time.stepSize:\n      The number of units between grid lines.\n    time.minUnit:\n      The minimum display format to be used for a time unit.\n    }\n    time: TChartMoment;\n  end;\n\n  { Scale radial linear point label class. }\n  TChartScaleRadialLinearPointLabel = class external name 'Object' (TChartAxes)\n  public\n    { Callback function to transform data labels to point labels. The default\n      implementation simply returns the current string. }\n    callback: TJSPromiseResolver;\n    { Font color for point labels. }\n    fontColor: string;\n    fontColors: TJSStringDynArray; external name 'fontColor';\n    fontColor_: TJSArray; external name 'fontColor';\n    { Font family to use when rendering labels. }\n    fontFamily: string;\n    { Font size in pixels. }\n    fontSize: NativeUInt;\n    { Font style to use when rendering point labels. }\n    fontStyle: string;\n  end;\n\n  { Scale radial linear tick class. }\n  TChartScaleRadialLinearTick = class external name 'Object' (TChartAxes)\n  public\n    { Color of label backdrops. }\n    backdropColor: string;\n    { Horizontal padding of label backdrop. }\n    backdropPaddingX: NativeInt;\n    { Vertical padding of label backdrop. }\n    backdropPaddingY: NativeInt;\n    { If true, scale will include 0 if it is not already included. }\n    beginAtZero: Boolean;\n    { User defined minimum number for the scale, overrides minimum value from\n      data. }\n    min: NativeUInt;\n    { User defined maximum number for the scale, overrides maximum value from\n      data. }\n    max: NativeUInt;\n    { Maximum number of ticks and gridlines to show. }\n    maxTicksLimit: NativeUInt;\n    { If defined and stepSize is not specified, the step size will be rounded to\n      this many decimal places. }\n    precision: NativeInt;\n    { User defined fixed step size for the scale. }\n    stepSize: NativeUInt;\n    { Adjustment used when calculating the maximum data value. }\n    suggestedMax: NativeUInt;\n    { Adjustment used when calculating the minimum data value. }\n    suggestedMin: NativeUInt;\n    { If true, draw a background behind the tick labels. }\n    showLabelBackdrop: Boolean;\n  end;\n\n  { Scale radial linear angle line class. }\n  TChartScaleRadialLinearAngleLine = class external name 'Object' (TChartAxes)\n  public\n    { If true, angle lines are shown. }\n    display: Boolean;\n    { Color of angled lines. }\n    color: string;\n    { Width of angled lines. }\n    lineWidth: NativeUInt;\n  end;\n\n  { Scale radial linear class. }\n  TChartScaleRadialLinear = class external name 'Object' (TChartAxes)\n  public\n    { Angle line configuration. }\n    angleLines: TChartScaleRadialLinearAngleLine;\n    { Grid line configuration. }\n    gridLines: TChartScaleGridLine;\n    { Point label configuration. }\n    pointLabels: TChartScaleRadialLinearAngleLine;\n    { Tick configuration. }\n    ticks: TChartScaleRadialLinearTick;\n  end;\n\n  { Plugins hook argument class. }\n  TChartPluginsHookArgument = class external name 'Object' (TJSObject)\n  public\n    { The dataset index. }\n    index: NativeInt;\n    { The dataset metadata. }\n    meta: TJSObject;\n    { The current animation value, between 0.0 and 1.0. }\n    easingValue: Double;\n  end;\n\n{$PUSH}{$WARN 4501 OFF}\n\n  { Plugins hook class. }\n  TChartPluginsHook = class(TJSObject)\n  public\n    { Creates an instance of TChartPluginsHook. }\n    constructor new;\n    { Called before initializing chart. }\n    procedure beforeInit(chart: TChartController;\n      options: TChartOptions); virtual;\n    { Called after chart has been initialized and before the first update. }\n    procedure afterInit(chart: TChartController;\n      options: TChartOptions); virtual;\n    { Called before updating chart. If any plugin returns false, the update. }\n    function beforeUpdate(chart: TChartController;\n      options: TChartOptions): Boolean; virtual;\n    { Called after chart has been updated and before rendering. Note that this\n      hook will not be called if the chart update has been previously cancelled. }\n    procedure afterUpdate(chart: TChartController;\n      options: TChartOptions); virtual;\n    { Called before updating the chart datasets. If any plugin returns false,\n      the datasets update is cancelled until another update is triggered. }\n    function beforeDatasetsUpdate(chart: TChartController;\n      options: TChartOptions): Boolean; virtual;\n    { Called after the chart datasets have been updated. Note that this hook\n      will not be called if the datasets update has been previously cancelled. }\n    procedure afterDatasetsUpdate(chart: TChartController;\n      options: TChartOptions); virtual;\n    { Called before updating the chart dataset at the given args.index. If any\n      plugin returns false, the datasets update is cancelled until another\n      update is triggered. }\n    function beforeDatasetUpdate(chart: TChartController;\n      const args: TChartPluginsHookArgument;\n      options: TChartOptions): Boolean; virtual;\n    { Called after the chart datasets at the given args.index has been updated.\n      Note that this hook will not be called if the datasets update has been\n      previously cancelled. }\n    procedure afterDatasetUpdate(chart: TChartController;\n      const args: TChartPluginsHookArgument; options: TChartOptions); virtual;\n    { Called before laying out chart. If any plugin returns false, the layout\n      update is cancelled until another update is triggered. }\n    function beforeLayout(chart: TChartController;\n      options: TChartOptions): Boolean; virtual;\n    { Called after the chart has been layed out. Note that this hook will not be\n      called if the layout update has been previously cancelled. }\n    procedure afterLayout(chart: TChartController;\n      options: TChartOptions); virtual;\n    { Called before rendering chart. If any plugin returns false, the rendering\n      is cancelled until another render is triggered. }\n    function beforeRender(chart: TChartController;\n      options: TChartOptions): Boolean; virtual;\n    { Called after the chart has been fully rendered (and animation completed).\n      Note that this hook will not be called if the rendering has been\n      previously cancelled. }\n    procedure afterRender(chart: TChartController;\n      options: TChartOptions); virtual;\n    { Called before drawing chart at every animation frame specified by the\n      given easing value. If any plugin returns false, the frame drawing is\n      cancelled until another render is triggered. }\n    function beforeDraw(chart: TChartController; easingValue: NativeInt;\n      options: TChartOptions): Boolean; virtual;\n    { Called after the chart has been drawn for the specific easing value.\n      Note that this hook will not be called if the drawing has been previously\n      cancelled. }\n    procedure afterDraw(chart: TChartController; easingValue: NativeInt;\n      options: TChartOptions); virtual;\n    { Called before drawing the chart datasets. If any plugin returns false, the\n      datasets drawing is cancelled until another render is triggered. }\n    function beforeDatasetsDraw(chart: TChartController; easingValue: NativeInt;\n      options: TChartOptions): Boolean; virtual;\n    { Called after the chart datasets have been drawn. Note that this hook will\n      not be called if the datasets drawing has been previously cancelled. }\n    procedure afterDatasetsDraw(chart: TChartController; easingValue: NativeInt;\n      options: TChartOptions); virtual;\n    { Called before drawing the chart dataset at the given args.index (datasets\n      are drawn in the reverse order). If any plugin returns false, the datasets\n      drawing is cancelled until another render is triggered. }\n    function beforeDatasetDraw(chart: TChartController;\n      const args: TChartPluginsHookArgument;\n      options: TChartOptions): Boolean; virtual;\n    { Called after the chart datasets at the given args.index have been drawn\n      (datasets are drawn in the reverse order). Note that this hook will not be\n      called if the datasets drawing has been previously cancelled. }\n    procedure afterDatasetDraw(chart: TChartController;\n      const args: TChartPluginsHookArgument; options: TChartOptions); virtual;\n    { Called before drawing the tooltip. If any plugin returns false, the\n      tooltip drawing is cancelled until another render is triggered. }\n    function beforeTooltipDraw(chart: TChartController;\n      const args: TChartPluginsHookArgument;\n      options: TChartOptions): Boolean; virtual;\n    { Called after drawing the tooltip. Note that this hook will not be called\n      if the tooltip drawing has been previously cancelled. }\n    procedure afterTooltipDraw(chart: TChartController;\n      const args: TChartPluginsHookArgument; options: TChartOptions); virtual;\n    { Called before processing the specified event. If any plugin returns false,\n      the event will be discarded. }\n    procedure beforeEvent(chart: TChartController; event: TJSEvent;\n      options: TChartOptions); virtual;\n    { Called after the event has been consumed. Note that this hook will not be\n      called if the event has been previously discarded. }\n    procedure afterEvent(chart: TChartController; event: TJSEvent;\n      options: TChartOptions); virtual;\n    { Called after the chart as been resized. }\n    procedure resize(chart: TChartController; size: NativeInt;\n      options: TChartOptions); virtual;\n    { Called after the chart as been destroyed. }\n    procedure destroy(chart: TChartController; options: TChartOptions); virtual;\n  end;\n\n{$POP}\n\n  { Plugins class. }\n  TChartPlugins = class external name 'Chart' (TJSObject)\n  public\n    { Registers the given plugin(s) if not already registered. }\n    procedure register(plugin: TChartPlugins); overload;\n    procedure register(plugin: TJSObject); overload;\n    procedure register(plugin: TJSArray); overload;\n    { Unregisters the given plugin(s) only if registered. }\n    procedure unregister(plugin: TChartPlugins); overload;\n    procedure unregister(plugin: TJSObject); overload;\n    procedure unregister(plugin: TJSArray); overload;\n    { Remove all registered plugins. }\n    procedure clear;\n    { Returns the number of registered plugins. }\n    function count: NativeUInt;\n    { Returns all registered plugin instances. }\n    function getAll: TJSArray;\n    { Calls enabled plugins for `chart` on the specified hook and with the given\n      args. This method immediately returns as soon as a plugin explicitly\n      returns false. The returned value can be used, for instance, to interrupt\n      the current action. }\n    function notify(chart: TChart; const hook: string;\n      const args: TJSArray): Boolean; overload;\n    function notify(chart: TChart; const hook: string): Boolean; varargs; overload;\n  end;\n\n  { Plugins filler class. }\n  TChartPluginsFiller = class external name 'Object' (TJSObject)\n  public\n    { Fill propagation when target is hidden. }\n    propagate: Boolean;\n  end;\n\n  { Plugins configuration class. }\n  TChartPluginsConfiguration = class external name 'Object' (TChartPlugins)\n  public\n    { Filler properties. }\n    filler: TChartPluginsFiller;\n  end;\n\n  { Options context class. }\n  TChartOptionsContext = class external name 'Object' (TJSObject)\n  public\n    { The associated chart. }\n    chart: TChartController;\n    { Index of the current data. }\n    dataIndex: NativeInt;\n    { Dataset at index datasetIndex. }\n    dataset: TChartDataset;\n    { Index of the current dataset. }\n    datasetIndex: NativeInt;\n  end;\n\n  { Options class. }\n  TChartOptions = class external name 'Object' (TJSObject)\n  public\n    { Resizes the chart canvas when its container does. }\n    responsive: Boolean;\n    { Duration in milliseconds it takes to animate to new size after a resize\n      event. }\n    responsiveAnimationDuration: NativeUInt;\n    { Maintain the original canvas aspect ratio (width / height) when resizing. }\n    maintainAspectRatio: Boolean;\n    { Canvas aspect ratio (i.e. width / height, a value of 1 representing a\n      square canvas). Note that this option is ignored if the height is\n      explicitly defined either as attribute or via the style. }\n    aspectRatio: NativeInt;\n    { Called when a resize occurs. Gets passed two arguments: the chart instance\n      and the new size. }\n    onResize: TChartResizeEventHandler;\n    { Override the window's default devicePixelRatio. }\n    devicePixelRatio: NativeInt;\n    { Configure hover properties. }\n    hover: TChartHover;\n    { The events option defines the browser events that the chart should listen\n      to for tooltips and hovering. }\n    events: TJSStringDynArray;\n    events_: TJSArray; external name 'events';\n    { Called when any of the events fire. Called in the context of the chart and\n      passed the event and an array of active elements (bars, points, etc). }\n    onHover: TJSMouseEventHandler;\n    { Called if the event is of type 'mouseup' or 'click'. Called in the context\n      of the chart and passed the event and an array of active elements. }\n    onClick: THTMLClickEventHandler;\n    { Default color used in chart colors. }\n    defaultColor: string;\n    { Default font color for all text. }\n    defaultFontColor: string;\n    { Default font family for all text. }\n    defaultFontFamily: string;\n    { Default font size (in px) for text. Does not apply to radialLinear scale\n      point labels. }\n    defaultFontSize: NativeUInt;\n    { Default font style. Does not apply to tooltip title or footer. Does not\n      apply to chart title. }\n    defaultFontStyle: string;\n    { Default line height for all lines. }\n    defaultLineHeight: JSValue;\n    { If false, the lines between points are not drawn. }\n    showLines: Boolean;\n    { Configure animation properties. }\n    animation: TChartAnimationConfiguration;\n    animation_: JSValue; external name 'animation';\n    { Configure layout properties. }\n    layout: TChartLayoutConfiguration;\n    layout_: JSValue; external name 'layout';\n    { Default legend properties. }\n    legend: TChartLegendConfiguration;\n    legend_: JSValue; external name 'legend';\n    { Configure title properties. }\n    title: TChartTitleConfiguration;\n    title_: JSValue; external name 'title';\n    { Configure tooltip properties. }\n    tooltips: TChartTooltipsConfiguration;\n    tooltips_: JSValue; external name 'tooltips';\n    { Configure elements properties. }\n    elements: TChartElementsConfiguration;\n    elements_: JSValue; external name 'elements';\n    { Configure chart scale. }\n    scale: TChartScaleConfiguration;\n    scale_: JSValue; external name 'scale';\n    { Configure chart scales. }\n    scales: TChartScalesConfiguration;\n    scales_: JSValue; external name 'scales';\n    { Configure plugins properties. }\n    plugins: TChartPluginsConfiguration;\n    plugins_: JSValue; external name 'plugins';\n  end;\n\n  { X/Y data class. }\n  TChartXYData = class(TJSObject)\n  public\n    { X value. }\n    x: JSValue;\n    x_: Double; external name 'x';\n    { Y value. }\n    y: JSValue;\n    y_: Double; external name 'y';\n    { Creates an instance of TChartXYData. }\n    constructor new(const x, y: JSValue); overload;\n    constructor new(const x: JSValue); overload;\n  end;\n\n  { T/Y data class. }\n  TChartTYData = class(TJSObject)\n  public\n    { T value. }\n    t: JSValue;\n    t_: Double; external name 't';\n    { Y value. }\n    y: JSValue;\n    y_: Double; external name 'y';\n    { Creates an instance of TChartTYData. }\n    constructor new(const t, y: JSValue); overload;\n    constructor new(const t: JSValue); overload;\n  end;\n\n  { X/Y/R data class. }\n  TChartXYRData = class(TJSObject)\n  public\n    { X value. }\n    x: JSValue;\n    x_: Double; external name 'x';\n    { Y value. }\n    y: JSValue;\n    y_: Double; external name 'y';\n    { R value. }\n    r: JSValue;\n    r_: Double; external name 'e';\n    { Creates an instance of TChartXYRData. }\n    constructor new(const x, y, r: JSValue); overload;\n    constructor new(const x, y: JSValue); overload;\n    constructor new(const x: JSValue); overload;\n  end;\n\n  { X/Y/V data class. }\n  TChartXYVData = class(TJSObject)\n  public\n    { X value. }\n    x: JSValue;\n    x_: Double; external name 'x';\n    { Y value. }\n    y: JSValue;\n    y_: Double; external name 'y';\n    { V value. }\n    v: JSValue;\n    v_: Double; external name 'v';\n    { Creates an instance of TChartXYVData. }\n    constructor new(const x, y, v: JSValue); overload;\n    constructor new(const x, y: JSValue); overload;\n    constructor new(const x: JSValue); overload;\n  end;\n\n  { Data class. }\n  TChartData = class external name 'Object' (TJSObject)\n  public\n    { Label array passed to the chart. }\n    labels: TJSStringDynArray;\n    labels_: TJSArray; external name 'labels';\n    { Dataset array passed to the chart. }\n    datasets: array of TChartDataset;\n    datasets_: TJSArray; external name 'datasets';\n  end;\n\n  { Configuration class. }\n  TChartConfiguration = class external name 'Object' (TJSObject)\n  public\n    { Chart type. }\n    type_: string; external name 'type';\n    { Chart data. }\n    data: TChartData;\n    { Chart options. }\n    options: TChartOptions;\n    { Plugins options. }\n    plugins: array of TChartPlugins;\n    plugins_: TJSArray; external name 'plugins';\n  end;\n\n  { Line dataset class. }\n  TChartLineDataset = class external name 'Object' (TChartDataset)\n  public\n    { The ID of the x axis to plot this dataset on. If not specified, this\n      defaults to the ID of the first found x axis. }\n    xAxisID: string;\n    { The ID of the y axis to plot this dataset on. If not specified, this\n      defaults to the ID of the first found y axis. }\n    yAxisID: string;\n    { The fill color under the line. }\n    backgroundColor: string;\n    { The color of the line. }\n    borderColor: string;\n    { The width of the line in pixels. }\n    borderWidth: NativeUInt;\n    { Length and spacing of dashes. }\n    borderDash: array of NativeInt;\n    borderDash_: TJSArray; external name 'borderDash';\n    { Offset for line dashes. }\n    borderDashOffset: NativeInt;\n    { Cap style of the line. }\n    borderCapStyle: string;\n    { Line joint style. }\n    borderJoinStyle: string;\n    { Algorithm used to interpolate a smooth curve from the discrete data\n      points. }\n    cubicInterpolationMode: string;\n    { How to fill the area under the line. }\n    fill: JSValue;\n    { Bezier curve tension of the line. Set to 0 to draw straightlines. This\n      option is ignored if monotone cubic interpolation is used. }\n    lineTension: Double;\n    { The fill color for points. }\n    pointBackgroundColor: string;\n    pointBackgroundColors: TJSStringDynArray; external name 'pointBackgroundColor';\n    pointBackgroundColor_: TJSArray; external name 'pointBackgroundColor';\n    { The border color for points. }\n    pointBorderColor: string;\n    pointBorderColors: TJSStringDynArray; external name 'pointBorderColor';\n    pointBorderColor_: TJSArray; external name 'pointBorderColor';\n    { The width of the point border in pixels. }\n    pointBorderWidth: NativeUInt;\n    pointBorderWidths: array of NativeUInt; external name 'pointBorderWidth';\n    pointBorderWidth_: TJSArray; external name 'pointBorderWidth';\n    { The radius of the point shape. If set to 0, the point is not rendered. }\n    pointRadius: NativeInt;\n    pointRadiuses: array of NativeInt; external name 'pointRadius';\n    pointRadius_: TJSArray; external name 'pointRadius';\n    { Style of the point. }\n    pointStyle: string;\n    pointStyles: TJSStringDynArray; external name 'pointStyle';\n    pointStyle_: TJSArray; external name 'pointStyle';\n    pointStyleImage: TJSObject; external name 'pointStyle';\n    pointStyleImage_: TJSObjectDynArray; external name 'pointStyle';\n    { The rotation of the point in degrees. }\n    pointRotation: NativeInt;\n    pointRotations: array of NativeInt; external name 'pointRotation';\n    pointRotation_: TJSArray; external name 'pointRotation';\n    { The pixel size of the non-displayed point that reacts to mouse events. }\n    pointHitRadius: NativeInt;\n    pointHitRadiuses: array of NativeInt; external name 'pointHitRadius';\n    pointHitRadius_: TJSArray; external name 'pointHitRadius';\n    { Point background color when hovered. }\n    pointHoverBackgroundColor: string;\n    pointHoverBackgroundColors: TJSStringDynArray; external name 'pointHoverBackgroundColor';\n    pointHoverBackgroundColor_: TJSArray; external name 'pointHoverBackgroundColor';\n    { Point border color when hovered. }\n    pointHoverBorderColor: string;\n    pointHoverBorderColors: TJSStringDynArray; external name 'pointHoverBorderColor';\n    pointHoverBorderColor_: TJSArray; external name 'pointHoverBorderColor';\n    { Border width of point when hovered. }\n    pointHoverBorderWidth: NativeUInt;\n    pointHoverBorderWidths: array of NativeUInt; external name 'pointHoverBorderWidth';\n    pointHoverBorderWidth_: TJSArray; external name 'pointHoverBorderWidth';\n    { The radius of the point when hovered. }\n    pointHoverRadius: NativeInt;\n    pointHoverRadiuses: array of NativeInt; external name 'pointHoverRadius';\n    pointHoverRadius_: TJSArray; external name 'pointHoverRadius';\n    { If false, the line is not drawn for this dataset. }\n    showLine: Boolean;\n    { If true, lines will be drawn between points with no or null data. If\n      false, points with NaN data will create a break in the line. }\n    spanGaps: Boolean;\n    { If the line is shown as a stepped line. }\n    steppedLine: Boolean;\n    steppedLine_: string; external name 'steppedLine';\n    { Array data passed to the chart. }\n    data: array of Integer;\n    datas: array of TChartXYData; external name 'data';\n    data_: TJSArray; external name 'data';\n  end;\n\n  { Line options class. }\n  TChartLineOptions = class external name 'Object' (TJSObject)\n  public\n    { If false, the lines between points are not drawn. }\n    showLines: Boolean;\n    { If false, NaN data causes a break in the line. }\n    spanGaps: Boolean;\n  end;\n\n  { Bar dataset class. }\n  TChartBarDataset = class external name 'Object' (TChartDataset)\n  public\n    { The ID of the x axis to plot this dataset on. If not specified, this\n      defaults to the ID of the first found x axis. }\n    xAxisID: string;\n    { The ID of the y axis to plot this dataset on. If not specified, this\n      defaults to the ID of the first found y axis. }\n    yAxisID: string;\n    { The fill color of the bar. }\n    backgroundColor: string;\n    backgroundColors: TJSStringDynArray; external name 'backgroundColor';\n    backgroundColor_: TJSArray; external name 'backgroundColor';\n    { The color of the bar border. }\n    borderColor: string;\n    borderColors: TJSStringDynArray; external name 'borderColor';\n    borderColor_: TJSArray; external name 'borderColor';\n    { The stroke width of the bar in pixels. }\n    borderWidth: NativeUInt;\n    borderWidths: array of NativeUInt; external name 'borderWidth';\n    borderWidth_: TJSArray; external name 'borderWidth';\n    { Which edge to skip drawing the border for. }\n    borderSkipped: string;\n    { The fill colour of the bars when hovered. }\n    hoverBackgroundColor: string;\n    hoverBackgroundColors: TJSStringDynArray; external name 'hoverBackgroundColor';\n    hoverBackgroundColor_: TJSArray; external name 'hoverBackgroundColor';\n    { The stroke colour of the bars when hovered. }\n    hoverBorderColor: string;\n    hoverBorderColors: TJSStringDynArray; external name 'hoverBorderColor';\n    hoverBorderColor_: TJSArray; external name 'hoverBorderColor';\n    { The stroke width of the bars when hovered. }\n    hoverBorderWidth: NativeUInt;\n    hoverBorderWidths: array of NativeUInt; external name 'hoverBorderWidth';\n    hoverBorderWidth_: TJSArray; external name 'hoverBorderWidth';\n    { The ID of the group to which this dataset belongs to (when stacked, each\n      group will be a separate stack). }\n    stack: string;\n    { Array data passed to the chart. }\n    data: array of Integer;\n    datas: array of TChartXYData; external name 'data';\n    data_: TJSArray; external name 'data';\n  end;\n\n  { Bar options class. }\n  TChartBarOptions = class external name 'Object' (TJSObject)\n  public\n    { Percent (0-1) of the available width each bar should be within the\n      category width. 1.0 will take the whole category width and put the bars\n      right next to each other. }\n    barPercentage: Double;\n    { Percent (0-1) of the available width each category should be within the\n      sample width. }\n    categoryPercentage: Double;\n    { Manually set width of each bar in pixels. If set to 'flex', it computes\n      \"optimal\" sample widths that globally arrange bars side by side. If not\n      set (default), bars are equally sized based on the smallest interval. }\n    barThickness: JSValue;\n    { Set this to ensure that bars are not sized thicker than this. }\n    maxBarThickness: NativeInt;\n    {\n    gridLines.offsetGridLines:\n      If true, the bars for a particular data point fall between the grid lines.\n      The grid line will move to the left by one half of the tick interval. If\n      false, the grid line will go right down the middle of the bars. }\n    gridLines: TChartScaleGridLine;\n  end;\n\n  { Radar dataset class. }\n  TChartRadarDataset = class external name 'Object' (TChartDataset)\n  public\n    { The fill color under the line. }\n    backgroundColor: string;\n    backgroundColor_: JSValue; external name 'backgroundColor';\n    { The color of the line. }\n    borderColor: string;\n    borderColor_: JSValue; external name 'borderColor';\n    { The width of the line in pixels. }\n    borderWidth: NativeUInt;\n    borderWidth_: JSValue; external name 'borderWidth';\n    { Length and spacing of dashes. }\n    borderDash: array of NativeInt;\n    borderDash_: TJSArray; external name 'borderDash';\n    { Offset for line dashes. }\n    borderDashOffset: NativeInt;\n    { Cap style of the line. }\n    borderCapStyle: string;\n    { Line joint style. }\n    borderJoinStyle: string;\n    { How to fill the area under the line. }\n    fill: JSValue;\n    { Bezier curve tension of the line. Set to 0 to draw straightlines. }\n    lineTension: NativeInt;\n    { The fill color for points. }\n    pointBackgroundColor: string;\n    pointBackgroundColors: TJSStringDynArray; external name 'pointBackgroundColor';\n    pointBackgroundColor_: TJSArray; external name 'pointBackgroundColor';\n    { The border color for points. }\n    pointBorderColor: string;\n    pointBorderColors: TJSStringDynArray; external name 'pointBorderColor';\n    pointBorderColor_: TJSArray; external name 'pointBorderColor';\n    { The width of the point border in pixels. }\n    pointBorderWidth: NativeUInt;\n    pointBorderWidths: array of NativeUInt; external name 'pointBorderWidth';\n    pointBorderWidth_: TJSArray; external name 'pointBorderWidth';\n    { The radius of the point shape. If set to 0, the point is not rendered. }\n    pointRadius: NativeInt;\n    pointRadiuses: array of NativeInt; external name 'pointRadius';\n    pointRadius_: TJSArray; external name 'pointRadius';\n    { The rotation of the point in degrees. }\n    pointRotation: NativeInt;\n    pointRotations: array of NativeInt; external name 'pointRotation';\n    pointRotation_: TJSArray; external name 'pointRotation';\n    { Style of the point. }\n    pointStyle: string;\n    pointStyles: TJSStringDynArray; external name 'pointStyle';\n    pointStyle_: TJSArray; external name 'pointStyle';\n    pointStyleImage: TJSObject; external name 'pointStyle';\n    pointStyleImage_: TJSObjectDynArray; external name 'pointStyle';\n    { The pixel size of the non-displayed point that reacts to mouse events. }\n    pointHitRadius: NativeInt;\n    pointHitRadiuses: array of NativeInt; external name 'pointHitRadius';\n    pointHitRadius_: TJSArray; external name 'pointHitRadius';\n    { Point background color when hovered. }\n    pointHoverBackgroundColor: string;\n    pointHoverBackgroundColors: TJSStringDynArray; external name 'pointHoverBackgroundColor';\n    pointHoverBackgroundColor_: TJSArray; external name 'pointHoverBackgroundColor';\n    { Point border color when hovered. }\n    pointHoverBorderColor: string;\n    pointHoverBorderColors: TJSStringDynArray; external name 'pointHoverBorderColor';\n    pointHoverBorderColor_: TJSArray; external name 'pointHoverBorderColor';\n    { Border width of point when hovered. }\n    pointHoverBorderWidth: NativeUInt;\n    pointHoverBorderWidths: array of NativeUInt; external name 'pointHoverBorderWidth';\n    pointHoverBorderWidth_: TJSArray; external name 'pointHoverBorderWidth';\n    { The radius of the point when hovered. }\n    pointHoverRadius: NativeInt;\n    pointHoverRadiuses: array of NativeInt; external name 'pointHoverRadius';\n    pointHoverRadius_: TJSArray; external name 'pointHoverRadius';\n    { Array data passed to the chart. }\n    data: array of Integer;\n    datas: array of TChartXYData; external name 'data';\n    data_: TJSArray; external name 'data';\n  end;\n\n  { Unlike other charts, the radar chart has no chart specific options. }\n\n  { Doughnut dataset class. }\n  TChartDoughnutDataset = class external name 'Object' (TChartDataset)\n  public\n    { The fill color of the arcs in the dataset. }\n    backgroundColor: TJSStringDynArray;\n    backgroundColor_: TJSArray; external name 'backgroundColor';\n    { The border color of the arcs in the dataset. }\n    borderColor: TJSStringDynArray;\n    borderColor_: TJSArray; external name 'borderColor';\n    { The border width of the arcs in the dataset. }\n    borderWidth: array of NativeUInt;\n    borderWidth_: TJSArray; external name 'borderWidth';\n    { The fill colour of the arcs when hovered. }\n    hoverBackgroundColor: TJSStringDynArray;\n    hoverBackgroundColor_: TJSArray; external name 'hoverBackgroundColor';\n    { The stroke colour of the arcs when hovered. }\n    hoverBorderColor: TJSStringDynArray;\n    hoverBorderColor_: TJSArray; external name 'hoverBorderColor';\n    { The stroke width of the arcs when hovered. }\n    hoverBorderWidth: array of NativeUInt;\n    hoverBorderWidth_: TJSArray; external name 'hoverBorderWidth';\n    { Array data passed to the chart. }\n    data: array of Integer;\n    data_: TJSArray; external name 'data';\n  end;\n\n  { Doughnut options class. }\n  TChartDoughnutOptions = class external name 'Object' (TJSObject)\n  public\n    { The percentage of the chart that is cut out of the middle. }\n    cutoutPercentage: NativeInt;\n    { Starting angle to draw arcs from. }\n    rotation: Double;\n    { Sweep to allow arcs to cover. }\n    circumference: Double;\n    {\n    animation.animateRotate:\n      If true, the chart will animate in with a rotation animation. This\n      property is in the options.animation object.\n    animation.animateScale:\n      If true, will animate scaling the chart from the center outwards. }\n    animation: TChartAnimationConfiguration;\n  end;\n\n  { Pie dataset class. }\n  TChartPieDataset = class external name 'Object' (TChartDoughnutDataset)\n  end;\n\n  { Pie options class. }\n  TChartPieOptions = class external name 'Object' (TChartDoughnutOptions)\n  end;\n\n  { Polar area dataset class. }\n  TChartPolarAreaDataset = class external name 'Object' (TChartDataset)\n  public\n    { The fill color of the arcs in the dataset. }\n    backgroundColor: TJSStringDynArray;\n    backgroundColor_: TJSArray; external name 'backgroundColor';\n    { The border color of the arcs in the dataset. }\n    borderColor: TJSStringDynArray;\n    borderColor_: TJSArray; external name 'borderColor';\n    { The border width of the arcs in the dataset. }\n    borderWidth: array of NativeUInt;\n    borderWidth_: TJSArray; external name 'borderWidth';\n    { The fill colour of the arcs when hovered. }\n    hoverBackgroundColor: TJSStringDynArray;\n    hoverBackgroundColor_: TJSArray; external name 'hoverBackgroundColor';\n    { The stroke colour of the arcs when hovered. }\n    hoverBorderColor: TJSStringDynArray;\n    hoverBorderColor_: TJSArray; external name 'hoverBorderColor';\n    { The stroke width of the arcs when hovered. }\n    hoverBorderWidth: array of NativeUInt;\n    hoverBorderWidth_: TJSArray; external name 'hoverBorderWidth';\n    { Array data passed to the chart. }\n    data: array of Integer;\n    data_: TJSArray; external name 'data';\n  end;\n\n  { Polar area options class. }\n  TChartPolarAreaOptions = class external name 'Object' (TJSObject)\n  public\n    { Starting angle to draw arcs for the first item in a dataset. }\n    startAngle: Double;\n    {\n    animation.animateRotate:\n      If true, the chart will animate in with a rotation animation. This\n      property is in the options.animation object.\n    animation.animateScale:\n      If true, will animate scaling the chart from the center outwards. }\n    animation: TChartAnimationConfiguration;\n  end;\n\n  { Bubble dataset class. }\n  TChartBubbleDataset = class external name 'Object' (TChartDataset)\n  public\n    { Bubble background color. }\n    backgroundColor: string;\n    backgroundColor_: JSValue; external name 'backgroundColor';\n    { Bubble border color. }\n    borderColor: string;\n    borderColor_: JSValue; external name 'borderColor';\n    { Bubble border width (in pixels). }\n    borderWidth: NativeUInt;\n    borderWidth_: JSValue; external name 'borderWidth';\n    { Bubble background color when hovered. }\n    hoverBackgroundColor: string;\n    hoverBackgroundColor_: JSValue; external name 'hoverBackgroundColor';\n    { Bubble border color hovered. }\n    hoverBorderColor: string;\n    hoverBorderColor_: JSValue; external name 'hoverBorderColor';\n    { Bubble border width when hovered (in pixels). }\n    hoverBorderWidth: NativeUInt;\n    hoverBorderWidth_: JSValue; external name 'hoverBorderWidth';\n    { Bubble additional radius when hovered (in pixels). }\n    hoverRadius: NativeInt;\n    { Bubble additional radius for hit detection (in pixels). }\n    hitRadius: NativeInt;\n    { Bubble shape style. }\n    pointStyle: string;\n    { Bubble rotation (in degrees). }\n    rotation: NativeInt;\n    { Bubble radius (in pixels). }\n    radius: NativeInt;\n    radius_: JSValue; external name 'radius';\n    { Array data passed to the chart. }\n    data: array of TChartXYRData;\n    data_: TJSArray; external name 'data';\n  end;\n\n  { Bubble options class. }\n  TChartBubbleOptions = class(TChartOptions)\n  end;\n\n  { Scatter dataset class. }\n  TChartScatterDataset = class external name 'Object' (TChartLineDataset)\n  end;\n\n  { Scatter options class. }\n  TChartScatterOptions = class external name 'Object' (TChartOptions)\n  end;\n\n  { Default properties class. }\n  TChartDefaults = class external name 'Object' (TJSObject)\n  public\n    { Global properties of the chart. }\n    global: TChartOptions;\n    { Default line options. }\n    line: TChartLineOptions;\n    { Default bar options. }\n    bar: TChartBarOptions;\n    { Default doughnut options. }\n    doughnut: TChartDoughnutOptions;\n    { Default pie options. }\n    pie: TChartPieOptions;\n    { Default polar area options. }\n    polarArea: TChartPolarAreaOptions;\n    { Default bubble options. }\n    bubble: TChartBubbleOptions;\n    { Default scatter options. }\n    scatter: TChartScatterOptions;\n  end;\n\n  { ChartJS class. }\n  TChart = class external name 'Chart' (TJSObject)\n  public class var\n    { Default properties of the chart. }\n    defaults: TChartDefaults;\n    { Default configuration for the scales. }\n    scaleService: TCharScaleService;\n    { Plugins object. }\n    plugins: TChartPlugins;\n  public\n    { Configuration object. }\n    config: TChartConfiguration;\n    { Creates a new instante of TChart. }\n    constructor new(item: JSValue); overload;\n    { Creates a new instante of TChart. }\n    constructor new(item: JSValue; const config: JSValue); overload;\n    { Destroys any chart instances that are created. }\n    procedure destroy;\n    { Triggers an update of the chart. }\n    procedure update(const config: JSValue); overload;\n    procedure update; overload;\n    { Reset the chart to it's state before the initial animation. }\n    procedure reset;\n    { Triggers a redraw of all chart elements. }\n    procedure render(const config: JSValue); overload;\n    procedure render; overload;\n    { Stops any current animation loop. }\n    function stop: TChart;\n    { Resizes the canvas element. }\n    function resize: TChart;\n    { Clears the chart canvas. }\n    function clear: TChart;\n    { This returns a base 64 encoded string of the chart in it's current state. }\n    function toBase64Image: string;\n    { Returns a HTML string of a legend for that chart. }\n    function generateLegend: string;\n    { Returns the single element at the event position. }\n    function getElementAtEvent(ev: TJSEvent): TJSArray;\n    { Returns all elements at the same data index. }\n    function getElementsAtEvent(ev: TJSEvent): TJSArray;\n    { Looks for the element under the event point, then returns all elements\n      from that dataset. }\n    function getDatasetAtEvent(ev: TJSEvent): TJSArray;\n    { Looks for the dataset that matches the current index and returns that\n      metadata. }\n    function getDatasetMeta(index: Integer): JSValue;\n  end;\n\n  { Controller class. }\n  TChartController = class external name 'Chart' (TChart)\n  public\n    id: JSValue;\n    ctx: TJSCanvasRenderingContext2D;\n    canvas: TJSHTMLCanvasElement;\n    width: NativeUInt;\n    height:  NativeUInt;\n    aspectRatio: NativeInt;\n    options: TChartOptions;\n    controller: TChart;\n    data: TChartData;\n    scales: TJSObject;\n    lastActive: TJSArray;\n    active: TJSArray;\n    animating: Boolean;\n    boxes: TJSArray;\n    chartArea: TChartPadding;\n    _bufferedRender: Boolean;\n    _bufferedRequest: TJSObject;\n  end;\n\nimplementation\n\n{$PUSH}{$WARN 5027 OFF}\n\nconstructor TChartPluginsHook.new;\nvar\n  dummy: Pointer;\nbegin\n  dummy := @beforeInit;\n  dummy := @afterInit;\n  dummy := @beforeUpdate;\n  dummy := @afterUpdate;\n  dummy := @beforeDatasetsUpdate;\n  dummy := @afterDatasetsUpdate;\n  dummy := @beforeDatasetUpdate;\n  dummy := @afterDatasetUpdate;\n  dummy := @beforeLayout;\n  dummy := @afterLayout;\n  dummy := @beforeRender;\n  dummy := @afterRender;\n  dummy := @beforeDraw;\n  dummy := @afterDraw;\n  dummy := @beforeDatasetsDraw;\n  dummy := @afterDatasetsDraw;\n  dummy := @beforeDatasetDraw;\n  dummy := @afterDatasetDraw;\n  dummy := @beforeTooltipDraw;\n  dummy := @afterTooltipDraw;\n  dummy := @beforeEvent;\n  dummy := @afterEvent;\n  dummy := @resize;\n  dummy := @destroy;\nend;\n\n{$POP}\n\nprocedure TChartPluginsHook.beforeInit(chart: TChartController;\n  options: TChartOptions);\nbegin\nend;\n\nprocedure TChartPluginsHook.afterInit(chart: TChartController;\n  options: TChartOptions);\nbegin\nend;\n\nfunction TChartPluginsHook.beforeUpdate(chart: TChartController;\n  options: TChartOptions): Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TChartPluginsHook.afterUpdate(chart: TChartController;\n  options: TChartOptions);\nbegin\nend;\n\nfunction TChartPluginsHook.beforeDatasetsUpdate(chart: TChartController;\n  options: TChartOptions): Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TChartPluginsHook.afterDatasetsUpdate(chart: TChartController;\n  options: TChartOptions);\nbegin\nend;\n\nfunction TChartPluginsHook.beforeDatasetUpdate(chart: TChartController;\n  const args: TChartPluginsHookArgument; options: TChartOptions): Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TChartPluginsHook.afterDatasetUpdate(chart: TChartController;\n  const args: TChartPluginsHookArgument; options: TChartOptions);\nbegin\nend;\n\nfunction TChartPluginsHook.beforeLayout(chart: TChartController;\n  options: TChartOptions): Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TChartPluginsHook.afterLayout(chart: TChartController;\n  options: TChartOptions);\nbegin\nend;\n\nfunction TChartPluginsHook.beforeRender(chart: TChartController;\n  options: TChartOptions): Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TChartPluginsHook.afterRender(chart: TChartController;\n  options: TChartOptions);\nbegin\nend;\n\nfunction TChartPluginsHook.beforeDraw(chart: TChartController;\n  easingValue: NativeInt; options: TChartOptions): Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TChartPluginsHook.afterDraw(chart: TChartController;\n  easingValue: NativeInt; options: TChartOptions);\nbegin\nend;\n\nfunction TChartPluginsHook.beforeDatasetsDraw(chart: TChartController;\n  easingValue: NativeInt; options: TChartOptions): Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TChartPluginsHook.afterDatasetsDraw(chart: TChartController;\n  easingValue: NativeInt; options: TChartOptions);\nbegin\nend;\n\nfunction TChartPluginsHook.beforeDatasetDraw(chart: TChartController;\n  const args: TChartPluginsHookArgument; options: TChartOptions): Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TChartPluginsHook.afterDatasetDraw(chart: TChartController;\n  const args: TChartPluginsHookArgument; options: TChartOptions);\nbegin\nend;\n\nfunction TChartPluginsHook.beforeTooltipDraw(chart: TChartController;\n  const args: TChartPluginsHookArgument; options: TChartOptions): Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TChartPluginsHook.afterTooltipDraw(chart: TChartController;\n  const args: TChartPluginsHookArgument; options: TChartOptions);\nbegin\nend;\n\nprocedure TChartPluginsHook.beforeEvent(chart: TChartController;\n  event: TJSEvent; options: TChartOptions);\nbegin\nend;\n\nprocedure TChartPluginsHook.afterEvent(chart: TChartController;\n  event: TJSEvent; options: TChartOptions);\nbegin\nend;\n\nprocedure TChartPluginsHook.resize(chart: TChartController; size: NativeInt;\n  options: TChartOptions);\nbegin\nend;\n\nprocedure TChartPluginsHook.destroy(chart: TChartController;\n  options: TChartOptions);\nbegin\nend;\n\n{ TChartXYData }\n\nconstructor TChartXYData.new(const x, y: JSValue);\nbegin\n  Self.x := x;\n  Self.y := y;\nend;\n\nconstructor TChartXYData.new(const x: JSValue);\nbegin\n  Self.x := x;\n  Self.y := 0;\nend;\n\n{ TChartTYData }\n\nconstructor TChartTYData.new(const t, y: JSValue);\nbegin\n  Self.t := t;\n  Self.y := y;\nend;\n\nconstructor TChartTYData.new(const t: JSValue);\nbegin\n  Self.t := t;\n  Self.y := 0;\nend;\n\n{ TChartXYRData }\n\nconstructor TChartXYRData.new(const x, y, r: JSValue);\nbegin\n  Self.x := x;\n  Self.y := y;\n  Self.r := r;\nend;\n\nconstructor TChartXYRData.new(const x, y: JSValue);\nbegin\n  Self.x := x;\n  Self.y := y;\n  Self.r := 0;\nend;\n\nconstructor TChartXYRData.new(const x: JSValue);\nbegin\n  Self.x := x;\n  Self.y := 0;\n  Self.r := 0;\nend;\n\n{ TChartXYVData }\n\nconstructor TChartXYVData.new(const x, y, v: JSValue);\nbegin\n  Self.x := x;\n  Self.y := y;\n  Self.v := v;\nend;\n\nconstructor TChartXYVData.new(const x, y: JSValue);\nbegin\n  Self.x := x;\n  Self.y := y;\n  Self.v := 0;\nend;\n\nconstructor TChartXYVData.new(const x: JSValue);\nbegin\n  Self.x := x;\n  Self.y := 0;\n  Self.v := 0;\nend;\n\nend.\n","program demoarea;\n\n{$MODE OBJFPC}\n{$MODESWITCH EXTERNALCLASS}\n\nuses\n  JS,\n  Math,\n  ChartJS;\n\nfunction randomScalingFactor: NativeUInt;\nbegin\n  Result := RandomRange(-100, 100);\nend;\n\nvar\n  config: TChartConfiguration;\n  dataset: TChartLineDataset;\nbegin\n  config := TChartConfiguration.new;\n  config.type_ := 'line';\n  config.data := TChartData.new;\n  config.data.labels := ['January', 'February', 'March', 'April', 'May',\n    'June', 'July'];\n\n  dataset := TChartLineDataset.new;\n  dataset.label_ := 'My First dataset';\n  dataset.borderColor := 'rgb(255, 99, 132)';\n  dataset.backgroundColor := 'rgb(255, 99, 132)';\n  dataset.data := [randomScalingFactor, randomScalingFactor,\n    randomScalingFactor, randomScalingFactor, randomScalingFactor,\n    randomScalingFactor, randomScalingFactor];\n  config.data.datasets_ := TJSArray.new;\n  config.data.datasets_.push(dataset);\n\n  dataset := TChartLineDataset.new;\n  dataset.label_ := 'My Second dataset';\n  dataset.borderColor := 'rgb(54, 162, 235)';\n  dataset.backgroundColor := 'rgb(54, 162, 235)';\n  dataset.data := [randomScalingFactor, randomScalingFactor,\n    randomScalingFactor, randomScalingFactor, randomScalingFactor,\n    randomScalingFactor, randomScalingFactor];\n  config.data.datasets_.push(dataset);\n\n  dataset := TChartLineDataset.new;\n  dataset.label_ := 'My Third dataset';\n  dataset.borderColor := 'rgb(75, 192, 192)';\n  dataset.backgroundColor := 'rgb(75, 192, 192)';\n  dataset.data := [randomScalingFactor, randomScalingFactor,\n    randomScalingFactor, randomScalingFactor, randomScalingFactor,\n    randomScalingFactor, randomScalingFactor];\n  config.data.datasets_.push(dataset);\n\n  dataset := TChartLineDataset.new;\n  dataset.label_ := 'My Four dataset';\n  dataset.borderColor := 'rgb(255, 205, 86)';\n  dataset.backgroundColor := 'rgb(255, 205, 86)';\n  dataset.data := [randomScalingFactor, randomScalingFactor,\n    randomScalingFactor, randomScalingFactor, randomScalingFactor,\n    randomScalingFactor, randomScalingFactor];\n  config.data.datasets_.push(dataset);\n\n  TChart.new('myChart', config);\nend.\n"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxzCA;;;AAyFS;;;;;AAwqBiB;AAAC;AAAD;AA8BS;;AAKA;;AA3sB1B;AAuVM;AAEf;AAFe;AAubf;AACE,mBAAU;nBADZ;AAv2BA;ACAA,iBAKS,UALT;;;;3BCAA,uBAIS,eAJT;;;tCA+ZiB;;AA4Df;AA41HF;AACE,0BAAkB,oBAAe,QAAC;tDADpC;AAvzIA;ACAA,mBAIS,qBAJT;;;xCAuOoB;AAAX;AAEP,aAAQ,iBAAM,CAAC,QAAG,CAAC,KAAK,GAAC,GAAP,CAAJ,CAAgB,GAAC,QAAG,CAAC,IAAI,KAAL,CAAJ;3EAFvB;AAAW;AAvOpB;ACGA,sBAKS,eALT;;;;rCCfA,sBAAiB,gCAAjB;;;tDAU4B;AAAnB;AAEP,aAAU,oBAAW,CAAC,CAAC,IAAK,GAAP;1CAFd;AAAmB;AAM1B;AACA;AACF;AACE,kBAA8B,IAApB,MAAoB;5BAC9B,eAAM,KAAN,GAAgB;vBAChB,eAAM,KAAN,GAA0B,IAAX,MAAW;jCAC1B,eAAM,KAAK,OAAX,GAAsB,CAAC,UAAW,WAAY,QAAS,QAAS,MAC9D,OAAQ,MADY;vFAGtB,mBAA6B,IAAlB,MAAkB;7BAC7B,gBAAO,MAAP,GAAkB;zBAClB,gBAAO,YAAP,GAAuB;/BACvB,gBAAO,gBAAP,GAA2B;nCAC3B,gBAAO,KAAP,GAAgB,CAAC,2BAAqB,2BACpC,2BAAqB,2BAAqB,2BAC1C,2BAAqB,0BAFP;rNAGhB,eAAM,KAAK,SAAX,GAAkC,IAAT,KAAS;zCAClC,eAAM,KAAK,SAAU,KAAK,CAAC,YAAD;/CAE1B,mBAA6B,IAAlB,MAAkB;7BAC7B,gBAAO,MAAP,GAAkB;zBAClB,gBAAO,YAAP,GAAuB;/BACvB,gBAAO,gBAAP,GAA2B;nCAC3B,gBAAO,KAAP,GAAgB,CAAC,2BAAqB,2BACpC,2BAAqB,2BAAqB,2BAC1C,2BAAqB,0BAFP;rNAGhB,eAAM,KAAK,SAAU,KAAK,CAAC,YAAD;/CAE1B,mBAA6B,IAAlB,MAAkB;7BAC7B,gBAAO,MAAP,GAAkB;zBAClB,gBAAO,YAAP,GAAuB;/BACvB,gBAAO,gBAAP,GAA2B;nCAC3B,gBAAO,KAAP,GAAgB,CAAC,2BAAqB,2BACpC,2BAAqB,2BAAqB,2BAC1C,2BAAqB,0BAFP;rNAGhB,eAAM,KAAK,SAAU,KAAK,CAAC,YAAD;/CAE1B,mBAA6B,IAAlB,MAAkB;7BAC7B,gBAAO,MAAP,GAAkB;zBAClB,gBAAO,YAAP,GAAuB;/BACvB,gBAAO,gBAAP,GAA2B;nCAC3B,gBAAO,KAAP,GAAgB,CAAC,2BAAqB,2BACpC,2BAAqB,2BAAqB,2BAC1C,2BAAqB,0BAFP;rNAGhB,eAAM,KAAK,SAAU,KAAK,CAAC,YAAD;/CAEnB,QAAP,KAAO,CAAI,UAAW,WAAf;nCA5CT;AAlBA"}